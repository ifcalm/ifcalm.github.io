<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="Go 是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang 编程面试问题总结">
<meta property="og:url" content="http://example.com/2020/06/08/go-interview/index.html">
<meta property="og:site_name" content="缘起">
<meta property="og:description" content="Go 是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-06-08T14:47:07.000Z">
<meta property="article:modified_time" content="2021-01-31T07:17:56.546Z">
<meta property="article:author" content="ifcalm">
<meta property="article:tag" content="Golang">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2020/06/08/go-interview/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>Golang 编程面试问题总结 | 缘起</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">缘起</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">种瓜的瓜, 种豆得豆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E5%AE%89%E5%85%A8%E8%AF%BB%E5%86%99%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F"><span class="nav-number">1.</span> <span class="nav-text">Golang中有哪些方式安全读写共享变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E7%BC%93%E5%86%B2-chan-%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%98%AF%E5%90%A6%E5%90%8C%E6%AD%A5"><span class="nav-number">2.</span> <span class="nav-text">无缓冲 chan 的发送和接收是否同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">go语言的并发机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E7%9A%84-CSP-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.</span> <span class="nav-text">go语言使用的 CSP 并发模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Golang%E4%B8%AD%E7%9A%84Goroutine%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">4.1.</span> <span class="nav-text">Golang中的Goroutine的特性:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.</span> <span class="nav-text">Golang 中常用的并发模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87channel%E9%80%9A%E9%81%93%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-number">5.1.</span> <span class="nav-text">通过channel通道实现并发控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87sync%E5%8C%85%E4%B8%AD%E7%9A%84WaitGroup%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-number">5.2.</span> <span class="nav-text">通过sync包中的WaitGroup实现并发控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Context%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-number">5.3.</span> <span class="nav-text">使用Context上下文，实现并发控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang%E4%B8%AD-json-%E6%A0%87%E5%87%86%E5%BA%93%E5%AF%B9-nil-slice-%E5%92%8C-%E7%A9%BA-slice-%E7%9A%84%E5%A4%84%E7%90%86%E6%98%AF%E4%B8%80%E8%87%B4%E7%9A%84%E5%90%97"><span class="nav-number">6.</span> <span class="nav-text">Golang中 json 标准库对 nil slice 和 空 slice 的处理是一致的吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%8F%E5%AF%B9%E8%B1%A1%E5%A4%9A%E4%BA%86%E4%BC%9A%E9%80%A0-GC-%E6%88%90%E5%8E%8B%E5%8A%9B"><span class="nav-number">7.</span> <span class="nav-text">Golang 的内存模型，为什么小对象多了会造 GC 成压力</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Data-Race-%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3-%E8%83%BD%E4%B8%8D%E8%83%BD%E4%B8%8D%E5%8A%A0%E9%94%81%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="nav-number">8.</span> <span class="nav-text">Data Race 问题怎么解决, 能不能不加锁解决这个问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-channel%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%88%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">9.</span> <span class="nav-text">什么是 channel，为什么它可以做到线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang-GC-%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="nav-number">10.</span> <span class="nav-text">Golang GC 时会发生什么</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">10.1.</span> <span class="nav-text">什么是垃圾回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">10.2.</span> <span class="nav-text">常用的垃圾回收的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-number">10.2.1.</span> <span class="nav-text">引用计数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4"><span class="nav-number">10.2.2.</span> <span class="nav-text">标记-清除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%90%9C%E9%9B%86"><span class="nav-number">10.2.3.</span> <span class="nav-text">分代搜集</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Golang-GC-%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88-1"><span class="nav-number">10.3.</span> <span class="nav-text">Golang GC 时会发生什么</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang-%E4%B8%AD-Goroutine-%E5%A6%82%E4%BD%95%E8%B0%83%E5%BA%A6"><span class="nav-number">11.</span> <span class="nav-text">Golang 中 Goroutine 如何调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">12.</span> <span class="nav-text">并发编程概念是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#etcd-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84"><span class="nav-number">13.</span> <span class="nav-text">etcd 怎么实现分布式锁的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%A0%88%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="nav-number">14.</span> <span class="nav-text">Go语言的栈空间管理是怎么样的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Goroutine%E5%92%8CChannel%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">15.</span> <span class="nav-text">Goroutine和Channel的作用分别是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%BC%8Fchannel"><span class="nav-number">15.1.</span> <span class="nav-text">阻塞式channel</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8BGoroutine%E7%9A%84%E6%95%B0%E9%87%8F"><span class="nav-number">16.</span> <span class="nav-text">怎么查看Goroutine的数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">17.</span> <span class="nav-text">Go中的锁有哪些</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">17.1.</span> <span class="nav-text">互斥锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">17.2.</span> <span class="nav-text">读写锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sync-Map%E5%AE%89%E5%85%A8%E9%94%81"><span class="nav-number">17.3.</span> <span class="nav-text">sync.Map安全锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E6%88%96%E8%80%85%E4%BA%92%E6%96%A5%E9%94%81%E8%AF%BB%E7%9A%84%E6%97%B6%E5%80%99%E8%83%BD%E5%86%99%E5%90%97"><span class="nav-number">18.</span> <span class="nav-text">读写锁或者互斥锁读的时候能写吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E9%99%90%E5%88%B6Goroutine%E7%9A%84%E6%95%B0%E9%87%8F"><span class="nav-number">19.</span> <span class="nav-text">怎么限制Goroutine的数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84"><span class="nav-number">20.</span> <span class="nav-text">Channel是同步的还是异步的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">21.</span> <span class="nav-text">异步和非阻塞的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang%E4%B8%AD-log%E5%8C%85%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97"><span class="nav-number">22.</span> <span class="nav-text">Golang中 log包线程安全吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Goroutine%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">23.</span> <span class="nav-text">Goroutine和线程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go%E7%9A%84%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86"><span class="nav-number">24.</span> <span class="nav-text">Go的调度原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go-struct%E8%83%BD%E4%B8%8D%E8%83%BD%E6%AF%94%E8%BE%83"><span class="nav-number">25.</span> <span class="nav-text">go struct能不能比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go%E7%9A%84-defer-%E7%94%A8%E6%B3%95%E4%B8%8E%E7%90%86%E8%A7%A3"><span class="nav-number">26.</span> <span class="nav-text">go的 defer 用法与理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88"><span class="nav-number">27.</span> <span class="nav-text">select可以用于什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#context%E5%8C%85%E7%9A%84%E7%94%A8%E9%80%94%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">28.</span> <span class="nav-text">context包的用途是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%8D%8F%E7%A8%8B%E5%A6%82%E4%BD%95%E7%AD%89%E5%85%B6%E4%BD%99%E5%8D%8F%E7%A8%8B%E5%AE%8C%E5%86%8D%E6%93%8D%E4%BD%9C"><span class="nav-number">29.</span> <span class="nav-text">主协程如何等其余协程完再操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slice-%E7%9A%84-len-%E5%92%8C-cap%EF%BC%8C%E5%85%B1%E4%BA%AB%E4%B8%8E%E6%89%A9%E5%AE%B9"><span class="nav-number">30.</span> <span class="nav-text">slice 的 len 和 cap，共享与扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map%E5%A6%82%E4%BD%95%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%8F%96"><span class="nav-number">31.</span> <span class="nav-text">map如何顺序读取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go-%E5%AE%9E%E7%8E%B0-set"><span class="nav-number">32.</span> <span class="nav-text">go 实现 set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang-%E9%87%8C%E7%9A%84%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E6%98%AF%E4%BB%80%E4%B9%88-%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8"><span class="nav-number">33.</span> <span class="nav-text">Golang 里的逃逸分析是什么, 怎么避免内存逃逸</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88"><span class="nav-number">33.1.</span> <span class="nav-text">什么是栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86"><span class="nav-number">33.2.</span> <span class="nav-text">什么是堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E9%80%83%E9%80%B8"><span class="nav-number">33.3.</span> <span class="nav-text">变量逃逸</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang-%E7%9A%84GC%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">34.</span> <span class="nav-text">Golang 的GC触发时机是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Etcd%E7%9A%84Raft%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="nav-number">35.</span> <span class="nav-text">Etcd的Raft一致性算法原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go%E7%9A%84%E5%8F%8D%E5%B0%84%E5%8C%85"><span class="nav-number">36.</span> <span class="nav-text">Go的反射包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go%E5%AE%9E%E7%8E%B0-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">37.</span> <span class="nav-text">go实现 生产者消费者模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sync-Pool-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">38.</span> <span class="nav-text">sync.Pool 的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GMP-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="nav-number">39.</span> <span class="nav-text">GMP 调度模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">40.</span> <span class="nav-text">Go 的垃圾回收是怎么实现的, 优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">41.</span> <span class="nav-text">三色标记算法的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%8B-slice-%E5%9C%A8-append-%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">42.</span> <span class="nav-text">描述下 slice 在 append 时发生了什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%8B%E5%8F%98%E9%87%8F%E9%80%83%E9%80%B8"><span class="nav-number">43.</span> <span class="nav-text">解释下变量逃逸</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98"><span class="nav-number">44.</span> <span class="nav-text">go 语法基础问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Go-%E5%85%81%E8%AE%B8%E5%A4%9A%E4%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC%E5%90%97"><span class="nav-number">44.1.</span> <span class="nav-text">Go 允许多个返回值吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Go-%E6%9C%89%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E5%90%97"><span class="nav-number">44.2.</span> <span class="nav-text">Go 有异常类型吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-rune-%E7%B1%BB%E5%9E%8B"><span class="nav-number">44.3.</span> <span class="nav-text">什么是 rune 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD-map-%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA-key"><span class="nav-number">44.4.</span> <span class="nav-text">如何判断 map 中是否包含某个 key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#go-%E5%A6%82%E4%BD%95%E4%BA%A4%E6%8D%A2-2-%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC"><span class="nav-number">44.5.</span> <span class="nav-text">go 如何交换 2 个变量的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Go-%E8%AF%AD%E8%A8%80-tag-%E7%9A%84%E7%94%A8%E5%A4%84"><span class="nav-number">44.6.</span> <span class="nav-text">Go 语言 tag 的用处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD-2-%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87%E6%98%AF%E7%9B%B8%E7%AD%89%E7%9A%84"><span class="nav-number">44.7.</span> <span class="nav-text">如何判断 2 个字符串切片是相等的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%93%E5%8D%B0%E6%97%B6%EF%BC%8C-v-%E5%92%8C-v-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">44.8.</span> <span class="nav-text">字符串打印时，%v 和 %+v 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E6%9E%9A%E4%B8%BE%E5%80%BC"><span class="nav-number">44.9.</span> <span class="nav-text">Go 语言中如何表示枚举值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA-struct-%E7%9A%84%E7%94%A8%E9%80%94"><span class="nav-number">44.10.</span> <span class="nav-text">空 struct&amp;#123;&amp;#125; 的用途</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#init-%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="nav-number">44.11.</span> <span class="nav-text">init() 函数是什么时候执行的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Go-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%88%86%E9%85%8D%E5%9C%A8%E6%A0%88%E4%B8%8A%E8%BF%98%E6%98%AF%E5%A0%86%E4%B8%8A"><span class="nav-number">44.12.</span> <span class="nav-text">Go 语言的局部变量分配在栈上还是堆上</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%AA-interface-%E5%8F%AF%E4%BB%A5%E6%AF%94%E8%BE%83%E5%90%97"><span class="nav-number">44.13.</span> <span class="nav-text">2 个 interface 可以比较吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%AA-nil-%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9B%B8%E7%AD%89%E5%90%97"><span class="nav-number">44.14.</span> <span class="nav-text">2 个 nil 可能不相等吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88%E6%98%AF%E5%90%A6%E5%AE%89%E5%85%A8"><span class="nav-number">44.15.</span> <span class="nav-text">函数返回局部变量的指针是否安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B-T-%E9%83%BD%E8%83%BD%E5%A4%9F%E8%B0%83%E7%94%A8-T-%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%97"><span class="nav-number">44.16.</span> <span class="nav-text">非接口的任意类型 T() 都能够调用 *T 的方法吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B%E6%B3%84%E9%9C%B2"><span class="nav-number">44.17.</span> <span class="nav-text">什么是协程泄露</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Go-%E5%8F%AF%E4%BB%A5%E9%99%90%E5%88%B6%E8%BF%90%E8%A1%8C%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F%E5%90%97"><span class="nav-number">44.18.</span> <span class="nav-text">Go 可以限制运行时操作系统线程的数量吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%BC%93%E5%86%B2%E7%9A%84-channel-%E5%92%8C%E6%9C%89%E7%BC%93%E5%86%B2%E7%9A%84-channel-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">44.19.</span> <span class="nav-text">无缓冲的 channel 和有缓冲的 channel 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#go%E7%9A%84%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="nav-number">44.20.</span> <span class="nav-text">go的组合继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#select-%E9%9A%8F%E6%9C%BA%E6%80%A7"><span class="nav-number">44.21.</span> <span class="nav-text">select 随机性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defer-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">44.22.</span> <span class="nav-text">defer 执行顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#interface-%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">44.23.</span> <span class="nav-text">interface 内部结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#goto"><span class="nav-number">44.24.</span> <span class="nav-text">goto</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%AF%94%E8%BE%83"><span class="nav-number">44.25.</span> <span class="nav-text">结构体比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#go-%E9%97%AD%E5%8C%85"><span class="nav-number">44.26.</span> <span class="nav-text">go 闭包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#panic-%E4%B8%8E-revover"><span class="nav-number">44.27.</span> <span class="nav-text">panic 与 revover</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8Eslice%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">44.28.</span> <span class="nav-text">数组与slice的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Golang-%E6%98%AF%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%90%97"><span class="nav-number">44.29.</span> <span class="nav-text">Golang 是面对对象语言吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#golang-%E6%B2%A1%E6%9C%89%E4%B8%89%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">44.30.</span> <span class="nav-text">golang 没有三元操作符 : ?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new-%E4%B8%8E-make-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">44.31.</span> <span class="nav-text">new() 与 make() 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#go%E7%9A%84mutex%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B9%90%E8%A7%82%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E5%88%86%E5%88%AB%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">44.32.</span> <span class="nav-text">go的mutex怎么使用，乐观和悲观锁分别怎么实现，使用场景是什么</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ifcalm</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/08/go-interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ifcalm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘起">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Golang 编程面试问题总结
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-08 22:47:07" itemprop="dateCreated datePublished" datetime="2020-06-08T22:47:07+08:00">2020-06-08</time>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

            <div class="post-description">Go 是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h3 id="Golang中有哪些方式安全读写共享变量"><a href="#Golang中有哪些方式安全读写共享变量" class="headerlink" title="Golang中有哪些方式安全读写共享变量"></a>Golang中有哪些方式安全读写共享变量</h3><ul>
<li><code>sync.Mutex</code> 互斥锁</li>
<li><code>channel</code></li>
</ul>
<h3 id="无缓冲-chan-的发送和接收是否同步"><a href="#无缓冲-chan-的发送和接收是否同步" class="headerlink" title="无缓冲 chan 的发送和接收是否同步"></a>无缓冲 <code>chan</code> 的发送和接收是否同步</h3><p><code>ch := make(chan int)</code> 无缓冲的<code>channel</code>由于没有缓冲发送和接收需要同步<br><code>ch := make(chan int, 2)</code> 有缓冲<code>channel</code>不要求发送和接收操作同步</p>
<h3 id="go语言的并发机制"><a href="#go语言的并发机制" class="headerlink" title="go语言的并发机制"></a>go语言的并发机制</h3><h3 id="go语言使用的-CSP-并发模型"><a href="#go语言使用的-CSP-并发模型" class="headerlink" title="go语言使用的 CSP 并发模型"></a>go语言使用的 <code>CSP</code> 并发模型</h3><p><code>CSP</code>模型是上个世纪七十年代提出的,不同于传统的多线程<strong>通过共享内存来通信</strong>，<code>CSP</code>讲究的是<strong>以通信的方式来共享内存</strong>。用于描述两个独立的并发实体通过共享的通讯<code>channel</code>进行通信的并发模型。 <code>CSP</code>中 <code>channel</code>是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的<code>channel</code></p>
<p>Golang中<code>channel</code> 是被单独创建并且可以在进程之间传递，它的通信模式类似于生产者消费者模式，一个实体通过将消息发送到<code>channel</code> 中，然后有监听这个 <code>channel</code> 的实体处理，两个实体之间是匿名的，这个就实现实体中间的解耦，其中 <code>channel</code> 是同步的一个消息被发送到 <code>channel</code> 中，最终是一定要被另外的实体消费掉的，在实现原理上其实类似一个阻塞的消息队列</p>
<p><code>Goroutine</code> 是Golang实际并发执行的实体，它底层是使用协程<code>coroutine</code>实现并发，<code>coroutine</code>是一种运行在用户态的用户线程，底层选择使用<code>coroutine</code>的出发点是因为，它具有以下特点:</p>
<ul>
<li>用户空间避免了内核态和用户态的切换导致的成本</li>
<li>可以由语言和框架层进行调度</li>
<li>更小的栈空间允许创建大量的实例</li>
</ul>
<p>Golang的<code>CSP</code>并发模型，是通过<code>Goroutine</code>和<code>Channel</code>来实现的</p>
<p><code>Goroutine</code> 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的<strong>线程</strong>类似，可以理解为<strong>线程</strong>。 <code>Channel</code>是Go语言中各个并发结构体(Goroutine)之前的通信机制。通常<code>Channel</code>，是各个<code>Goroutine</code>之间通信的<strong>管道</strong>，有点类似于Linux中的管道</p>
<h4 id="Golang中的Goroutine的特性"><a href="#Golang中的Goroutine的特性" class="headerlink" title="Golang中的Goroutine的特性:"></a>Golang中的<code>Goroutine</code>的特性:</h4><p>Golang内部有三个对象:</p>
<ul>
<li>G（Goroutine）对象, Goroutine 我们所说的协程，为用户级的轻量级线程，每个 Goroutine 对象中的sched保存着其上下文信息</li>
<li>M（Machine）对象, 数量对应真实的CPU数, 真正干活的对象</li>
<li>P（Processor）对象, 即为<code>G</code>和<code>M</code>的调度对象，用来调度<code>G</code>和<code>M</code>之间的关联关系，其数量可通过<code>GOMAXPROCS()</code>来设置，默认为核心数</li>
</ul>
<p>在单核情况下，所有<code>Goroutine</code>运行在同一个线程（M0）中，每一个线程维护一个上下文（P），任何时刻，一个上下文中只有一个<code>Goroutine</code>，其他<code>Goroutine</code>在<code>runqueue</code>中等待</p>
<p>一个<code>Goroutine</code>运行完自己的时间片后，让出上下文，自己回到<code>runqueue</code>中</p>
<p>Golang是为并发而生的语言，Go语言是为数不多的在语言层面实现并发的语言</p>
<h3 id="Golang-中常用的并发模型"><a href="#Golang-中常用的并发模型" class="headerlink" title="Golang 中常用的并发模型"></a>Golang 中常用的并发模型</h3><h4 id="通过channel通道实现并发控制"><a href="#通过channel通道实现并发控制" class="headerlink" title="通过channel通道实现并发控制"></a>通过<code>channel</code>通道实现并发控制</h4><p>无缓冲的通道指的是通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送 <code>goroutine</code> 和接收 <code>goroutine</code> 同时准备好，才可以完成发送和接收操作</p>
<p>从无缓冲的通道定义来看，发送 <code>goroutine</code> 和接收 <code>gouroutine</code> 必须是同步的，如果没有同时准备好的话，先执行的操作就会阻塞等待，直到另一个相对应的操作准备好为止。这种无缓冲的通道我们也称之为<strong>同步通道</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    ch :&#x3D; make(chan struct&#123;&#125;)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        fmt.Println(&quot;start ...&quot;)</span><br><span class="line">        time.Sleep(time.Second * 2)</span><br><span class="line">        ch&lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;-ch</span><br><span class="line">    fmt.Println(&quot;finished&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当主 <code>goroutine</code> 运行到 <code>&lt;-ch</code> 接受 <code>channel</code> 的值的时候，如果该 <code>channel</code> 中没有数据，就会一直阻塞等待，直到有值。 这样就可以简单实现并发控制</p>
<h4 id="通过sync包中的WaitGroup实现并发控制"><a href="#通过sync包中的WaitGroup实现并发控制" class="headerlink" title="通过sync包中的WaitGroup实现并发控制"></a>通过<code>sync</code>包中的<code>WaitGroup</code>实现并发控制</h4><p><code>Goroutine</code>是异步执行的，有的时候为了防止在结束<code>mian</code>函数的时候结束掉<code>Goroutine</code>，所以需要同步等待，这个时候就需要用 <code>WaitGroup</code>了，在 <code>sync</code> 包中，提供了 <code>WaitGroup</code>，它会等待它收集的所有 <code>goroutine</code> 任务全部完成。在<code>WaitGroup</code>里主要有三个方法:</p>
<ul>
<li>Add(), 可以添加或减少 <code>goroutine</code>的数量</li>
<li>Done(), 相当于<code>Add(-1)</code></li>
<li>Wait(), 执行后会堵塞主线程，直到<code>WaitGroup</code>里的值减至0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    var urls &#x3D; []string&#123;</span><br><span class="line">        &quot;https:&#x2F;&#x2F;google.com&quot;,</span><br><span class="line">        &quot;https:&#x2F;&#x2F;baidu.com&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    for _, url :&#x3D; range urls &#123;</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go func(url string) &#123;</span><br><span class="line">            defer wg.Done()</span><br><span class="line">            http.Get(url)</span><br><span class="line">        &#125;(url)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用Context上下文，实现并发控制"><a href="#使用Context上下文，实现并发控制" class="headerlink" title="使用Context上下文，实现并发控制"></a>使用<code>Context</code>上下文，实现并发控制</h4><p>通常在一些简单场景下使用 <code>channel</code> 和 <code>WaitGroup</code> 已经足够了，但是当面临一些复杂多变的网络并发场景下 <code>channel</code> 和 <code>WaitGroup</code> 显得有些力不从心了。 比如一个网络请求 Request，每个 Request 都需要开启一个 <code>goroutine</code> 做一些事情，这些 <code>goroutine</code> 又可能会开启其他的 <code>goroutine</code>，比如数据库和RPC服务。 所以我们需要一种可以跟踪 <code>goroutine</code> 的方案，才可以达到控制他们的目的，这就是Go语言为我们提供的 <code>Context</code>，称之为上下文非常贴切，它就是<code>goroutine</code> 的上下文。 它是包括一个程序的运行环境、现场和快照等。每个程序要运行时，都需要知道当前程序的运行状态，通常Go 将这些封装在一个 <code>Context</code> 里，再将它传给要执行的 <code>goroutine</code></p>
<p><code>context</code> 包主要是用来处理多个 <code>goroutine</code> 之间共享数据，及多个 <code>goroutine</code> 的管理</p>
<h3 id="Golang中-json-标准库对-nil-slice-和-空-slice-的处理是一致的吗"><a href="#Golang中-json-标准库对-nil-slice-和-空-slice-的处理是一致的吗" class="headerlink" title="Golang中 json 标准库对 nil slice 和 空 slice 的处理是一致的吗"></a>Golang中 <code>json</code> 标准库对 <code>nil slice</code> 和 <code>空 slice</code> 的处理是一致的吗</h3><h3 id="Golang-的内存模型，为什么小对象多了会造-GC-成压力"><a href="#Golang-的内存模型，为什么小对象多了会造-GC-成压力" class="headerlink" title="Golang 的内存模型，为什么小对象多了会造 GC 成压力"></a>Golang 的内存模型，为什么小对象多了会造 GC 成压力</h3><p>通常小对象过多会导致GC三色法消耗过多的GPU, 优化思路是，减少对象分配</p>
<h3 id="Data-Race-问题怎么解决-能不能不加锁解决这个问题"><a href="#Data-Race-问题怎么解决-能不能不加锁解决这个问题" class="headerlink" title="Data Race 问题怎么解决, 能不能不加锁解决这个问题"></a><code>Data Race</code> 问题怎么解决, 能不能不加锁解决这个问题</h3><h3 id="什么是-channel，为什么它可以做到线程安全"><a href="#什么是-channel，为什么它可以做到线程安全" class="headerlink" title="什么是 channel，为什么它可以做到线程安全"></a>什么是 <code>channel</code>，为什么它可以做到线程安全</h3><p><code>Channel</code>是Go中的一个核心类型，可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯, <code>Channel</code>也可以理解是一个先进先出的队列，通过管道进行通信</p>
<p>Golang的<code>Channel</code>,发送一个数据到<code>Channel</code> 和 从<code>Channel</code>接收一个数据都是<strong>原子性</strong>的。而且Go的设计思想就是<strong>不要通过共享内存来通信，而是通过通信来共享内存</strong>，前者就是传统的<strong>加锁</strong>，后者就是<code>Channel</code>。也就是说，设计<code>Channel</code>的主要目的就是在多任务间传递数据的，这当然是安全的</p>
<h3 id="Golang-GC-时会发生什么"><a href="#Golang-GC-时会发生什么" class="headerlink" title="Golang GC 时会发生什么"></a>Golang GC 时会发生什么</h3><h4 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a>什么是垃圾回收</h4><p>内存管理是程序员开发应用的一大难题。传统的系统级编程语言，主要指<code>C/C++</code>中，程序开发者必须对内存小心的进行管理操作，控制内存的申请及释放。因为稍有不慎，就可能产生内存泄露问题，这种问题不易发现并且难以定位，一直成为困扰程序开发者的噩梦。那如何解决这个头疼的问题呢</p>
<ul>
<li>内存泄露检测工具。这种工具的原理一般是静态代码扫描，通过扫描程序检测可能出现内存泄露的代码段。然而检测工具难免有疏漏和不足，只能起到辅助作用</li>
<li>智能指针。这是 <code>c++</code> 中引入的自动内存管理方法，通过拥有自动内存管理功能的指针对象来引用对象，是程序员不用太关注内存的释放，而达到内存自动释放的目的。这种方法是采用最广泛的做法，但是对程序开发者有一定的学习成本，而且一旦有忘记使用的场景依然无法避免内存泄露</li>
</ul>
<p>为了解决这个问题，后来开发出来的几乎所有新语言都引入了语言层面的自动内存管理, 也就是语言的使用者只用关注内存的申请而不必关心内存的释放，内存释放由虚拟机<code>virtual machine</code>或运行时<code>runtime</code>来自动进行管理。而<strong>这种对不再使用的内存资源进行自动回收的行为就被称为垃圾回收</strong></p>
<h4 id="常用的垃圾回收的方法"><a href="#常用的垃圾回收的方法" class="headerlink" title="常用的垃圾回收的方法"></a>常用的垃圾回收的方法</h4><h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h5><p>这是最简单的一种垃圾回收算法，和之前提到的智能指针类似。对每个对象维护一个引用计数，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减一，当被引用对象被创建或被赋值给其他对象时引用计数自动加一。当引用计数为0时则立即回收对象。这种方法的优点是实现简单，并且内存的回收很及时。这种算法在内存比较紧张和实时性比较高的系统中使用的比较广泛，如php，python等</p>
<p>简单引用计数算法也有明显的缺点:</p>
<ul>
<li>频繁更新引用计数降低了性能</li>
<li>当对象间发生循环引用时引用链中的对象都无法得到释放</li>
</ul>
<h5 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h5><p>标记-清除分为两步，标记从根变量开始迭代遍历所有被引用的对象，对能够通过应用遍历访问到的对象都标记为<strong>被引用</strong>；标记完成后进行清除操作，对没有标记过的内存进行回收, 回收同时可能伴有碎片整理操作</p>
<h5 id="分代搜集"><a href="#分代搜集" class="headerlink" title="分代搜集"></a>分代搜集</h5><p>java的<code>jvm</code> 就使用的分代回收的思路。在面向对象编程语言中，绝大多数对象的生命周期都非常短。分代收集的基本思想是，将堆划分为两个或多个称为代的空间。新创建的对象存放在称为新生代中, 一般来说，新生代的大小会比 老年代小很多，随着垃圾回收的重复执行，生命周期较长的对象会被提升到老年代中</p>
<p>因此，新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生，分别用于对各自空间中的对象执行垃圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代</p>
<h4 id="Golang-GC-时会发生什么-1"><a href="#Golang-GC-时会发生什么-1" class="headerlink" title="Golang GC 时会发生什么"></a>Golang GC 时会发生什么</h4><p>Golang 1.5后，采取的是 非分代的、非移动的、并发的、<strong>三色标记清除垃圾回收算法</strong></p>
<h3 id="Golang-中-Goroutine-如何调度"><a href="#Golang-中-Goroutine-如何调度" class="headerlink" title="Golang 中 Goroutine 如何调度"></a>Golang 中 <code>Goroutine</code> 如何调度</h3><p><code>goroutine</code>是Golang语言中最经典的设计，<code>goroutine</code>的本质是协程，是实现并行计算的核心。只需使用<code>go</code>关键字即可启动一个协程，并且它是处于<strong>异步方式运行</strong>，你不需要等它运行完成以后在执行以后的代码</p>
<p><code>go func()</code> 通过<code>go</code>关键字启动一个协程来运行函数</p>
<p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。 因此，协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态, 即<strong>进入上一次离开时所处逻辑流的位置</strong></p>
<ul>
<li>线程和进程的操作是由程序触发系统接口，最后的执行者是系统</li>
<li>协程的操作执行者则是用户自身程序，<code>goroutine</code>也是协程</li>
</ul>
<p><code>groutine</code>能拥有强大的并发实现是通过<strong>GPM调度模型</strong>实现</p>
<p>Go的调度器内部有四个重要的结构:</p>
<ul>
<li>M: M代表内核级线程，一个M就是一个线程，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache）、当前执行的goroutine、随机数发生器等等非常多的信息</li>
<li>G: 代表一个goroutine，它有自己的栈</li>
<li>P: P全称是Processor，处理器，它的主要用途就是用来执行goroutine的，所以它也维护了一个goroutine队列，里面存储了所有需要它来执行的goroutine</li>
<li>Sched: 代表调度器，它维护有存储M和G的队列以及调度器的一些状态信息等</li>
</ul>
<h3 id="并发编程概念是什么"><a href="#并发编程概念是什么" class="headerlink" title="并发编程概念是什么"></a>并发编程概念是什么</h3><ul>
<li>并行是指两个或者多个事件在同一时刻发生；并发是指两个或多个事件在同一时间间隔发生</li>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件</li>
<li>并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义上的<strong>同时执行</strong></li>
</ul>
<p>并发编程是指在一台处理器上同时处理多个任务, 每个任务轮流使用时间片。并发是在同一实体上的多个事件。多个事件在同一时间间隔发生。并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能</p>
<h3 id="etcd-怎么实现分布式锁的"><a href="#etcd-怎么实现分布式锁的" class="headerlink" title="etcd 怎么实现分布式锁的"></a><code>etcd</code> 怎么实现分布式锁的</h3><h3 id="Go语言的栈空间管理是怎么样的"><a href="#Go语言的栈空间管理是怎么样的" class="headerlink" title="Go语言的栈空间管理是怎么样的"></a>Go语言的栈空间管理是怎么样的</h3><p>Go语言的运行环境<code>runtime</code>会在<code>goroutine</code>需要的时候动态地分配栈空间，而不是给每个<code>goroutine</code>分配固定大小的内存空间。这样就避免了需要程序员来决定栈的大小</p>
<h3 id="Goroutine和Channel的作用分别是什么"><a href="#Goroutine和Channel的作用分别是什么" class="headerlink" title="Goroutine和Channel的作用分别是什么"></a><code>Goroutine</code>和<code>Channel</code>的作用分别是什么</h3><p>进程是内存资源管理和cpu调度的执行单元。为了有效利用多核处理器的优势，将进程进一步细分，允许一个进程里存在多个线程，这多个线程还是共享同一片内存空间，但cpu调度的最小单元变成了线程</p>
<p>协程，可以看作是轻量级的线程。但与线程不同的是，线程的切换是由操作系统控制的，而协程的切换则是由用户控制的</p>
<p>Go中的<code>goroutinue</code>就是协程,可以实现并行，多个协程可以在多个处理器同时跑。而协程同一时刻只能在一个处理器上跑, 可以把宿主语言想象成单线程的。 然而,多个<code>goroutine</code>之间的通信是通过<code>channel</code></p>
<p>在Go中<code>channel</code>是<code>goroutinues</code>之间进行通信的渠道</p>
<p>可以把<code>channel</code>形象比喻为工厂里的传送带,一头的生产者<code>goroutine</code>往传输带放东西,另一头的消费者<code>goroutinue</code>则从输送带取东西。<code>channel</code>实际上是一个有类型的消息队列, 遵循先进先出的特点</p>
<h4 id="阻塞式channel"><a href="#阻塞式channel" class="headerlink" title="阻塞式channel"></a>阻塞式<code>channel</code></h4><p><code>channel</code>默认是没有缓冲区的，也就是说，通信是阻塞的。<code>send</code>操作必须等到有消费者<code>accept</code>才算完成</p>
<h3 id="怎么查看Goroutine的数量"><a href="#怎么查看Goroutine的数量" class="headerlink" title="怎么查看Goroutine的数量"></a>怎么查看<code>Goroutine</code>的数量</h3><p><code>GOMAXPROCS</code>中控制的是未被阻塞的所有Goroutine, 通过<code>GOMAXPROCS</code>可以查看Goroutine的数量</p>
<h3 id="Go中的锁有哪些"><a href="#Go中的锁有哪些" class="headerlink" title="Go中的锁有哪些"></a>Go中的锁有哪些</h3><ul>
<li>互斥锁</li>
<li>读写锁</li>
<li><code>sync.Map</code>安全锁</li>
</ul>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>Go并发程序对共享资源进行访问控制的主要手段，由标准库代码包<code>sync.Mutex</code> 进行管理</p>
<p><code>sync.Mutex</code>包中的类型只有两个公开的指针方法:</p>
<ul>
<li>Lock()</li>
<li>Unlock()</li>
</ul>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>读写锁是针对读写操作的互斥锁，可以分别针对读操作与写操作进行锁定和解锁操作</p>
<p>读写锁的访问控制规则如下:</p>
<ol>
<li>多个写操作之间是互斥的</li>
<li>写操作与读操作之间也是互斥的</li>
<li>多个读操作之间不是互斥的</li>
</ol>
<p>读写锁在Go的标准库代码包<code>sync.RWMutex</code>中，提供有以下几种方法:</p>
<ul>
<li>RLock(), 对读操作的锁定</li>
<li>RUnlock(), 对读操作的解锁</li>
<li>Lock(), 对写操作的锁定</li>
<li>Unlock(), 对写操作的解锁</li>
</ul>
<h4 id="sync-Map安全锁"><a href="#sync-Map安全锁" class="headerlink" title="sync.Map安全锁"></a><code>sync.Map</code>安全锁</h4><p>golang中的<code>sync.Map</code>是并发安全的</p>
<h3 id="读写锁或者互斥锁读的时候能写吗"><a href="#读写锁或者互斥锁读的时候能写吗" class="headerlink" title="读写锁或者互斥锁读的时候能写吗"></a>读写锁或者互斥锁读的时候能写吗</h3><p>Go中读写锁包括读锁和写锁，多个读线程可以同时访问共享数据；写线程必须等待所有读线程都释放锁以后，才能取得锁；同样的，读线程必须等待写线程释放锁后，才能取得锁，也就是说读写锁要确保的是如下互斥关系，可以同时读，但是读-写，写-写都是互斥的</p>
<h3 id="怎么限制Goroutine的数量"><a href="#怎么限制Goroutine的数量" class="headerlink" title="怎么限制Goroutine的数量"></a>怎么限制<code>Goroutine</code>的数量</h3><p>在Golang中，<code>Goroutine</code>虽然很好，但是数量太多了，往往会带来很多麻烦，比如耗尽系统资源导致程序崩溃，或者CPU使用率过高导致系统忙不过来。所以我们可以限制下<code>Goroutine</code>的数量,这样就需要在每一次执行<code>go</code>之前判断<code>goroutine</code>的数量，如果数量超了，就要阻塞<code>go</code>的执行。第一时间想到的就是<strong>使用通道</strong>。每次执行<code>go</code>之前向通道写入值，直到通道满的时候就阻塞了</p>
<h3 id="Channel是同步的还是异步的"><a href="#Channel是同步的还是异步的" class="headerlink" title="Channel是同步的还是异步的"></a><code>Channel</code>是同步的还是异步的</h3><p><code>Channel</code>是异步进行的</p>
<h3 id="异步和非阻塞的区别"><a href="#异步和非阻塞的区别" class="headerlink" title="异步和非阻塞的区别"></a>异步和非阻塞的区别</h3><h3 id="Golang中-log包线程安全吗"><a href="#Golang中-log包线程安全吗" class="headerlink" title="Golang中 log包线程安全吗"></a>Golang中 <code>log</code>包线程安全吗</h3><p>Golang的标准库提供了<code>log</code>的机制，但是该模块的功能较为简单, 在输出的位置做了线程安全的保护</p>
<h3 id="Goroutine和线程的区别"><a href="#Goroutine和线程的区别" class="headerlink" title="Goroutine和线程的区别"></a><code>Goroutine</code>和线程的区别</h3><p><strong>从调度上看</strong>，<code>goroutine</code>的调度开销远远小于线程调度开销</p>
<p>OS的线程由OS内核调度，每隔几毫秒，一个硬件时钟中断发到CPU，CPU调用一个调度器内核函数。这个函数暂停当前正在运行的线程，把他的寄存器信息保存到内存中，查看线程列表并决定接下来运行哪一个线程，再从内存中恢复线程的注册表信息，最后继续执行选中的线程。这种线程切换需要一个完整的上下文切换：即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。某种意义上，这种操作还是很慢的</p>
<p>Go运行的时候包涵一个自己的调度器, Go的调度器不是由硬件时钟来定期触发的，而是由特定的go语言结构来触发的，他不需要切换到内核语境，所以调度一个<code>goroutine</code>比调度一个线程的成本低很多</p>
<p><strong>从栈空间上</strong>，<code>goroutine</code>的栈空间更加动态灵活</p>
<p>每个OS的线程都有一个固定大小的栈内存，通常是2MB，栈内存用于保存在其他函数调用期间哪些正在执行或者临时暂停的函数的局部变量。这个固定的栈大小，如果对于<code>goroutine</code>来说，可能是一种巨大的浪费。作为对比<code>goroutine</code>在生命周期开始只有一个很小的栈，典型情况是<code>2KB</code>, 在go程序中，一次创建十万左右的<code>goroutine</code>也不罕见<code>2KB*100,000=200MB</code>。而且<code>goroutine</code>的栈不是固定大小，它可以按需增大和缩小，最大限制可以到<code>1GB</code></p>
<p><strong><code>goroutine</code>没有一个特定的标识</strong></p>
<p>在大部分支持多线程的操作系统和编程语言中，线程有一个独特的标识，通常是一个整数或者指针，这个特性可以让我们构建一个线程的局部存储，本质是一个全局的<code>map</code>，以线程的标识作为键，这样每个线程可以独立使用这个<code>map</code>存储和获取值，不受其他线程干扰</p>
<p><code>goroutine</code>中没有可供程序员访问的标识，原因是一种纯函数的理念，不希望滥用线程局部存储导致一个不健康的超距作用，即函数的行为不仅取决于它的参数，还取决于运行它的线程标识</p>
<h3 id="Go的调度原理"><a href="#Go的调度原理" class="headerlink" title="Go的调度原理"></a>Go的调度原理</h3><h3 id="go-struct能不能比较"><a href="#go-struct能不能比较" class="headerlink" title="go struct能不能比较"></a>go struct能不能比较</h3><h3 id="go的-defer-用法与理解"><a href="#go的-defer-用法与理解" class="headerlink" title="go的 defer 用法与理解"></a>go的 defer 用法与理解</h3><h3 id="select可以用于什么"><a href="#select可以用于什么" class="headerlink" title="select可以用于什么"></a>select可以用于什么</h3><p><code>select</code> 的用法比较单一, 主要是处理多个<code>channel</code>的操作</p>
<h3 id="context包的用途是什么"><a href="#context包的用途是什么" class="headerlink" title="context包的用途是什么"></a><code>context</code>包的用途是什么</h3><h3 id="主协程如何等其余协程完再操作"><a href="#主协程如何等其余协程完再操作" class="headerlink" title="主协程如何等其余协程完再操作"></a>主协程如何等其余协程完再操作</h3><ul>
<li>利用 <code>sync.WaitGroup</code></li>
<li>利用 <code>channel</code></li>
</ul>
<h3 id="slice-的-len-和-cap，共享与扩容"><a href="#slice-的-len-和-cap，共享与扩容" class="headerlink" title="slice 的 len 和 cap，共享与扩容"></a><code>slice</code> 的 <code>len</code> 和 <code>cap</code>，共享与扩容</h3><h3 id="map如何顺序读取"><a href="#map如何顺序读取" class="headerlink" title="map如何顺序读取"></a><code>map</code>如何顺序读取</h3><p>可以通过<code>sort</code>中的排序包进行对<code>map</code>中的<code>key</code>进行排序</p>
<h3 id="go-实现-set"><a href="#go-实现-set" class="headerlink" title="go 实现 set"></a>go 实现 set</h3><p>根据<code>map</code>的<code>keys</code>的无序性和唯一性，可以将其作为<code>set</code></p>
<h3 id="Golang-里的逃逸分析是什么-怎么避免内存逃逸"><a href="#Golang-里的逃逸分析是什么-怎么避免内存逃逸" class="headerlink" title="Golang 里的逃逸分析是什么, 怎么避免内存逃逸"></a>Golang 里的逃逸分析是什么, 怎么避免内存逃逸</h3><p>在讨论变量生命周期之前，先来了解下计算机组成里两个非常重要的概念:</p>
<ul>
<li>栈</li>
<li>堆</li>
</ul>
<h4 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h4><p>栈是一种拥有特殊规则的线性表数据结构, 栈只允许从线性表的同一端放入和取出数据，按照后进先出的顺序</p>
<p>变量和栈有什么关系, 栈可用于内存分配，栈的分配和回收速度非常快</p>
<p>下面的代码展示了栈在内存分配上的作用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func makeMem(a, b int) int &#123;</span><br><span class="line">    var c int</span><br><span class="line">    c &#x3D; a*b</span><br><span class="line"></span><br><span class="line">    var x int</span><br><span class="line">    x &#x3D; c*10</span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明:</p>
<ul>
<li>传入 a、b 两个整型参数</li>
<li>声明整型变量 c，运行时，c 会分配一段内存用以存储 c 的数值</li>
<li>将 a 和 b 相乘后赋值给 c</li>
<li>声明整型变量 x，x 也会被分配一段内存</li>
<li>让 c 乘以 10 后赋值给变量 x</li>
<li>返回 x 的值</li>
</ul>
<p>上面的代码在没有任何优化的情况下，会进行变量 c 和 x 的分配过程。Go语言默认情况下会将 c 和 x 分配在栈上，这两个变量在 <code>makeMem</code> 函数退出时就不再使用，函数结束时，保存 c 和 x 的栈内存再出栈释放内存，整个分配内存的过程通过栈的分配和回收都会非常迅速</p>
<h4 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h4><p>堆在内存分配中类似于 <strong>往一个房间里摆放各种家具，家具的尺寸有大有小，分配内存时，需要找一块足够装下家具的空间再摆放家具。经过反复摆放和腾空家具后，房间里的空间会变得乱七八糟，此时再往这个空间里摆放家具会发现虽然有足够的空间，但各个空间分布在不同的区域，没有一段连续的空间来摆放家具</strong>。此时，内存分配器就需要对这些空间进行调整优化</p>
<p><strong>堆分配内存</strong> 和 <strong>栈分配内存</strong>相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成<strong>内存碎片</strong></p>
<h4 id="变量逃逸"><a href="#变量逃逸" class="headerlink" title="变量逃逸"></a>变量逃逸</h4><p>自动决定变量分配方式，提高运行效率</p>
<p>堆和栈各有优缺点，该怎么在编程中处理这个问题呢？在 <code>C/C++</code> 语言中，需要开发者自己学习如何进行内存分配，选用怎样的内存分配方式来适应不同的算法需求。比如，函数局部变量尽量使用栈，全局变量、结构体成员使用堆分配等。程序员不得不花费很长的时间在不同的项目中学习、记忆这些概念并加以实践和使用</p>
<p>Go语言将这个过程整合到了编译器中，命名为<strong>变量逃逸分析</strong>。通过编译器分析代码的特征和代码的生命周期，决定应该使用堆还是栈来进行内存分配</p>
<p>在使用Go语言进行编程时，Go语言的设计者不希望开发者将精力放在内存应该分配在栈还是堆的问题上，编译器会自动帮助开发者完成这个纠结的选择，但<strong>变量逃逸分析</strong>也是需要了解的一个编译器技术，这个技术不仅用于Go语言，在 <code>Java</code> 等语言的编译器优化上也使用了类似的技术</p>
<h3 id="Golang-的GC触发时机是什么"><a href="#Golang-的GC触发时机是什么" class="headerlink" title="Golang 的GC触发时机是什么"></a>Golang 的GC触发时机是什么</h3><h3 id="Etcd的Raft一致性算法原理"><a href="#Etcd的Raft一致性算法原理" class="headerlink" title="Etcd的Raft一致性算法原理"></a>Etcd的<code>Raft</code>一致性算法原理</h3><h3 id="Go的反射包"><a href="#Go的反射包" class="headerlink" title="Go的反射包"></a>Go的反射包</h3><h3 id="go实现-生产者消费者模式"><a href="#go实现-生产者消费者模式" class="headerlink" title="go实现 生产者消费者模式"></a>go实现 生产者消费者模式</h3><h3 id="sync-Pool-的使用"><a href="#sync-Pool-的使用" class="headerlink" title="sync.Pool 的使用"></a><code>sync.Pool</code> 的使用</h3><h3 id="GMP-调度模型"><a href="#GMP-调度模型" class="headerlink" title="GMP 调度模型"></a>GMP 调度模型</h3><h3 id="Go-的垃圾回收是怎么实现的-优缺点"><a href="#Go-的垃圾回收是怎么实现的-优缺点" class="headerlink" title="Go 的垃圾回收是怎么实现的, 优缺点"></a>Go 的垃圾回收是怎么实现的, 优缺点</h3><h3 id="三色标记算法的原理"><a href="#三色标记算法的原理" class="headerlink" title="三色标记算法的原理"></a>三色标记算法的原理</h3><h3 id="描述下-slice-在-append-时发生了什么"><a href="#描述下-slice-在-append-时发生了什么" class="headerlink" title="描述下 slice 在 append 时发生了什么"></a>描述下 <code>slice</code> 在 <code>append</code> 时发生了什么</h3><h3 id="解释下变量逃逸"><a href="#解释下变量逃逸" class="headerlink" title="解释下变量逃逸"></a>解释下变量逃逸</h3><hr>
<h3 id="go-语法基础问题"><a href="#go-语法基础问题" class="headerlink" title="go 语法基础问题"></a>go 语法基础问题</h3><h4 id="Go-允许多个返回值吗"><a href="#Go-允许多个返回值吗" class="headerlink" title="Go 允许多个返回值吗"></a>Go 允许多个返回值吗</h4><p>go 允许有多个返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func swap(x, y string) (string, string) &#123;</span><br><span class="line">    return y, x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Go-有异常类型吗"><a href="#Go-有异常类型吗" class="headerlink" title="Go 有异常类型吗"></a>Go 有异常类型吗</h4><p>Go 没有异常类型，只有错误类型<code>Error</code>，通常使用返回值来表示异常状态</p>
<h4 id="什么是-rune-类型"><a href="#什么是-rune-类型" class="headerlink" title="什么是 rune 类型"></a>什么是 <code>rune</code> 类型</h4><p><code>ASCII</code> 码只需要 <code>7 bit</code> 就可以完整地表示，但只能表示英文字母在内的128个字符，为了表示世界上大部分的文字系统，发明了 <code>Unicode</code>， 它是<code>ASCII</code>的超集，包含世界上书写系统中存在的所有字符，并为每个代码分配一个标准编号, 称为<code>Unicode CodePoint</code>，在 Go 语言中称之为 <code>rune</code>，是 <code>int32</code> 类型的别名</p>
<p>o 语言中，字符串的底层表示是 <code>byte</code> (8 bit) 序列，而非 <code>rune</code> (32 bit) 序列。汉字 使用 UTF-8 编码后各占 3 个 <code>byte</code>，我们也可以将字符串转换为 <code>rune</code> 序列</p>
<h4 id="如何判断-map-中是否包含某个-key"><a href="#如何判断-map-中是否包含某个-key" class="headerlink" title="如何判断 map 中是否包含某个 key"></a>如何判断 <code>map</code> 中是否包含某个 <code>key</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if val, ok :&#x3D; dict[&quot;key1&quot;]; ok &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dict[&quot;key1&quot;]</code> 有 2 个返回值，val 和 ok，如果 ok 等于 <code>true</code>，则说明 dict 包含 key <code>key1</code>，val 将被赋予对应的值</p>
<h4 id="go-如何交换-2-个变量的值"><a href="#go-如何交换-2-个变量的值" class="headerlink" title="go 如何交换 2 个变量的值"></a>go 如何交换 2 个变量的值</h4><p>go 支持多重赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b :&#x3D; 1, 2</span><br><span class="line">a, b &#x3D; b, a</span><br></pre></td></tr></table></figure>
<p>多个变量交换也可以使用该方式 <code>a, b, c, d = d, c, b, a</code></p>
<h4 id="Go-语言-tag-的用处"><a href="#Go-语言-tag-的用处" class="headerlink" title="Go 语言 tag 的用处"></a>Go 语言 <code>tag</code> 的用处</h4><p>tag 可以理解为 <code>struct</code> 字段的注解，可以用来定义字段的一个或多个属性。可以通过反射获取到某个字段定义的属性，采取相应的处理方式。tag 丰富了代码的语义，增强了灵活性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;encoding&#x2F;json&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type People struct &#123;</span><br><span class="line">    Name string   &#96;json:&quot;p_name&quot;&#96;</span><br><span class="line">    Id   string   &#96;json:&quot;p_id&quot;&#96;</span><br><span class="line">    Age  int      &#96;json:&quot;-&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    buf, _ :&#x3D; json.Marshal(People&#123;&quot;ifcalm&quot;, &quot;1234&quot;, 25&#125;)</span><br><span class="line">    fmt.Printf(&quot;%s\n&quot;, buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子使用 tag 定义了结构体字段与 json 字段的转换关系，<code>Name -&gt; p_name</code>, <code>Id -&gt; p_id</code>，忽略 Age 字段。很方便地实现了 Go 结构体与不同规范的 <code>json</code> 文本之间的转换</p>
<h4 id="如何判断-2-个字符串切片是相等的"><a href="#如何判断-2-个字符串切片是相等的" class="headerlink" title="如何判断 2 个字符串切片是相等的"></a>如何判断 2 个字符串切片是相等的</h4><h4 id="字符串打印时，-v-和-v-的区别"><a href="#字符串打印时，-v-和-v-的区别" class="headerlink" title="字符串打印时，%v 和 %+v 的区别"></a>字符串打印时，<code>%v</code> 和 <code>%+v</code> 的区别</h4><h4 id="Go-语言中如何表示枚举值"><a href="#Go-语言中如何表示枚举值" class="headerlink" title="Go 语言中如何表示枚举值"></a>Go 语言中如何表示枚举值</h4><p>在 Go 中引入枚举的标准方法是声明一个自定义类型和一个使用了 <code>iota</code> 的 <code>const</code> 组</p>
<h4 id="空-struct-的用途"><a href="#空-struct-的用途" class="headerlink" title="空 struct{} 的用途"></a>空 <code>struct&#123;&#125;</code> 的用途</h4><p>使用空结构体 <code>struct&#123;&#125;</code> 可以节省内存，一般作为占位符使用，表明这里并不需要一个值</p>
<p>比如使用 <code>map</code> 表示集合时，只关注 <code>key</code>，<code>value</code> 可以使用 <code>struct&#123;&#125;</code> 作为占位符。如果使用其他类型作为占位符，例如 <code>int</code>，<code>bool</code>，不仅浪费了内存，而且容易引起歧义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type Set map[string]struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    set :&#x3D; make(Set)</span><br><span class="line"></span><br><span class="line">    for _, item :&#x3D; range []string&#123;&quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;C&quot;&#125; &#123;</span><br><span class="line">        set[item] &#x3D; struct&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(len(set))</span><br><span class="line">    if _, ok :&#x3D; set[&quot;B&quot;]; ok &#123;</span><br><span class="line">        fmt.Println(&quot;B exists&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再比如，使用信道<code>channel</code>控制并发时，我们只是需要一个信号，但并不需要传递值，这个时候，也可以使用 <code>struct&#123;&#125;</code> 代替</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    ch :&#x3D; make(chan struct&#123;&#125;, 1)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        &lt;-ch</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    ch&lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再比如，声明只包含方法的结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Lamp struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (l Lamp) On() &#123;</span><br><span class="line">    fmt.Println(&quot;On&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (l Lamp) Off() &#123;</span><br><span class="line">    fmt.Println(&quot;Off&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="init-函数是什么时候执行的"><a href="#init-函数是什么时候执行的" class="headerlink" title="init() 函数是什么时候执行的"></a><code>init()</code> 函数是什么时候执行的</h4><ul>
<li>对同一个go 文件的init<code>()</code> 调用顺序是从上到下的</li>
<li>对同一个<code>package</code> 中的不同文件，将文件名按字符串进行从小到大排序，之后顺序调用各文件中的<code>init()</code>函数</li>
<li>对于不同的<code>package</code>，如果不相互依赖的话，按照<code>main</code> 包中<code>import</code> 的顺序调用其包中的<code>init()</code> 函数</li>
</ul>
<p><code>init()</code> 函数是 Go 程序初始化的一部分。Go 程序初始化先于 <code>main</code> 函数，由 <code>runtime</code> 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化</p>
<p>每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的 <code>init()</code> 函数。同一个包，甚至是同一个源文件可以有多个 <code>init()</code> 函数。<code>init()</code> 函数没有入参和返回值，不能被其他函数调用，同一个包内多个 <code>init()</code> 函数的执行顺序不作保证</p>
<p><code>import –&gt; const –&gt; var –&gt; init() –&gt; main()</code></p>
<h4 id="Go-语言的局部变量分配在栈上还是堆上"><a href="#Go-语言的局部变量分配在栈上还是堆上" class="headerlink" title="Go 语言的局部变量分配在栈上还是堆上"></a>Go 语言的局部变量分配在栈上还是堆上</h4><p>由编译器决定。Go 语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做<strong>逃逸分析</strong>，当发现变量的作用域没有超出函数范围，就可以在栈上，反之则必须分配在堆上</p>
<h4 id="2-个-interface-可以比较吗"><a href="#2-个-interface-可以比较吗" class="headerlink" title="2 个 interface 可以比较吗"></a>2 个 <code>interface</code> 可以比较吗</h4><h4 id="2-个-nil-可能不相等吗"><a href="#2-个-nil-可能不相等吗" class="headerlink" title="2 个 nil 可能不相等吗"></a>2 个 <code>nil</code> 可能不相等吗</h4><h4 id="函数返回局部变量的指针是否安全"><a href="#函数返回局部变量的指针是否安全" class="headerlink" title="函数返回局部变量的指针是否安全"></a>函数返回局部变量的指针是否安全</h4><h4 id="非接口的任意类型-T-都能够调用-T-的方法吗"><a href="#非接口的任意类型-T-都能够调用-T-的方法吗" class="headerlink" title="非接口的任意类型 T() 都能够调用 *T 的方法吗"></a>非接口的任意类型 <code>T()</code> 都能够调用 <code>*T</code> 的方法吗</h4><h4 id="什么是协程泄露"><a href="#什么是协程泄露" class="headerlink" title="什么是协程泄露"></a>什么是协程泄露</h4><p><code>goroutine leak</code>是go协程泄漏，什么是go协程泄漏，通俗来说，开启了一个<code>goroutine</code>，用完后，我们要正确让其结束。如果它没用了，还没结束，那就是<code>goroutine leak</code></p>
<p>泄漏的<code>goroutine</code>占用一部分cpu，还可能占着一些其他资源，从而影响主协程效率，有时甚至产生异常</p>
<h4 id="Go-可以限制运行时操作系统线程的数量吗"><a href="#Go-可以限制运行时操作系统线程的数量吗" class="headerlink" title="Go 可以限制运行时操作系统线程的数量吗"></a>Go 可以限制运行时操作系统线程的数量吗</h4><p>可以使用环境变量 <code>GOMAXPROCS</code> 或 <code>runtime.GOMAXPROCS(num int)</code> 设置</p>
<h4 id="无缓冲的-channel-和有缓冲的-channel-的区别"><a href="#无缓冲的-channel-和有缓冲的-channel-的区别" class="headerlink" title="无缓冲的 channel 和有缓冲的 channel 的区别"></a>无缓冲的 <code>channel</code> 和有缓冲的 <code>channel</code> 的区别</h4><p><strong>在执行过程中暂停，以等待某个条件的触发 ，我们就称之为阻塞</strong></p>
<p>在Go中我们<code>make</code>一个<code>channel</code>有两种方式，分别是有缓冲的和没缓冲的</p>
<ul>
<li>非缓冲 <code>channel</code> 发送和接收动作是同时发生的, <code>ch := make(chan int)</code> ，如果没 goroutine 读取接收者<code>&lt;-ch</code> ，那么发送者<code>ch&lt;-</code> 就会一直阻塞</li>
<li>缓冲 <code>channel</code> 类似一个队列，只有队列满了才可能发送阻塞</li>
</ul>
<h4 id="go的组合继承"><a href="#go的组合继承" class="headerlink" title="go的组合继承"></a>go的组合继承</h4><p>golang 提倡组合，不提倡继承</p>
<p>组合一般理解为 <code>has-a</code> 的关系，继承是<code>is-a</code> 的关系，两者都能起到代码复用的作用</p>
<p>go支持组合，即一种结构体包含另外一个结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Person) A() &#123;</span><br><span class="line">    fmt.Print(p.Nmae)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Ifcalm struct &#123;</span><br><span class="line">    *Person</span><br><span class="line">    Age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lss :&#x3D; &amp;Ifcalm&#123;</span><br><span class="line">    Person: &amp;Person&#123;&quot;lss&quot;&#125;</span><br><span class="line">    Age: 18</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="select-随机性"><a href="#select-随机性" class="headerlink" title="select 随机性"></a><code>select</code> 随机性</h4><p><code>select - case</code> 用法比较单一，仅能用于信道的相关操作</p>
<p><code>switch - case</code> 里面的 <code>case</code> 是顺序执行，但在<code>select</code> 里不是</p>
<h4 id="defer-执行顺序"><a href="#defer-执行顺序" class="headerlink" title="defer 执行顺序"></a><code>defer</code> 执行顺序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(test())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test() string &#123;</span><br><span class="line">	defer fmt.Println(&quot;A&quot;)</span><br><span class="line">	defer fmt.Println(&quot;B&quot;)</span><br><span class="line">	defer fmt.Println(&quot;C&quot;)</span><br><span class="line">	fmt.Println(&quot;D&quot;)</span><br><span class="line">	return &quot;E&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D</span><br><span class="line">C</span><br><span class="line">B</span><br><span class="line">A</span><br><span class="line">E</span><br></pre></td></tr></table></figure>
<ul>
<li>我们发现<code>defer</code>就像一个栈，后<code>defer</code>的会先执行，且在函数退出时才会执行</li>
<li><code>defer</code>的执行顺序在<code>return</code>之后，但是在返回值返回给调用方之前，所以使用defer可以达到修改返回值的目的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(test(5))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test(num int) int &#123;</span><br><span class="line">	defer func(num int) &#123;</span><br><span class="line">		num++</span><br><span class="line">		fmt.Println(num)</span><br><span class="line">	&#125;(num)</span><br><span class="line">	return num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h4 id="interface-内部结构"><a href="#interface-内部结构" class="headerlink" title="interface 内部结构"></a><code>interface</code> 内部结构</h4><h4 id="goto"><a href="#goto" class="headerlink" title="goto"></a><code>goto</code></h4><p>Go 语言的 <code>goto</code> 语句可以无条件地转移到过程中指定的行。</p>
<p><code>goto</code> 语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能. 但是，在结构化程序设计中一般不主张使用 <code>goto</code> 语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	a :&#x3D; 10</span><br><span class="line">LOOP:</span><br><span class="line">	if a &lt; 15 &#123;</span><br><span class="line">		a++</span><br><span class="line">		goto LOOP</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结构体比较"><a href="#结构体比较" class="headerlink" title="结构体比较"></a>结构体比较</h4><ul>
<li>同一个<code>struct</code>的两个实例能不能比较。可以能、也可以不能</li>
<li>两个不同的<code>struct</code>的实例能不能比较。可以能、也可以不能</li>
</ul>
<p><strong>如果结构体的所有成员变量都是可比较的，那么结构体就可比较, 如果结构体中存在不可比较的成员变量，那么结构体就不能比较</strong></p>
<p>结构体之间进行转换需要他们具备完全相同的成员, 字段名、字段类型、字段个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type T struct &#123;</span><br><span class="line">	Name  string</span><br><span class="line">	Age   int</span><br><span class="line">	Arr   [2]bool</span><br><span class="line">	Ptr   *int</span><br><span class="line">	Slice []int</span><br><span class="line">	Map   map[string]string &#x2F;&#x2F;切片和map不能比较，所以包含该类型的结构体实例也不能比较，&#x3D;&#x3D; 或 !&#x3D; 直接报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	t1 :&#x3D; T&#123;</span><br><span class="line">		Name:  &quot;lss&quot;,</span><br><span class="line">		Age:   18,</span><br><span class="line">		Arr:   [2]bool&#123;true, false&#125;,</span><br><span class="line">		Ptr:   new(int),</span><br><span class="line">		Slice: []int&#123;1, 2, 3&#125;,</span><br><span class="line">		Map:   make(map[string]string),</span><br><span class="line">	&#125;</span><br><span class="line">	t2 :&#x3D; T&#123;</span><br><span class="line">		Name:  &quot;lss&quot;,</span><br><span class="line">		Age:   18,</span><br><span class="line">		Arr:   [2]bool&#123;true, false&#125;,</span><br><span class="line">		Ptr:   new(int),</span><br><span class="line">		Slice: []int&#123;1, 2, 3&#125;,</span><br><span class="line">		Map:   make(map[string]string),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(t1 &#x3D;&#x3D; t2)                  &#x2F;&#x2F;报错</span><br><span class="line">	fmt.Println(&amp;t1 &#x3D;&#x3D; &amp;t2)                &#x2F;&#x2F;指针可以比较, false</span><br><span class="line">	fmt.Println(reflect.DeepEqual(t1, t2)) &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">	t3 :&#x3D; &amp;T&#123;</span><br><span class="line">		Name:  &quot;lss&quot;,</span><br><span class="line">		Age:   18,</span><br><span class="line">		Arr:   [2]bool&#123;true, false&#125;,</span><br><span class="line">		Ptr:   new(int),</span><br><span class="line">		Slice: []int&#123;1, 2, 3&#125;,</span><br><span class="line">		Map:   make(map[string]string),</span><br><span class="line">	&#125;</span><br><span class="line">	t4 :&#x3D; &amp;T&#123;</span><br><span class="line">		Name:  &quot;lss&quot;,</span><br><span class="line">		Age:   18,</span><br><span class="line">		Arr:   [2]bool&#123;true, false&#125;,</span><br><span class="line">		Ptr:   new(int),</span><br><span class="line">		Slice: []int&#123;1, 2, 3&#125;,</span><br><span class="line">		Map:   make(map[string]string),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(&quot;%p, %p \n&quot;, t3, t4)</span><br><span class="line">	fmt.Printf(&quot;%p, %p \n&quot;, &amp;t3, &amp;t4)</span><br><span class="line">	fmt.Println(t3 &#x3D;&#x3D; t4)</span><br><span class="line">	fmt.Println(*t3 &#x3D;&#x3D; *t4)</span><br><span class="line">	fmt.Println(reflect.DeepEqual(t3, t4))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>t1, t2是同一个<code>struct</code>的2个赋值相同的实例, 他们本质就是结构体的一个对象，因为成员变量带有了不能比较的成员，所以只要写 <code>==</code> 就报错</p>
<p>t3, t4 虽然能用 <code>==</code> ，但本质上是比较的指针类型，<code>*t3 == *t4</code> 一样一写就报错</p>
<p><code>func DeepEqual(a1, a2 interface&#123;&#125;) bool</code> 这个方法比较指针类型深度是否一致的情况, 可以达到比较值是否相等这样的效果</p>
<p><code>struct</code>可以作为<code>map</code>的key么, <code>struct</code>必须是可比较的，才能作为key，否则编译时报错</p>
<h4 id="go-闭包"><a href="#go-闭包" class="headerlink" title="go 闭包"></a>go 闭包</h4><p>函数也是值。它们可以像其它值一样传递。 函数值可以用作函数的参数或返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func compute(fn func(float64, float64) float64) float64 &#123;</span><br><span class="line">     return fn(3, 4)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     hypot :&#x3D; func(x, y float64) float64 &#123;</span><br><span class="line">         return math.Sqrt(x*x + y*y)</span><br><span class="line">     &#125;</span><br><span class="line">     fmt.Println(hypot(5, 12))</span><br><span class="line"></span><br><span class="line">     fmt.Println(compute(hypot))</span><br><span class="line">     fmt.Println(compute(math.Pow))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被绑定在了这些变量上。 例如，下面函数 <code>adder</code> 返回一个闭包。每个闭包都被绑定在其各自的 <code>sum</code> 变量上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func adder() func(int) int &#123;</span><br><span class="line">     sum :&#x3D; 0</span><br><span class="line">     return func(x int) int &#123;</span><br><span class="line">         sum +&#x3D; x</span><br><span class="line">         return sum</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     pos, neg :&#x3D; adder(), adder()</span><br><span class="line">     for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">         fmt.Println(</span><br><span class="line">             pos(i),</span><br><span class="line">             neg(-2*i),</span><br><span class="line">         )</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="panic-与-revover"><a href="#panic-与-revover" class="headerlink" title="panic 与 revover"></a><code>panic</code> 与 <code>revover</code></h4><p>编程语言一般都会有异常捕获机制</p>
<p>只需要调用<code>panic</code> 函数，就可以触发宕机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	panic(&quot;test&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发生异常，有时候需要捕获，Go 内建函数 <code>recover</code> 可以让程序在发送宕机后起死回生, 但是 <code>recover</code> 的使用，必须在 <code>defer</code> 函数中才能生效，其他作用域下，它是不工作的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	testA(20)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果执行到这句，说明panic被捕获了</span><br><span class="line">    &#x2F;&#x2F;后续的程序能继续运行</span><br><span class="line">	fmt.Println(&quot;It&#39;s ok&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func testA(x int) &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		if err :&#x3D; recover(); err !&#x3D; nil &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;制造数组越界，触发 panic</span><br><span class="line">	var arr [10]int</span><br><span class="line">	arr[x] &#x3D; 88</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>recover()</code> 可以将捕获到的 <code>panic</code> 信息打印</p>
<p>通常来说，不应该对进入<code>panic</code>宕机的程序做任何处理，但有时，需要我们从宕机中恢复，至少我们可以在程序崩溃前做一些操作，比如关闭所有连接，释放资源</p>
<p>Go 的异常抛出与捕获，依赖两个内置函数：</p>
<ul>
<li><code>panic</code> : 抛出异常，是程序奔溃</li>
<li><code>recover</code> : 捕获异常，恢复程序或做收尾工作</li>
</ul>
<h4 id="数组与slice的区别"><a href="#数组与slice的区别" class="headerlink" title="数组与slice的区别"></a>数组与<code>slice</code>的区别</h4><p>数组类型的值的长度是固定的数组的长度在声明它的时候就必须给定，并且在之后不会再改变。可以说，数组的长度是其类型的一部分，数组的容量永远等于其长度，都是不可变的</p>
<p>切片类型的值是可变长的。而切片的类型字面量中只有其元素的类型，而没有其长度。切片的长度可以自动地随着其中元素数量的增长而增长，但不会随着元素数量的减少而减少</p>
<p>在每一个切片的底层数据结构中，会包含一个数组，可以被叫做底层数据，而切片就是对底层数组的引用，故而切片类型属于<strong>引用类型</strong></p>
<p>一个切片无法容纳更多的元素时，Go 语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中</p>
<p>在一般的情况下，你可以简单地认为新切片的容量将会是原切片容量的 2 倍。<br>但是，当原切片的长度大于或等于<code>1024</code> 时，Go 语言将会以原容量的 1.25<br> 倍作为新容量的基准。新容量基准会被调整，不断地与1.25相乘，直到结果不小于原长度与要追加的元素数量之和</p>
<h4 id="Golang-是面对对象语言吗"><a href="#Golang-是面对对象语言吗" class="headerlink" title="Golang 是面对对象语言吗"></a>Golang 是面对对象语言吗</h4><p>Java 面向对象核心特征：封装、继承、多态，golang虽然可以通过各种方式达到类似的功能，但 golang 算是面向对象的语言吗</p>
<p>严格来讲，<strong>Go不是OOP的语言，但是又允许有OOP的编程风格</strong></p>
<p>面向对象程序设计(OOP)是一种计算机编程架构。 OOP的一条基本原则是计算机程序由单个能够起到子程序作用的单元或对象组合而成。 OOP达到了软件工程的三个主要目标：重用性、灵活性和扩展性。 OOP=对象+类+继承+多态+消息，其中核心概念是<strong>类和对象</strong></p>
<p>go 官网自己说是 <code>Yes and No</code>, 也就是说 go 允许 OOP 的编程风格，但又缺乏一些 java 和 C++ 中常见的 <code>类, 对象, 继承 等语言层面支持的结构</code></p>
<h4 id="golang-没有三元操作符"><a href="#golang-没有三元操作符" class="headerlink" title="golang 没有三元操作符 : ?"></a>golang 没有三元操作符 <code>: ?</code></h4><p>golang 中没有三元运算符，但我们可以简单实现一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func If(condition bool, trueVal, falseVal interface&#123;&#125;) interface&#123;&#125; &#123;</span><br><span class="line">	if condition &#123;</span><br><span class="line">		return trueVal</span><br><span class="line">	&#125;</span><br><span class="line">	return falseVal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="new-与-make-的区别"><a href="#new-与-make-的区别" class="headerlink" title="new() 与 make() 的区别"></a><code>new()</code> 与 <code>make()</code> 的区别</h4><p><code>new</code> 只能传递一个参数，该参数为一个任意类型，可以是Go内建的类型，也可以是自定义的类型</p>
<p>new 函数做了如下事情:</p>
<ul>
<li>分配内存</li>
<li>设置零值</li>
<li>返回指针（重要）</li>
</ul>
<p>内建函数 <code>make</code> 用来 为 <code>slice, map, chan</code> 类型分配内存和初始化一个对象，<code>make</code> 也只能用在这3种类型上</p>
<ol>
<li><code>new</code> 可以为所有的类型分配内存，并初始化为零值，返回指针</li>
<li><code>make</code> 只能为 <code>slice, map, chan</code> 分配内存，并初始化，返回的是类型</li>
</ol>
<h4 id="go的mutex怎么使用，乐观和悲观锁分别怎么实现，使用场景是什么"><a href="#go的mutex怎么使用，乐观和悲观锁分别怎么实现，使用场景是什么" class="headerlink" title="go的mutex怎么使用，乐观和悲观锁分别怎么实现，使用场景是什么"></a>go的<code>mutex</code>怎么使用，乐观和悲观锁分别怎么实现，使用场景是什么</h4>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Golang/" rel="tag"># Golang</a>
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/05/02/redis-interview/" rel="prev" title="Redis 常见面试问题总结">
                  <i class="fa fa-chevron-left"></i> Redis 常见面试问题总结
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/07/12/backend-interview/" rel="next" title="后端通用面试问题总结">
                  后端通用面试问题总结 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ifcalm</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">109k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:39</span>
  </span>
</div>





<!-- 网站运行时间的设置 -->

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
