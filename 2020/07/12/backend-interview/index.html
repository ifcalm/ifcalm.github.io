<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="在软体架构和程序设计领域，前端是软体系统中直接和用户交互的部分，而后端控制着软件的输出的编程语言">
<meta property="og:type" content="article">
<meta property="og:title" content="后端通用面试问题总结">
<meta property="og:url" content="http://example.com/2020/07/12/backend-interview/index.html">
<meta property="og:site_name" content="缘起">
<meta property="og:description" content="在软体架构和程序设计领域，前端是软体系统中直接和用户交互的部分，而后端控制着软件的输出的编程语言">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-07-12T07:57:02.000Z">
<meta property="article:modified_time" content="2021-03-03T12:45:00.528Z">
<meta property="article:author" content="ifcalm">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2020/07/12/backend-interview/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>后端通用面试问题总结 | 缘起</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">缘起</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">种瓜的瓜, 种豆得豆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">协程，线程，进程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%8C%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%8C%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="nav-number">2.</span> <span class="nav-text">互斥锁，读写锁，死锁问题是怎么解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-%E5%8E%9F%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">epoll 原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O"><span class="nav-number">3.1.</span> <span class="nav-text">I&#x2F;O</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">3.2.</span> <span class="nav-text">事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">3.3.</span> <span class="nav-text">通知机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll%E6%9C%BA%E5%88%B6"><span class="nav-number">3.4.</span> <span class="nav-text">epoll机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll-API"><span class="nav-number">3.5.</span> <span class="nav-text">epoll API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll-%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="nav-number">3.6.</span> <span class="nav-text">epoll 的两种触发方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">IO 多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">5.</span> <span class="nav-text">并发编程概念是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">6.</span> <span class="nav-text">什么是线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LVS-%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BA%86%E8%A7%A3"><span class="nav-number">7.</span> <span class="nav-text">LVS 的相关了解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">8.</span> <span class="nav-text">Redis的数据类型有哪些，以及应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String"><span class="nav-number">8.1.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List"><span class="nav-number">8.2.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hash"><span class="nav-number">8.3.</span> <span class="nav-text">Hash</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set"><span class="nav-number">8.4.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sorted-Set"><span class="nav-number">8.5.</span> <span class="nav-text">Sorted Set</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">9.</span> <span class="nav-text">异步和非阻塞的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="nav-number">10.</span> <span class="nav-text">滑动窗口的概念以及应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E5%A4%A7%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%8C%E8%AE%A9%E5%85%B6%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E6%83%B3%E5%8A%A0%E7%AD%89%E4%BA%8E1000%E6%80%8E%E4%B9%88%E7%AE%97"><span class="nav-number">11.</span> <span class="nav-text">一个非常大的数组，让其中两个数想加等于1000怎么算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%EF%BC%8C%E6%96%B9%E6%B3%95"><span class="nav-number">12.</span> <span class="nav-text">常用测试工具，压测工具，方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%80%8E%E4%B9%88%E6%B5%8B%E8%AF%95%EF%BC%8C%E6%AF%94%E5%A6%82%E6%9C%89%E5%A4%96%E9%83%A8%E6%8E%A5%E5%8F%A3mysql%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">13.</span> <span class="nav-text">复杂的单元测试怎么测试，比如有外部接口mysql接口的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis%E9%9B%86%E7%BE%A4%EF%BC%8C%E5%93%A8%E5%85%B5%EF%BC%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E4%BA%8B%E5%8A%A1"><span class="nav-number">14.</span> <span class="nav-text">redis集群，哨兵，持久化，事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql%E5%92%8Credis%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">15.</span> <span class="nav-text">mysql和redis区别是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFredis%E7%BC%93%E5%AD%98%E5%88%B0mysql"><span class="nav-number">15.1.</span> <span class="nav-text">什么是redis缓存到mysql</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><span class="nav-number">15.2.</span> <span class="nav-text">其他缓存策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql%E4%BA%8B%E5%8A%A1"><span class="nav-number">16.</span> <span class="nav-text">mysql事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">16.1.</span> <span class="nav-text">并发事务带来的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">16.2.</span> <span class="nav-text">并发事务的解决办法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97"><span class="nav-number">16.3.</span> <span class="nav-text">事务日志</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#grpc%E9%81%B5%E5%BE%AA%E4%BB%80%E4%B9%88%E5%8D%8F%E8%AE%AE"><span class="nav-number">17.</span> <span class="nav-text">grpc遵循什么协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#grpc%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">18.</span> <span class="nav-text">grpc内部原理是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http2%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%8Ehttp1-1%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">19.</span> <span class="nav-text">http2的特点是什么，与http1.1的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#client%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="nav-number">20.</span> <span class="nav-text">client如何实现长连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">21.</span> <span class="nav-text">大文件排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E7%A8%B3%E5%AE%9A%E7%9A%84"><span class="nav-number">22.</span> <span class="nav-text">基本排序，哪些是稳定的</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%B3%E5%AE%9A%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">22.1.</span> <span class="nav-text">稳定的排序算法:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F"><span class="nav-number">22.2.</span> <span class="nav-text">不稳定排序:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Http-get%E4%B8%8Ehead"><span class="nav-number">23.</span> <span class="nav-text">Http get与head</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Http-401-403"><span class="nav-number">24.</span> <span class="nav-text">Http 401,403</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Http-keep-alive"><span class="nav-number">25.</span> <span class="nav-text">Http keep-alive</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E7%94%A8Keep-Alive%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">25.1.</span> <span class="nav-text">启用Keep-Alive的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%B6%88%E6%81%AF%E5%86%85%E5%AE%B9%E9%95%BF%E5%BA%A6%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">25.2.</span> <span class="nav-text">如何判断消息内容长度的大小</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Http%E8%83%BD%E4%B8%8D%E8%83%BD%E4%B8%80%E6%AC%A1%E8%BF%9E%E6%8E%A5%E5%A4%9A%E6%AC%A1%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%8D%E7%AD%89%E5%90%8E%E7%AB%AF%E8%BF%94%E5%9B%9E"><span class="nav-number">26.</span> <span class="nav-text">Http能不能一次连接多次请求，不等后端返回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E5%92%8C-UDP-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">27.</span> <span class="nav-text">TCP 和 UDP 有什么区别,适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#time-wait%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">28.</span> <span class="nav-text">time-wait的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">29.</span> <span class="nav-text">数据库如何建索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">30.</span> <span class="nav-text">孤儿进程，僵尸进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%9D%A1%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D"><span class="nav-number">31.</span> <span class="nav-text">死锁条件，如何避免</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux%E5%91%BD%E4%BB%A4%EF%BC%8C%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%EF%BC%8Ccpu%E8%B4%9F%E8%BD%BD%EF%BC%8C%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7%E7%BB%99%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="nav-number">32.</span> <span class="nav-text">linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git%E6%96%87%E4%BB%B6%E7%89%88%E6%9C%AC%EF%BC%8C%E4%BD%BF%E7%94%A8%E9%A1%BA%E5%BA%8F%EF%BC%8Cmerge%E8%B7%9Frebase"><span class="nav-number">33.</span> <span class="nav-text">git文件版本，使用顺序，merge跟rebase</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E4%BC%9A%E7%94%A8%E5%88%B0%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">34.</span> <span class="nav-text">一般会用到哪些数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84%E7%9B%B8%E6%AF%94-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">35.</span> <span class="nav-text">链表和数组相比, 有什么优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%97%A0%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BA%A4%E5%8F%89%E7%82%B9"><span class="nav-number">36.</span> <span class="nav-text">如何判断两个无环单链表有没有交叉点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E6%9C%89%E6%B2%A1%E6%9C%89%E7%8E%AF-%E5%B9%B6%E6%89%BE%E5%87%BA%E5%85%A5%E7%8E%AF%E7%82%B9"><span class="nav-number">37.</span> <span class="nav-text">如何判断一个单链表有没有环, 并找出入环点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B-TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD"><span class="nav-number">38.</span> <span class="nav-text">描述一下 TCP 四次挥手的过程中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81"><span class="nav-number">39.</span> <span class="nav-text">TCP 有哪些状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E7%9A%84-LISTEN-%E7%8A%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">40.</span> <span class="nav-text">TCP 的 LISTEN 状态是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E7%9A%84-CLOSE-WAIT-%E7%8A%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">41.</span> <span class="nav-text">TCP 的 CLOSE_WAIT 状态是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA-socket-%E8%BF%9E%E6%8E%A5%E8%A6%81%E7%BB%8F%E8%BF%87%E5%93%AA%E4%BA%9B%E6%AD%A5%E9%AA%A4"><span class="nav-number">42.</span> <span class="nav-text">建立一个 socket 连接要经过哪些步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84-HTTP-%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">43.</span> <span class="nav-text">常见的 HTTP 状态码有哪些</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E7%B1%BB"><span class="nav-number">43.1.</span> <span class="nav-text">HTTP状态码分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#301%E5%92%8C302%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">44.</span> <span class="nav-text">301和302有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#504%E5%92%8C500%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">45.</span> <span class="nav-text">504和500有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS-%E5%92%8C-HTTP-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">46.</span> <span class="nav-text">HTTPS 和 HTTP 有什么区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-%E4%B8%8E-HTTPS-%E5%8C%BA%E5%88%AB"><span class="nav-number">46.1.</span> <span class="nav-text">HTTP 与 HTTPS 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">46.2.</span> <span class="nav-text">TCP 三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">46.3.</span> <span class="nav-text">HTTPS 的工作原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">47.</span> <span class="nav-text">手写一个快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">48.</span> <span class="nav-text">配置中心如何保证一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E9%87%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%86%9F%E6%82%89%E5%90%97"><span class="nav-number">49.</span> <span class="nav-text">Redis 里数据结构的实现熟悉吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SLB%E5%8E%9F%E7%90%86"><span class="nav-number">50.</span> <span class="nav-text">SLB原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E5%88%99"><span class="nav-number">51.</span> <span class="nav-text">分布式一致性原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-%E2%80%93-gt-C"><span class="nav-number">52.</span> <span class="nav-text">智能指针 –&gt; C++</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%92%8C%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="nav-number">53.</span> <span class="nav-text">唯一索引和主键索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp%E7%B2%98%E5%8C%85"><span class="nav-number">54.</span> <span class="nav-text">tcp粘包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83"><span class="nav-number">55.</span> <span class="nav-text">进程虚拟空间分布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E5%92%8C-go-%E5%92%8C-java-%E5%AF%B9%E6%AF%94"><span class="nav-number">56.</span> <span class="nav-text">c++ 和 go 和 java 对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="nav-number">57.</span> <span class="nav-text">堆的时间复杂度，稳定性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">58.</span> <span class="nav-text">几种基本排序算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#top-K-%E9%97%AE%E9%A2%98"><span class="nav-number">59.</span> <span class="nav-text">top-K 问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80"><span class="nav-number">59.1.</span> <span class="nav-text">解法一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C"><span class="nav-number">59.2.</span> <span class="nav-text">解法二</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%89"><span class="nav-number">59.3.</span> <span class="nav-text">解法三</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95%E5%9B%9B"><span class="nav-number">59.4.</span> <span class="nav-text">解法四</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%BB%E9%94%AE"><span class="nav-number">60.</span> <span class="nav-text">什么是主键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="nav-number">61.</span> <span class="nav-text">联合索引和唯一索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%8A%E5%A4%9A%E7%9A%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E5%A5%BD%E5%90%97"><span class="nav-number">62.</span> <span class="nav-text">越多的索引越好吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88"><span class="nav-number">63.</span> <span class="nav-text">建立索引要注意什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">64.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">65.</span> <span class="nav-text">tcp三次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">66.</span> <span class="nav-text">数据库隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cookie%E4%B8%8Esession"><span class="nav-number">67.</span> <span class="nav-text">cookie与session</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#token"><span class="nav-number">67.1.</span> <span class="nav-text">token</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-%E5%92%8C-epoll"><span class="nav-number">68.</span> <span class="nav-text">select 和 epoll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">69.</span> <span class="nav-text">TCP 拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3"><span class="nav-number">69.1.</span> <span class="nav-text">拥塞窗口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp-%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">69.2.</span> <span class="nav-text">tcp 的四种拥塞控制算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mysql-%E7%94%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">70.</span> <span class="nav-text">Mysql 用的是什么数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kafka-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">71.</span> <span class="nav-text">kafka 的工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85"><span class="nav-number">71.1.</span> <span class="nav-text">发布&#x2F;订阅</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B-HTTPS-%E7%9A%84%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B%EF%BC%8C%E9%9C%80%E8%A6%81%E5%87%A0%E6%AC%A1%E9%80%9A%E4%BF%A1"><span class="nav-number">72.</span> <span class="nav-text">详细描述一下 HTTPS 的加密过程，需要几次通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">72.1.</span> <span class="nav-text">HTTPS解决的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%8C%E8%AF%B4%E4%B8%80%E4%B8%8B-time-wait"><span class="nav-number">73.</span> <span class="nav-text">三次握手和四次挥手，说一下 time_wait</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">73.1.</span> <span class="nav-text">TCP 报文的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">73.2.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1"><span class="nav-number">73.3.</span> <span class="nav-text">TCP 建立连接为什么要三次握手而不是两次</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%80%8C%E4%B8%8D%E6%98%AF%E5%9B%9B%E6%AC%A1"><span class="nav-number">73.4.</span> <span class="nav-text">TCP 建立连接为什么要三次握手而不是四次</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E4%B8%80%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%98%AF%E5%88%A9%E7%94%A8%E4%BA%86-TCP-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E6%BC%8F%E6%B4%9E%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="nav-number">73.5.</span> <span class="nav-text">有一种网络攻击是利用了 TCP 建立连接机制的漏洞，这个问题怎么解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">73.6.</span> <span class="nav-text">四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-TCP-%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%89%E6%AC%A1"><span class="nav-number">73.7.</span> <span class="nav-text">为什么 TCP 关闭连接为什么要四次而不是三次</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9C%A8-TIME-WAIT-%E7%8A%B6%E6%80%81%E7%AD%89%E5%BE%85-2MSL-%E6%97%B6%E9%97%B4%E6%89%8D%E8%83%BD%E8%BF%9B%E5%85%A5-CLOSED-%E7%8A%B6%E6%80%81"><span class="nav-number">73.8.</span> <span class="nav-text">客户端为什么需要在 TIME-WAIT 状态等待 2MSL 时间才能进入 CLOSED 状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mysql-%E7%9A%84%E5%B9%BB%E8%AF%BB%E6%98%AF%E6%80%8E%E4%B9%88%E4%B8%AA%E6%83%85%E5%86%B5%EF%BC%8CMysql-%E6%98%AF%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%9A%84"><span class="nav-number">74.</span> <span class="nav-text">Mysql 的幻读是怎么个情况，Mysql 是如何避免的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">75.</span> <span class="nav-text">自旋锁和互斥锁有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">76.</span> <span class="nav-text">用过哪些分布式锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-setnx-expire-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="nav-number">77.</span> <span class="nav-text">redis setnx + expire 有什么缺点，如何优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA-URL-%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">78.</span> <span class="nav-text">打开一个 URL 的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-DNS-%E8%A7%A3%E6%9E%90"><span class="nav-number">78.1.</span> <span class="nav-text">1. DNS 解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8F%91%E8%B5%B7TCP%E8%AF%B7%E6%B1%82"><span class="nav-number">78.2.</span> <span class="nav-text">2. 发起TCP请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%8F%91%E8%B5%B7HTTP%E8%AF%B7%E6%B1%82"><span class="nav-number">78.3.</span> <span class="nav-text">3. 发起HTTP请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">78.4.</span> <span class="nav-text">4. 负载均衡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93"><span class="nav-number">78.5.</span> <span class="nav-text">5. 浏览器渲染</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E9%A1%B5%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD"><span class="nav-number">78.6.</span> <span class="nav-text">网页静态资源加载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E6%A0%91-%E5%92%8C-B-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88-mysql-%E8%A6%81%E7%94%A8-B-%E6%A0%91%EF%BC%8Cmongodb-%E8%A6%81%E7%94%A8-B-%E6%A0%91"><span class="nav-number">79.</span> <span class="nav-text">B 树 和 B+ 树的区别，为什么 mysql 要用 B+ 树，mongodb 要用 B 树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-%E7%9A%84%E8%B7%B3%E8%A1%A8%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">80.</span> <span class="nav-text">redis 的跳表，为什么不用红黑树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-%E9%9B%86%E7%BE%A4%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%B8%80%E8%87%B4%E6%80%A7-hash"><span class="nav-number">81.</span> <span class="nav-text">redis 集群是怎么实现的，说一下一致性 hash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="nav-number">82.</span> <span class="nav-text">进程的调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mysql-%E9%9B%86%E7%BE%A4%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">83.</span> <span class="nav-text">Mysql 集群如何保证数据的一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mysql-%E9%9B%86%E7%BE%A4%E5%9C%A8%E4%BF%9D%E8%AF%81%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="nav-number">84.</span> <span class="nav-text">Mysql 集群在保证强一致性的情况下，如何保证高并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">85.</span> <span class="nav-text">哪些操作会导致内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E5%AF%BC%E8%87%B4-io-%E5%BC%80%E9%94%80%E5%A4%A7%E5%B9%85%E4%B8%8A%E5%8D%87"><span class="nav-number">86.</span> <span class="nav-text">哪些操作会导致 io 开销大幅上升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5"><span class="nav-number">87.</span> <span class="nav-text">异步和同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%81%9A%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E9%85%8D%E7%BD%AE%E5%B9%B3%E5%8F%B0%E7%B3%BB%E7%BB%9F"><span class="nav-number">88.</span> <span class="nav-text">怎么做一个自动化配置平台系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E7%9A%84%E6%B5%81%E7%A8%8B%E8%A7%84%E8%8C%83%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">89.</span> <span class="nav-text">开发的流程规范是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E4%B8%8A-cpu-%E5%92%8C%E5%86%85%E5%AD%98%E7%AA%81%E7%84%B6%E9%A3%99%E9%AB%98%E5%90%8E%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E6%8E%92%E9%94%99"><span class="nav-number">90.</span> <span class="nav-text">线上 cpu 和内存突然飙高后应该怎么排错</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%97%E5%88%B0%E6%94%BB%E5%87%BB%E6%80%8E%E4%B9%88%E5%AE%9A%E4%BD%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%AE%E9%A2%98"><span class="nav-number">91.</span> <span class="nav-text">服务器受到攻击怎么定位服务器问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rpc%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">92.</span> <span class="nav-text">rpc的具体实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%B5%B7%E9%87%8F%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5%E7%B3%BB%E7%BB%9F"><span class="nav-number">93.</span> <span class="nav-text">设计一个海量日志写入系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%95%BF%E9%93%BE%E6%8E%A5%E8%BD%AC%E7%9F%AD%E9%93%BE%E6%8E%A5%EF%BC%8C%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="nav-number">94.</span> <span class="nav-text">设计一个长链接转短链接，需要考虑高并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%BE%AE%E4%BF%A1%E6%9C%8B%E5%8F%8B%E5%9C%88%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%88%97%E5%87%BA%E4%B8%BB%E8%A6%81%E7%9A%84%E8%A1%A8%E7%BB%93%E6%9E%84%EF%BC%8C%E5%86%99%E5%87%BA%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">95.</span> <span class="nav-text">设计一个微信朋友圈系统，列出主要的表结构，写出一些数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%B5%B7%E9%87%8F%E7%9A%84%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F"><span class="nav-number">96.</span> <span class="nav-text">设计一个海量的评论系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%87%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">97.</span> <span class="nav-text">使用过的中间件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E8%AE%A2%E5%8D%95%E5%8F%B7%E7%94%9F%E6%88%90%E7%9A%84%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98"><span class="nav-number">98.</span> <span class="nav-text">唯一订单号生成的算法问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E6%96%B9%E6%A1%88"><span class="nav-number">99.</span> <span class="nav-text">mysql高可用的方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">100.</span> <span class="nav-text">服务发现怎么实现的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E5%AE%95%E6%9C%BA%E9%80%A0%E6%88%90%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98"><span class="nav-number">101.</span> <span class="nav-text">如何保证服务宕机造成的分布式服务节点处理问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">102.</span> <span class="nav-text">高可用软件是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1orm%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%86%99"><span class="nav-number">103.</span> <span class="nav-text">怎么设计orm，你会怎么写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F"><span class="nav-number">104.</span> <span class="nav-text">怎么设计一个并发服务程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AAweb%E6%A1%86%E6%9E%B6%EF%BC%8C%E8%A6%81%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1"><span class="nav-number">105.</span> <span class="nav-text">设计一个web框架，要怎么设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%8C%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-number">106.</span> <span class="nav-text">实现消息队列. 多生产者，多消费者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%81%9A%E5%BC%B9%E6%80%A7%E6%89%A9%E7%BC%A9%E5%AE%B9%EF%BC%8C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">107.</span> <span class="nav-text">怎么做弹性扩缩容，原理是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86"><span class="nav-number">108.</span> <span class="nav-text">解释一下中间件原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%84%E4%B8%AA%E7%B3%BB%E7%BB%9F%E5%87%BA%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6"><span class="nav-number">109.</span> <span class="nav-text">各个系统出问题怎么监控报警</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="nav-number">110.</span> <span class="nav-text">微服务架构是什么样的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">111.</span> <span class="nav-text">负载均衡原理是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">112.</span> <span class="nav-text">分布式锁的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mysql%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">113.</span> <span class="nav-text">Mysql高可用方案有哪些</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ifcalm</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/12/backend-interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ifcalm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘起">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          后端通用面试问题总结
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-12 15:57:02" itemprop="dateCreated datePublished" datetime="2020-07-12T15:57:02+08:00">2020-07-12</time>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>30k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>27 分钟</span>
    </span>
</div>

            <div class="post-description">在软体架构和程序设计领域，前端是软体系统中直接和用户交互的部分，而后端控制着软件的输出的编程语言</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h3 id="协程，线程，进程的区别"><a href="#协程，线程，进程的区别" class="headerlink" title="协程，线程，进程的区别"></a>协程，线程，进程的区别</h3><p>进程、线程、协程是为了满足用户的多任务任务需求。比如一边写代码一边听音乐</p>
<p>单核的 CPU 一次只能执行一个任务，想要实现多任务，需要把 CPU 的运行时间切成一段一段的时间片，每个时间片运行一个程序，循环的分配时间片给不同的应用程序</p>
<p>由于时间片非常的短，在用户看来，就像是多个任务同时在运行</p>
<p>进程、线程、协程就是计算机表示任务的方式, 它们被统称为<strong>执行体</strong></p>
<p>进程、线程、协程的区别主要体现在执行体的颗粒度上。最初的执行体任务比较简单，用一个进程就能满足需求，随着执行体做的事情越来越复杂，就出现了进程内多任务的需求</p>
<p>进程内的执行体，被称为线程，它作为进程的子执行体，创建和运行成本小很多。线程是执行任务的最小单元，每个线程具有独立的栈空间，并共享堆空间</p>
<p>进程和线程都属于系统级的任务，切换进程、线程都需要经历用户态跃迁内核态，切换成功后再由内核态切回用户态</p>
<p>协程是比线程颗粒度更细小的任务，允许切换线程的最小单元是函数(方法），而切换协程可以在任何一行代码</p>
<h3 id="互斥锁，读写锁，死锁问题是怎么解决"><a href="#互斥锁，读写锁，死锁问题是怎么解决" class="headerlink" title="互斥锁，读写锁，死锁问题是怎么解决"></a>互斥锁，读写锁，死锁问题是怎么解决</h3><h3 id="epoll-原理"><a href="#epoll-原理" class="headerlink" title="epoll 原理"></a><code>epoll</code> 原理</h3><p><code>epoll</code>是一种I/O事件通知机制，是linux 内核实现<strong>IO多路复用</strong>的一个实现</p>
<p><strong>IO多路复用</strong>是指，在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作</p>
<h4 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h4><p>输入输出(input/output)的对象可以是文件(file)， 网络(socket)，进程之间的管道(pipe)。在linux系统中，都用文件描述符(fd)来表示</p>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><ul>
<li>可读事件，当文件描述符关联的内核读缓冲区可读，则触发可读事件。可读：内核缓冲区非空，有数据可以读取</li>
<li>可写事件，当文件描述符关联的内核写缓冲区可写，则触发可写事件。可写：内核缓冲区不满，有空闲空间可以写入</li>
</ul>
<h4 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h4><p>通知机制，就是当事件发生的时候，则主动通知。通知机制的反面，就是轮询机制</p>
<h4 id="epoll机制"><a href="#epoll机制" class="headerlink" title="epoll机制"></a>epoll机制</h4><p><code>epoll</code>是一种当文件描述符的内核缓冲区非空的时候，发出可读信号进行通知，当写缓冲区不满的时候，发出可写信号通知的机制</p>
<h4 id="epoll-API"><a href="#epoll-API" class="headerlink" title="epoll API"></a>epoll API</h4><p><code>epoll</code>的核心是3个API，核心数据结构是: 1个红黑树和1个链表</p>
<ul>
<li><code>int epoll_create(int size)</code>, 内核会产生一个epoll 实例数据结构并返回一个文件描述符，这个特殊的描述符就是epoll实例的句柄，后面的两个接口都以它为中心</li>
<li><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code>, 将被监听的描述符添加到红黑树或从红黑树中删除或者对监听事件进行修改</li>
<li><code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</code>, 阻塞等待注册的事件发生，返回事件的数目，并将触发的事件写入<code>events</code>数组中</li>
</ul>
<h4 id="epoll-的两种触发方式"><a href="#epoll-的两种触发方式" class="headerlink" title="epoll 的两种触发方式"></a>epoll 的两种触发方式</h4><p><code>epoll</code>监控多个文件描述符的I/O事件。<code>epoll</code>支持边缘触发(edge trigger, ET)或水平触发(level trigger, LT)，通过<code>epoll_wait</code>等待I/O事件，如果当前没有可用的事件则阻塞调用线程</p>
<p><strong><code>select</code>和<code>poll</code>只支持LT工作模式，<code>epoll</code>的默认的工作模式是LT模式</strong></p>
<ol>
<li>水平触发</li>
<li>边缘触发</li>
</ol>
<h3 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h3><p>假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择:</p>
<ul>
<li>按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡主，全班都会被耽误</li>
<li>你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接</li>
<li>你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A, <strong>这种就是IO复用模型</strong>，Linux下的<code>select</code>、<code>poll</code>和<code>epoll</code>就是干这个的。将用户<code>socket</code>对应的fd注册进<code>epoll</code>，然后<code>epoll</code>帮你监听哪些<code>socket</code>上有消息到达，这样就避免了大量的无用操作</li>
</ul>
<p>这样，整个过程只在调用<code>select、poll、epoll</code>这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是<strong>事件驱动</strong>，所谓的<strong>reactor模式</strong></p>
<h3 id="并发编程概念是什么"><a href="#并发编程概念是什么" class="headerlink" title="并发编程概念是什么"></a>并发编程概念是什么</h3><h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><p>线程安全是程式设计中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成</p>
<p>线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。 不会出现数据不一致或者数据污染。 线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</p>
<h3 id="LVS-的相关了解"><a href="#LVS-的相关了解" class="headerlink" title="LVS 的相关了解"></a>LVS 的相关了解</h3><p><code>LVS</code>，全称Linux Virtual Server，是国人章文嵩发起的一个开源项目。在社区具有很大的热度，是一个基于四层、具有强大性能的反向代理服务器</p>
<h3 id="Redis的数据类型有哪些，以及应用场景"><a href="#Redis的数据类型有哪些，以及应用场景" class="headerlink" title="Redis的数据类型有哪些，以及应用场景"></a><code>Redis</code>的数据类型有哪些，以及应用场景</h3><p>Redis目前支持5种数据类型，分别是:</p>
<ul>
<li>String, 字符串</li>
<li>List, 列表</li>
<li>Hash, 字典</li>
<li>Set, 集合</li>
<li>Sorted Set, 有序集合</li>
</ul>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>String是简单的 key-value 键值对，value 不仅可以是 String，也可以是数字。String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到<code>incr,decr</code>等操作时会转成数值型进行计算，此时redisObject的encoding字段为int</p>
<p><em>应用场景:</em></p>
<p>String是最常用的一种数据类型，普通的<code>key/value</code>存储都可以归为此类</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>edis列表是简单的字符串列表，是一个链表或者说是一个队列。可以从头部或尾部向Redis列表添加元素。列表的最大长度为<code>2^32 - 1</code>，也即每个列表支持超过40亿个元素</p>
<p>Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构</p>
<p><em>应用场景:</em></p>
<p>Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表、粉丝列表等都可以用Redis的list结构来实现，再比如有的应用使用Redis的list类型实现一个简单的轻量级消息队列，生产者push，消费者pop/bpop</p>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>待补充</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>一个值不重复的列表，类似数学领域中的集合概念，且Redis也提供了针对集合的求交集、并集、差集等操作。</p>
<p>set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因</p>
<p><em>应用场景:</em></p>
<p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的</p>
<h4 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h4><p>Redis有序集合类似Redis集合，不同的是增加了一个功能，即集合是有序的。一个有序集合的每个成员带有分数，用于进行排序</p>
<p>Redis有序集合添加、删除和测试的时间复杂度均为<code>O(1)</code></p>
<p>Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单</p>
<p><em>应用场景:</em></p>
<p>Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的 public timeline 可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。</p>
<p>又比如用户的积分排行榜需求就可以通过有序集合实现。还有上面介绍的使用List实现轻量级的消息队列，其实也可以通过Sorted Set实现有优先级或按权重的队列</p>
<h3 id="异步和非阻塞的区别"><a href="#异步和非阻塞的区别" class="headerlink" title="异步和非阻塞的区别"></a>异步和非阻塞的区别</h3><p>异步，调用在发出之后，这个调用就直接返回，不管有无结果. 异步是过程</p>
<p>非阻塞, 关注的是程序在等待调用结果时的状态，指在不能立刻得到结果之前，该调用不会阻塞当前线程</p>
<h3 id="滑动窗口的概念以及应用"><a href="#滑动窗口的概念以及应用" class="headerlink" title="滑动窗口的概念以及应用"></a>滑动窗口的概念以及应用</h3><p>滑动窗口协议是用来改善吞吐量的一种技术，即容许发送方在接收任何应答之前传送附加的包。 接收方告诉发送方在某一时刻能送多少包（称窗口尺寸）。 TCP中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据</p>
<h3 id="一个非常大的数组，让其中两个数想加等于1000怎么算"><a href="#一个非常大的数组，让其中两个数想加等于1000怎么算" class="headerlink" title="一个非常大的数组，让其中两个数想加等于1000怎么算"></a>一个非常大的数组，让其中两个数想加等于1000怎么算</h3><h3 id="常用测试工具，压测工具，方法"><a href="#常用测试工具，压测工具，方法" class="headerlink" title="常用测试工具，压测工具，方法"></a>常用测试工具，压测工具，方法</h3><h3 id="复杂的单元测试怎么测试，比如有外部接口mysql接口的情况"><a href="#复杂的单元测试怎么测试，比如有外部接口mysql接口的情况" class="headerlink" title="复杂的单元测试怎么测试，比如有外部接口mysql接口的情况"></a>复杂的单元测试怎么测试，比如有外部接口mysql接口的情况</h3><h3 id="redis集群，哨兵，持久化，事务"><a href="#redis集群，哨兵，持久化，事务" class="headerlink" title="redis集群，哨兵，持久化，事务"></a>redis集群，哨兵，持久化，事务</h3><h3 id="mysql和redis区别是什么"><a href="#mysql和redis区别是什么" class="headerlink" title="mysql和redis区别是什么"></a><code>mysql</code>和<code>redis</code>区别是什么</h3><p>Redis基于内存，是一个大的 map 结构，读写速度快，也可做持久化，但是内存空间有限，当数据量超过内存空间时，需扩充内存，但内存价格贵</p>
<p>MySQL基于磁盘，读写速度没有Redis快，但是不受空间容量限制，性价比高。</p>
<p>大多数的应用场景是MySQL（主）+Redis（辅），MySQL做为主存储，Redis用于缓存，加快访问速度。需要高性能的地方使用Redis，不需要高性能的地方使用MySQL。存储数据在MySQL和Redis之间做同步</p>
<h4 id="什么是redis缓存到mysql"><a href="#什么是redis缓存到mysql" class="headerlink" title="什么是redis缓存到mysql"></a>什么是redis缓存到mysql</h4><p>Redis其实就是说把表中经常访问的记录放在了Redis中，然后用户查询时先去查询Redis再去查询MySQL，确实实现了读写分离，也就是Redis只做读操作。由于缓存在内存中，所以查询会很快。对于一个sql语句格式的数据请求，首先计算该语句的MD5并据此得到结果集标识符，然后利用该标识符在Redis中查找该结果集。注意，结果集中的每一行都有一个相应的键，这些键都存储在一个Redis集合结构中。如果Redis中不存在这样一个集合，说明要找的结果集不在Redis中，所以需要执行相应的sql语句，在Mysql中查询到相应的结果集，然后按照上面所说的办法把结果集中的每一行以字符串或哈希的形式存入Redis</p>
<h4 id="其他缓存策略"><a href="#其他缓存策略" class="headerlink" title="其他缓存策略"></a>其他缓存策略</h4><p>MemCached数据结构单一，仅用来缓存数据，而Redis支持更加丰富的数据类型，也可以在服务器端直接对数据进行丰富的操作,这样可以减少网络IO次数和数据体积</p>
<p>MemCached不支持数据持久化，断电或重启后数据消失，但其稳定性是有保证的。Redis支持数据持久化和数据恢复，允许单点故障，但是同时也会付出性能的代价</p>
<h3 id="mysql事务"><a href="#mysql事务" class="headerlink" title="mysql事务"></a><code>mysql</code>事务</h3><p><code>MySQL</code> 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务</p>
<ul>
<li>在 <code>MySQL</code> 中只有使用了 <code>Innodb</code> 数据库引擎的数据库或表才支持事务</li>
<li>事务处理可以用来维护数据库的完整性，保证成批的 <code>SQL</code> 语句要么全部执行，要么全部不执行</li>
<li>事务用来管理 <code>insert</code>,<code>update</code>,<code>delete</code> 语句</li>
</ul>
<p>一般来说，事务是必须满足4个条件【ACID】：原子性、一致性、隔离性又称独立性、持久性</p>
<ul>
<li>原子性: 一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样</li>
<li>一致性: 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作</li>
<li>隔离性: 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交、读提交、可重复读和串行化</li>
<li>持久性: 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失</li>
</ul>
<p>MYSQL 事务处理主要有两种方法:</p>
<ol>
<li>用 <code>BEGIN</code>, <code>ROLLBACK</code>, <code>COMMIT</code>来实现<ul>
<li><code>BEGIN</code> 开始一个事务</li>
<li><code>ROLLBACK</code> 事务回滚</li>
<li><code>COMMIT</code> 事务确认</li>
</ul>
</li>
<li>直接用 <code>SET</code> 来改变 MySQL 的自动提交模式<ul>
<li><code>SET AUTOCOMMIT=0</code> 禁止自动提交</li>
<li><code>SET AUTOCOMMIT=1</code> 开启自动提交</li>
</ul>
</li>
</ol>
<h4 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h4><ul>
<li>更新丢失: 当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题, 后的更新覆盖了由其他事务所做的更新</li>
<li>脏读: 一个事务正在对一条记录做修改，在这个事务完成并提交前， 这条记录的数据就处于不一致状态； 这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些脏数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做<strong>脏读</strong></li>
<li>不可重复读: 一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了, 这种现象就叫做不可重复读</li>
<li>幻读: 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读</li>
</ul>
<p>不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样,因为中间有其他事务提交了修改</p>
<p>幻读的重点在于新增或者删除：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样, 因为中间有其他事务提交了插入/删除</p>
<h4 id="并发事务的解决办法"><a href="#并发事务的解决办法" class="headerlink" title="并发事务的解决办法"></a>并发事务的解决办法</h4><p>更新丢失通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决</p>
<p>脏读 、 不可重复读和幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决</p>
<ul>
<li>一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改</li>
<li>一种是数据多版本并发控制，简称 MVCC，也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照, 并用这个快照来提供一定级别 的一致性读取</li>
</ul>
<p>SQL标准定义了4类隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销</p>
<ol>
<li>读取未提交内容<ul>
<li>所有事务都可以看到其他未提交事务的执行结果</li>
<li>该隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少</li>
<li>该级别引发的问题是脏读, 读取到了未提交的数据</li>
</ul>
</li>
<li>读取提交内容<ul>
<li>这是大多数数据库系统的默认隔离级别, 但不是MySQL默认的</li>
<li>一个事务只能看见已经提交事务所做的改变</li>
<li>这种隔离级别出现的问题是不可重复读：不可重复读意味着我们在同一个事务中执行完全相同的<code>select</code>语句时可能看到不一样的结果</li>
</ul>
</li>
<li>可重读<ul>
<li>这是MySQL的默认事务隔离级别</li>
<li>它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行</li>
<li>此级别可能出现的问题是幻读：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的幻影行</li>
<li>InnoDB存储引擎通过多版本并发控制机制解决幻读问题, InnoDB还通过间隙锁解决幻读问题</li>
</ul>
</li>
<li>多版本并发控制<ul>
<li>Mysql的大多数事务型存储引擎实现都不是简单的行级锁。基于提升并发性考虑，一般都同时实现了多版本并发控制【MVCC】</li>
<li>MVCC的实现是通过保存数据在某一个时间点快照来实现的。也就是说不管实现时间多长，每个事物看到的数据都是一致的</li>
<li><code>InnoDB</code>的MVCC是通过在每行记录后面保存两个隐藏的列来实现。这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号。每开始一个新的事务，系统版本号都会自动新增。事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较</li>
</ul>
</li>
<li>可串行化<ul>
<li>这是最高的隔离级别</li>
<li>它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁</li>
<li>在这个级别，可能导致大量的超时现象和锁竞争</li>
</ul>
</li>
</ol>
<h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4><p>待补充</p>
<h3 id="grpc遵循什么协议"><a href="#grpc遵循什么协议" class="headerlink" title="grpc遵循什么协议"></a><code>grpc</code>遵循什么协议</h3><h3 id="grpc内部原理是什么"><a href="#grpc内部原理是什么" class="headerlink" title="grpc内部原理是什么"></a><code>grpc</code>内部原理是什么</h3><h3 id="http2的特点是什么，与http1-1的对比"><a href="#http2的特点是什么，与http1-1的对比" class="headerlink" title="http2的特点是什么，与http1.1的对比"></a><code>http2</code>的特点是什么，与<code>http1.1</code>的对比</h3><ul>
<li>HTTP2使用的是二进制传送，HTTP1.X是文本传送, 二进制传送的单位是帧和流。帧组成了流，同时流还有流ID标示</li>
<li>HTTP2支持多路复用, 因为有流ID，所以通过同一个http请求实现多个http请求传输变成了可能，可以通过流ID来标示究竟是哪个流从而定位到是哪个http请求</li>
<li>HTTP2通过gzip和compress压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID就可以知道表头的值了</li>
<li>HTTP2支持服务器推送, HTTP2支持在客户端未经请求许可的情况下，主动向客户端推送内容</li>
</ul>
<h3 id="client如何实现长连接"><a href="#client如何实现长连接" class="headerlink" title="client如何实现长连接"></a>client如何实现长连接</h3><h3 id="大文件排序"><a href="#大文件排序" class="headerlink" title="大文件排序"></a>大文件排序</h3><h3 id="基本排序，哪些是稳定的"><a href="#基本排序，哪些是稳定的" class="headerlink" title="基本排序，哪些是稳定的"></a>基本排序，哪些是稳定的</h3><p>稳定性: 稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录<code>R</code>和<code>S</code>，且在原本的列表中<code>R</code>出现在<code>S</code>之前，在排序过的列表中<code>R</code>也将会是在<code>S</code>之前</p>
<h4 id="稳定的排序算法"><a href="#稳定的排序算法" class="headerlink" title="稳定的排序算法:"></a>稳定的排序算法:</h4><ul>
<li>冒泡排序</li>
<li>插入排序</li>
<li>桶排序</li>
<li>计数排序</li>
<li>归并排序</li>
</ul>
<h4 id="不稳定排序"><a href="#不稳定排序" class="headerlink" title="不稳定排序:"></a>不稳定排序:</h4><ul>
<li>选择排序</li>
<li>希尔排序</li>
<li>堆排序</li>
<li>快速排序</li>
</ul>
<h3 id="Http-get与head"><a href="#Http-get与head" class="headerlink" title="Http get与head"></a>Http <code>get</code>与<code>head</code></h3><ul>
<li>HEAD: 只请求页面的首部</li>
<li>GET: 请求指定的页面信息，并返回实体主体</li>
</ul>
<p><code>HEAD</code>和<code>GET</code>本质是一样的，区别在于<code>HEAD</code>不含有呈现数据，而仅仅是HTTP头信息。有的人可能觉得这个方法没什么用，其实不是这样的</p>
<p>想象一个业务情景: 欲判断某个资源是否存在，我们通常使用<code>GET</code>，但这里用<code>HEAD</code>则意义更加明确</p>
<h3 id="Http-401-403"><a href="#Http-401-403" class="headerlink" title="Http 401,403"></a>Http 401,403</h3><ul>
<li><code>401</code> Unauthorized</li>
<li><code>403</code> Forbidden</li>
</ul>
<p><code>401</code>，是说服务端不知道你是谁, 例如，token 失效，或者 token 缺失，甚至 token 伪造。导致服务端无法识别你的身份，这时会返回 HTTP Status Code 401。客户端此时只能重试</p>
<p><code>403</code>，是说虽然服务端已经知道了你是谁，但是你没有权限去访问该数据资源, 例如，你登录成功了，但是你却非要去访问其他人的隐私内容，或者你无权访问的内容</p>
<h3 id="Http-keep-alive"><a href="#Http-keep-alive" class="headerlink" title="Http keep-alive"></a>Http <code>keep-alive</code></h3><p>HTTP协议采用<strong>请求-应答</strong>模式，当使用普通模式，即非<code>Keep-Alive</code>模式时，每个请求-应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）, 当使用<code>Keep-Alive</code>模式（又称持久连接、连接重用）时，<code>Keep-Alive</code> 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，<code>Keep-Alive</code> 功能避免了建立或者重新建立连接</p>
<p><code>http 1.0</code> 中默认是关闭的，需要在 http 头加入<code>Connection: Keep-Alive</code>，才能启用<code>Keep-Alive</code></p>
<p><code>http 1.1</code>中默认启用<code>Keep-Alive</code>，如果加入<code>Connection: close</code>，才关闭</p>
<p>目前大部分浏览器都是用<code>http1.1</code>协议，也就是说默认都会发起<code>Keep-Alive</code>的连接请求了，所以是否能完成一个完整的<code>Keep-Alive</code>连接就看服务器设置情况</p>
<h4 id="启用Keep-Alive的优点"><a href="#启用Keep-Alive的优点" class="headerlink" title="启用Keep-Alive的优点"></a>启用Keep-Alive的优点</h4><p>启用<code>Keep-Alive</code>模式肯定更高效，性能更高。因为避免了【建立/释放】连接的开销</p>
<h4 id="如何判断消息内容长度的大小"><a href="#如何判断消息内容长度的大小" class="headerlink" title="如何判断消息内容长度的大小"></a>如何判断消息内容长度的大小</h4><p><code>Keep-Alive</code>模式，客户端如何判断请求所得到的响应数据已经接收完成，我们已经知道了，<code>Keep-Alive</code>模式发送玩数据HTTP服务器不会自动断开连接，所有不能再使用返回EOF(-1)来判断</p>
<ul>
<li>使用消息首部字段<code>Conent-Length</code><br><code>Conent-Length</code>表示实体内容长度，客户端（服务器）可以根据这个值来判断数据是否接收完成。但是如果消息中没有<code>Conent-Length</code>，那该如何来判断呢</li>
<li>使用消息首部字段<code>Transfer-Encoding</code><br>当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过<code>Content-length</code>消息首部字段告诉客户端需要接收多少数据。但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用<code>Transfer-Encoding: chunk</code>模式来传输数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用<code>Transfer-Encoding: chunked</code>这样的方式来代替<code>Content-Length</code></li>
</ul>
<h3 id="Http能不能一次连接多次请求，不等后端返回"><a href="#Http能不能一次连接多次请求，不等后端返回" class="headerlink" title="Http能不能一次连接多次请求，不等后端返回"></a>Http能不能一次连接多次请求，不等后端返回</h3><ul>
<li><code>HTTP/1.0</code>: 一个tcp连接只能发一个http请求。每次服务端返回响应后TCP连接会断开</li>
<li><code>HTTP/1.1</code>: 默认开启<code>Connection: keep-alive</code>，一个TCP连接可以发多个http请求，但是多个请求是串行执行</li>
<li><code>HTTP/2</code>: 引入了多路复用技术和二进制分帧，同个域名下的请求只需要占用一个 TCP 连接，请求和响应是并行执行</li>
</ul>
<h3 id="TCP-和-UDP-有什么区别-适用场景"><a href="#TCP-和-UDP-有什么区别-适用场景" class="headerlink" title="TCP 和 UDP 有什么区别,适用场景"></a><code>TCP</code> 和 <code>UDP</code> 有什么区别,适用场景</h3><ul>
<li>TCP基于连接, UDP基于无连接</li>
<li>TCP要求系统资源较多, UDP较少</li>
<li>UDP程序结构简单</li>
<li>TCP流模式, UDP数据报模式</li>
<li>TCP保证数据顺序, UDP不保证</li>
</ul>
<p>UDP应用场景:</p>
<ul>
<li>面向数据报方式</li>
<li>网络数据大多为短消息</li>
<li>拥有大量 client</li>
<li>对数据安全性无特殊要求</li>
<li>网络负担非常重，但对响应速度要求高</li>
</ul>
<p>通常我们在说到网络编程时默认是指TCP编程，即用<code>socket</code>函数创建一个<code>socke</code>t用于TCP通讯</p>
<ul>
<li>TCP 编程</li>
<li>UDP 编程</li>
</ul>
<ol>
<li>TCP面向连接, 如打电话要先拨号建立连接. UDP是无连接的，即发送数据之前不需要建立连接</li>
<li>TCP提供可靠的服务, 也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达. UDP尽最大努力交付，不保证可靠交付</li>
<li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流. UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低, 对实时应用很有用，如IP电话，实时视频会议等</li>
<li>每一条TCP连接只能是点到点的. UDP支持一对一，一对多的交互通信</li>
<li>TCP首部开销20字节. UDP的首部开销小，只有8个字节</li>
<li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li>
</ol>
<h3 id="time-wait的作用"><a href="#time-wait的作用" class="headerlink" title="time-wait的作用"></a><code>time-wait</code>的作用</h3><h3 id="数据库如何建索引"><a href="#数据库如何建索引" class="headerlink" title="数据库如何建索引"></a>数据库如何建索引</h3><h3 id="孤儿进程，僵尸进程"><a href="#孤儿进程，僵尸进程" class="headerlink" title="孤儿进程，僵尸进程"></a>孤儿进程，僵尸进程</h3><h3 id="死锁条件，如何避免"><a href="#死锁条件，如何避免" class="headerlink" title="死锁条件，如何避免"></a>死锁条件，如何避免</h3><h3 id="linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程"><a href="#linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程" class="headerlink" title="linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程"></a>linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程</h3><h3 id="git文件版本，使用顺序，merge跟rebase"><a href="#git文件版本，使用顺序，merge跟rebase" class="headerlink" title="git文件版本，使用顺序，merge跟rebase"></a>git文件版本，使用顺序，<code>merge</code>跟<code>rebase</code></h3><h3 id="一般会用到哪些数据结构"><a href="#一般会用到哪些数据结构" class="headerlink" title="一般会用到哪些数据结构"></a>一般会用到哪些数据结构</h3><ul>
<li>数组</li>
<li>栈</li>
<li>队列</li>
<li>链表</li>
<li>图</li>
<li>树</li>
<li>前缀树</li>
<li>哈希表</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1634155">常见数据结构</a></p>
<h3 id="链表和数组相比-有什么优缺点"><a href="#链表和数组相比-有什么优缺点" class="headerlink" title="链表和数组相比, 有什么优缺点"></a>链表和数组相比, 有什么优缺点</h3><p>数组,在内存上给出了连续的空间. 链表,内存地址上可以是不连续的</p>
<p>数组内的数据可随机访问.但链表不具备随机访问性</p>
<p>链表的扩展性比数组好.因为一个数组建立后所占用的空间大小就是固定的.如果满了就没法扩展.只能新建一个更大空间的数组.而链表不是固定的,可以很方便的扩展</p>
<p>内存地址的利用率方面.不管你内存里还有多少空间,如果没办法一次性给出数组所需的要空间,那就会提示内存不足,磁盘空间整理的原因之一在这里.而链表可以是分散的空间地址</p>
<p>如果数组的中间插入一个元素,那么这个元素后的所有元素的内存地址都要往后移动.删除的话同理.只有对数据的最后一个元素进行插入删除操作时,才比较快.链表只需要更改有必要更改的节点内的节点信息就够了.并不需要更改节点的内存地址</p>
<h3 id="如何判断两个无环单链表有没有交叉点"><a href="#如何判断两个无环单链表有没有交叉点" class="headerlink" title="如何判断两个无环单链表有没有交叉点"></a>如何判断两个无环单链表有没有交叉点</h3><h3 id="如何判断一个单链表有没有环-并找出入环点"><a href="#如何判断一个单链表有没有环-并找出入环点" class="headerlink" title="如何判断一个单链表有没有环, 并找出入环点"></a>如何判断一个单链表有没有环, 并找出入环点</h3><h3 id="描述一下-TCP-四次挥手的过程中"><a href="#描述一下-TCP-四次挥手的过程中" class="headerlink" title="描述一下 TCP 四次挥手的过程中"></a>描述一下 TCP 四次挥手的过程中</h3><ul>
<li>第一次挥手(FIN=1，seq=x): 假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据, 发送完毕后，客户端进入 FIN_WAIT_1 状态</li>
<li>第二次挥手(ACK=1，ACKnum=x+1): 服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接. 发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接</li>
<li>第三次挥手(FIN=1，seq=y): 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1. 发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK</li>
<li>第四次挥手(ACK=1，ACKnum=y+1): 客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <code>TIME_WAIT</code>状态，等待可能出现的要求重传的 ACK 包. 服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态. 客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态</li>
</ul>
<h3 id="TCP-有哪些状态"><a href="#TCP-有哪些状态" class="headerlink" title="TCP 有哪些状态"></a>TCP 有哪些状态</h3><h3 id="TCP-的-LISTEN-状态是什么"><a href="#TCP-的-LISTEN-状态是什么" class="headerlink" title="TCP 的 LISTEN 状态是什么"></a>TCP 的 <code>LISTEN</code> 状态是什么</h3><h3 id="TCP-的-CLOSE-WAIT-状态是什么"><a href="#TCP-的-CLOSE-WAIT-状态是什么" class="headerlink" title="TCP 的 CLOSE_WAIT 状态是什么"></a>TCP 的 <code>CLOSE_WAIT</code> 状态是什么</h3><h3 id="建立一个-socket-连接要经过哪些步骤"><a href="#建立一个-socket-连接要经过哪些步骤" class="headerlink" title="建立一个 socket 连接要经过哪些步骤"></a>建立一个 <code>socket</code> 连接要经过哪些步骤</h3><h3 id="常见的-HTTP-状态码有哪些"><a href="#常见的-HTTP-状态码有哪些" class="headerlink" title="常见的 HTTP 状态码有哪些"></a>常见的 <code>HTTP</code> 状态码有哪些</h3><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头用以响应浏览器的请求</p>
<p>下面是常见的HTTP状态码:</p>
<ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
</ul>
<h4 id="HTTP状态码分类"><a href="#HTTP状态码分类" class="headerlink" title="HTTP状态码分类"></a>HTTP状态码分类</h4><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型:</p>
<ul>
<li>1xx: 信息，服务器收到请求，需要请求者继续执行操作</li>
<li>2xx: 成功，操作被成功接收并处理</li>
<li>3xx: 重定向，需要进一步的操作以完成请求</li>
<li>4xx: 客户端错误，请求包含语法错误或无法完成请求</li>
<li>5xx: 服务器错误，服务器在处理请求的过程中发生了错误</li>
</ul>
<h3 id="301和302有什么区别"><a href="#301和302有什么区别" class="headerlink" title="301和302有什么区别"></a><code>301</code>和<code>302</code>有什么区别</h3><p><code>302</code>重定向只是暂时的重定向，搜索引擎会抓取新的内容而保留旧的地址，因为服务器返回<code>302</code>，所以，搜索搜索引擎认为新的网址是暂时的。 而<code>301</code>重定向是永久的重定向，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址</p>
<p>对于301请求，浏览器是默认给一个很长的缓存。而302是不缓存的</p>
<p>302：请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在<code>Cache-Control</code>或<code>Expires</code>中进行了指定的情况下，这个响应才是可缓存的</p>
<h3 id="504和500有什么区别"><a href="#504和500有什么区别" class="headerlink" title="504和500有什么区别"></a><code>504</code>和<code>500</code>有什么区别</h3><ul>
<li>502 Bad Gateway错误</li>
<li>504 Bad Gateway timeout 网关超时</li>
<li>500 后端脚本出现错误。或者高并发时候因为系统资源限制，而不能打开过多文件</li>
</ul>
<h3 id="HTTPS-和-HTTP-有什么区别"><a href="#HTTPS-和-HTTP-有什么区别" class="headerlink" title="HTTPS 和 HTTP 有什么区别"></a><code>HTTPS</code> 和 <code>HTTP</code> 有什么区别</h3><p>HTTP（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。被用于在 Web 浏览器和网站服务器之间传递信息, HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 <code>http://</code> 打头的都是标准 HTTP 服务. HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息</p>
<p>HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 <code>SSL/TLS</code> 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性</p>
<p>HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式:</p>
<ul>
<li>TCP 三次同步握手</li>
<li>客户端验证服务器数字证书</li>
<li>DH 算法协商对称加密算法的密钥、hash 算法的密钥</li>
<li>SSL 安全加密隧道协商完成</li>
<li>网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改</li>
</ul>
<h4 id="HTTP-与-HTTPS-区别"><a href="#HTTP-与-HTTPS-区别" class="headerlink" title="HTTP 与 HTTPS 区别"></a>HTTP 与 HTTPS 区别</h4><ul>
<li>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好</li>
<li>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用</li>
<li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包</li>
<li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443</li>
<li>TTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以 HTTPS 比 HTTP 要更耗费服务器资源</li>
</ul>
<h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><p>在TCP/IP协议中，TCP协议通过三次握手建立一个可靠的连接</p>
<ul>
<li>第一次握手：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认</li>
<li>第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态</li>
<li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</li>
</ul>
<h4 id="HTTPS-的工作原理"><a href="#HTTPS-的工作原理" class="headerlink" title="HTTPS 的工作原理"></a>HTTPS 的工作原理</h4><p>HTTPS 能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用 HTTPS 协议</p>
<ol>
<li>客户端发起 HTTPS 请求</li>
<li>服务端的配置, 采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面, 这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西</li>
<li>传送证书, 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等</li>
<li>客户端解析证书, 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题, 如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容</li>
<li>传送加密信息, 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了</li>
<li>服务端解密信息, 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全</li>
<li>传输加密后的信息, 这部分信息是服务端用私钥加密后的信息，可以在客户端被还原</li>
<li>客户端解密信息, 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策</li>
</ol>
<h3 id="手写一个快速排序"><a href="#手写一个快速排序" class="headerlink" title="手写一个快速排序"></a>手写一个快速排序</h3><p>快速排序利用的是分治思想，假设要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为分区点，我们遍历 p 到 r 之间的数据，将小于分区点的放到左边，将大于分区点的放到右边，将分区点放到中间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func QuickSort(arr []int) &#123;</span><br><span class="line">    separateSort(arr, 0, len(arr)-1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func separateSort(arr []int, start, end int) &#123;</span><br><span class="line">    if start &gt;&#x3D; end &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    i :&#x3D; partition(arr, start, end)</span><br><span class="line">    separateSort(arr, start, i-1)</span><br><span class="line">    separateSort(arr, i+1, end)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func partition(arr []int, start, end int) int &#123;</span><br><span class="line">    pivot :&#x3D; arr[end]</span><br><span class="line">    var i &#x3D; start</span><br><span class="line">    for j :&#x3D; start; j &lt; end; j++ &#123;</span><br><span class="line">        if arr[j] &lt; pivot &#123;</span><br><span class="line">            if !(i &#x3D;&#x3D; j) &#123;</span><br><span class="line">                arr[i], arr[j] &#x3D; arr[j], arr[i]</span><br><span class="line">            &#125;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i], arr[end] &#x3D; arr[end], arr[i]</span><br><span class="line">    return i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置中心如何保证一致性"><a href="#配置中心如何保证一致性" class="headerlink" title="配置中心如何保证一致性"></a>配置中心如何保证一致性</h3><h3 id="Redis-里数据结构的实现熟悉吗"><a href="#Redis-里数据结构的实现熟悉吗" class="headerlink" title="Redis 里数据结构的实现熟悉吗"></a>Redis 里数据结构的实现熟悉吗</h3><ul>
<li>字符串 String</li>
<li>列表 List</li>
<li>字典 Hash</li>
<li>集合 Set</li>
<li>有序集合 Zset</li>
</ul>
<h3 id="SLB原理"><a href="#SLB原理" class="headerlink" title="SLB原理"></a>SLB原理</h3><h3 id="分布式一致性原则"><a href="#分布式一致性原则" class="headerlink" title="分布式一致性原则"></a>分布式一致性原则</h3><h3 id="智能指针-–-gt-C"><a href="#智能指针-–-gt-C" class="headerlink" title="智能指针 –&gt; C++"></a>智能指针 –&gt; C++</h3><h3 id="唯一索引和主键索引"><a href="#唯一索引和主键索引" class="headerlink" title="唯一索引和主键索引"></a>唯一索引和主键索引</h3><h3 id="tcp粘包"><a href="#tcp粘包" class="headerlink" title="tcp粘包"></a>tcp粘包</h3><p>在socket网络编程中，都是端到端通信，由<code>客户端端口+服务端端口+客户端IP+服务端IP+传输协议</code>组成的五元组可以明确的标识一条连接。在TCP的socket编程中，发送端和接收端都有成对的socket。发送端为了将多个发往接收端的包，更加高效的的发给接收端，于是采用了优化算法（Nagle算法），将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。那么这样一来，接收端就必须使用高效科学的拆包机制来分辨这些数据</p>
<p>TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。 TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理</p>
<h3 id="进程虚拟空间分布"><a href="#进程虚拟空间分布" class="headerlink" title="进程虚拟空间分布"></a>进程虚拟空间分布</h3><h3 id="c-和-go-和-java-对比"><a href="#c-和-go-和-java-对比" class="headerlink" title="c++ 和 go 和 java 对比"></a>c++ 和 go 和 java 对比</h3><h3 id="堆的时间复杂度，稳定性"><a href="#堆的时间复杂度，稳定性" class="headerlink" title="堆的时间复杂度，稳定性"></a>堆的时间复杂度，稳定性</h3><h3 id="几种基本排序算法"><a href="#几种基本排序算法" class="headerlink" title="几种基本排序算法"></a>几种基本排序算法</h3><ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li>希尔排序</li>
<li>归并排序</li>
<li>快速排序</li>
<li>堆排序</li>
<li>计数排序</li>
<li>桶排序</li>
<li>基数排序</li>
</ul>
<h3 id="top-K-问题"><a href="#top-K-问题" class="headerlink" title="top-K 问题"></a>top-K 问题</h3><p>什么是 Top K 问题: 简单来说就是在一堆数据里面找到前 K 大（当然也可以是前 K 小）的数</p>
<h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>既然是要前 K 大的数，那么最直接的当然就是排序了，通过如快排等效率较高的排序算法，可以在平均 <code>O(nlogn)</code> 的时间复杂度找到结果</p>
<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>快排的 partition 划分思想可以用于计算某个位置的数值等问题，例如用来计算中位数；显然，也适用于计算 TopK 问题</p>
<p>每次经过划分，如果中间值等于 K ，那么其左边的数就是 Top K 的数据； 当然，如果不等于，只要递归处理左边或者右边的数即可</p>
<p>在海量数据的情况下，我们很有可能没办法一次性将数据全部加载入内存</p>
<h4 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h4><p>面对海量数据，我们就可以放分布式的方向去思考了</p>
<p>我们可以将数据分散在多台机器中，然后每台机器并行计算各自的 TopK 数据，最后汇总，再计算得到最终的 TopK 数据</p>
<p>这种数据分片的分布式思想在面试中非常值得一提，在实际项目中也十分常见</p>
<h4 id="解法四"><a href="#解法四" class="headerlink" title="解法四"></a>解法四</h4><p>提到 Top K 问题，最经典的解法还是利用堆</p>
<p>维护一个大小为 K 的小顶堆，依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较：如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中。遍历完全部数据，Top K 的元素也自然都在堆里面了</p>
<p>对于海量数据，我们不需要一次性将全部数据取出来，可以一次只取一部分，因为我们只需要将数据一个个拿来与堆顶比较</p>
<h3 id="什么是主键"><a href="#什么是主键" class="headerlink" title="什么是主键"></a>什么是主键</h3><p>主键: 数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的键。一个数据表只能有一个主键，且主键的取值不能缺失，即不能为空值</p>
<h3 id="联合索引和唯一索引"><a href="#联合索引和唯一索引" class="headerlink" title="联合索引和唯一索引"></a>联合索引和唯一索引</h3><h3 id="越多的索引越好吗"><a href="#越多的索引越好吗" class="headerlink" title="越多的索引越好吗"></a>越多的索引越好吗</h3><p>索引并不是建立越多越好，把索引比作目录，相当于，一本100页的书，如果有50页目录，书本这么厚，实际内容就那么少，谁还会去翻看</p>
<ul>
<li>数据量小的表不需要建立索引,建立会增加额外的索引开销</li>
<li>数据变更需要维护索引,因此更多的索引意味着更多的维护成本</li>
<li>更多的索引意味着也需要更多的空间</li>
<li>不经常引用的列不要建立索引，因为不常用，即使建立了索引也没有多大意义。对经常用于查询的字段应该创建索引</li>
<li>经常频繁更新的列不要建立索引，因为肯定会影响插入或更新的效率</li>
</ul>
<p>索引用于快速找出在某个列中有一特定值的行，不使用索引，MySQL必须从第一条记录开始读完整个表，直到找出相关的行，表越大，查询数据所花费的时间就越多，所以索引还是很有用的</p>
<p>其中MySQL中的索引的存储类型有两种：<code>Btree</code>、<code>HASH</code>，平时我们经常见到的基本都是 <code>b+树</code></p>
<p><code>MyISAM</code>（非聚簇索引）和<code>InnoDB</code>（聚簇索引）存储引擎：只支持<code>BTREE</code>索引， 也就是说默认使用<code>BTREE</code>，这也是我们经常见到的，不能够更换<code>MEMORY/HEAP</code>存储引擎：支持<code>HASH</code>和<code>BTREE</code>索引</p>
<p><strong>聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针</strong></p>
<h3 id="建立索引要注意什么"><a href="#建立索引要注意什么" class="headerlink" title="建立索引要注意什么"></a>建立索引要注意什么</h3><ul>
<li>确定针对该表的操作是大量的查询操作还是大量的增删改操作</li>
<li>尝试建立索引来帮助特定的查询。检查自己的sql语句，为那些频繁在where子句中出现的字段建立索引</li>
<li>尝试建立复合索引来进一步提高系统性能。修改复合索引将消耗更长时间，同时，复合索引也占磁盘空间</li>
<li>对于小型的表，建立索引可能会影响性能</li>
<li>应该避免对具有较少值的字段进行索引</li>
<li>避免选择大型数据类型的列作为索引</li>
<li>在经常用作过滤器的字段上建立索引</li>
<li>在SQL语句中经常进行GROUP BY、ORDER BY的字段上建立索引</li>
<li>在不同值较少的字段上不必要建立索引，如性别字段</li>
<li>对于经常存取的列避免建立索引</li>
<li>在经常存取的多个列上建立复合索引，但要注意复合索引的建立顺序要按照使用的频度来确定</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。 此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程</p>
<p>死锁（英语：deadlock），又译为死结，计算机科学名词。当两个以上的运算单元，双方都在等待对方停止运行，以获取系统资源，但是没有一方提前退出时，就称为死锁</p>
<p>例如，一个进程 p1占用了显示器，同时又必须使用打印机，而打印机被进程p2占用，p2又必须使用显示器，这样就形成了死锁。 因为p1必须等待p2发布打印机才能够完成工作并发布屏幕，同时p2也必须等待p1发布显示器才能完成工作并发布打印机，形成循环等待的死锁</p>
<p>死锁的四个条件是：</p>
<ul>
<li>禁止抢占（no preemption）：系统资源不能被强制从一个进程中退出</li>
<li>持有和等待（hold and wait）：一个进程可以在等待时持有系统资源</li>
<li>互斥（mutual exclusion）：资源只能同时分配给一个行程，无法多个行程共享</li>
<li>循环等待（circular waiting）：一系列进程互相持有其他进程所需要的资源</li>
</ul>
<p>死锁只有在四个条件同时满足时发生，预防死锁必须至少破坏其中一项</p>
<h3 id="tcp三次握手"><a href="#tcp三次握手" class="headerlink" title="tcp三次握手"></a>tcp三次握手</h3><p>所谓三次握手，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包</p>
<p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 <code>connect()</code> 时。将触发三次握手</p>
<ul>
<li>第一次握手(SYN=1, seq=x)<br>客户端发送一个 TCP 的 <code>SYN</code> 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里, 发送完毕后，客户端进入 <code>SYN_SEND</code> 状态</li>
<li>第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1)<br>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 <code>SYN_RCVD</code> 状态</li>
<li>第三次握手(ACK=1，ACKnum=y+1)<br>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1, 发送完毕后，客户端进入 <code>ESTABLISHED</code> 状态，当服务器端接收到这个包时，也进入 <code>ESTABLISHED</code> 状态，TCP 握手结束</li>
</ul>
<h3 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h3><p>事务的四种隔离级别:</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th align="center">脏读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>未提交读（Read uncommitted）</td>
<td align="center">可能</td>
<td>可能</td>
</tr>
<tr>
<td>已提交读（Read committed）</td>
<td align="center">不可能</td>
<td>可能</td>
</tr>
<tr>
<td>可重复读（Repeatable read）</td>
<td align="center">不可能</td>
<td>可能</td>
</tr>
<tr>
<td>可串行化（Serializable ）</td>
<td align="center">不可能</td>
<td>不可能</td>
</tr>
</tbody></table>
<p><strong>脏读:</strong> 当一个事务允许读取另外一个事务修改但未提交的数据时，就可能发生脏读</p>
<p><strong>不可重复读:</strong> 在一次事务中，当一行数据获取两遍得到不同的结果表示发生了不可重复读</p>
<p><strong>幻读:</strong> 在事务执行过程中，当两个完全相同的查询语句执行得到不同的结果集, 这种现象称为幻读.</p>
<ul>
<li>可串行化: 可串行化（SERIALIZABLE）是最高的隔离级别, 在基于锁机制并发控制的DBMS上，可串行化要求在选定对象上的读锁和写锁直到事务结束后才能释放。在SELECT的查询中使用一个“WHERE”子句来描述一个范围时应该获得一个<strong>范围锁</strong>（range-locks）。这种机制可以避免幻读现象</li>
<li>可重复读: 在可重复读隔离级别中，基于锁机制并发控制的DBMS需要对选定对象的读锁（read locks）和写锁（write locks）一直保持到事务结束，但不要求范围锁，因此可能会发生<strong>幻读</strong></li>
<li>提交读: 在提交读（READ COMMITTED）级别中，基于锁机制并发控制的DBMS需要对选定对象的写锁一直保持到事务结束，但是读锁在SELECT操作完成后马上释放, 因此不可重复读现象可能会发生。和前一种隔离级别一样，也不要求范围锁</li>
<li>未提交读: 未提交读（READ UNCOMMITTED）是最低的隔离级别。允许脏读（dirty reads），事务可以看到其他事务<strong>尚未提交</strong>的修改</li>
</ul>
<h3 id="cookie与session"><a href="#cookie与session" class="headerlink" title="cookie与session"></a><code>cookie</code>与<code>session</code></h3><p>http是一个无状态协议: 什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。这种无状态的的好处是快速。坏处是假如我们想要把<code>www.ifcalm.net/login.html</code>和<code>www.ifcalm.net/index.html</code>关联起来，必须使用某些手段和工具</p>
<p>由于http的无状态性，为了使某个域名下的所有网页能够共享某些数据，<code>session</code>和<code>cookie</code>出现了。客户端访问服务器的流程如下:</p>
<ul>
<li>首先，客户端会发送一个http请求到服务器端</li>
<li>服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。该头部包含了sessionId</li>
<li>在客户端发起的第二次请求，假如服务器给了set-Cookie，浏览器会自动在请求头中添加cookie</li>
<li>服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端</li>
</ul>
<p>cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中, 现在大多都是Session + Cookie，但是只用session不用cookie，或是只用cookie，不用session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用, 用session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。如果全部用cookie，数据量大的时候客户端是没有那么多空间的, 如果只用cookie不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大</p>
<p><strong>session 有如用户信息档案表, 里面包含了用户的认证信息和登录状态等信息. 而 cookie 就是用户通行证</strong></p>
<h4 id="token"><a href="#token" class="headerlink" title="token"></a>token</h4><p>token 也称作令牌, token 的认证方式类似于临时的证书签名, 并且是一种服务端无状态的认证方式, 非常适合于 <code>REST API</code> 的场景. 所谓无状态就是服务端并不会保存身份认证相关的数据</p>
<p>token 组成: </p>
<ul>
<li>uid: 用户唯一身份标识</li>
<li>time: 当前时间的时间戳</li>
<li>sign: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接</li>
<li>固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库</li>
</ul>
<h3 id="select-和-epoll"><a href="#select-和-epoll" class="headerlink" title="select 和 epoll"></a>select 和 epoll</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003063859">select和epoll详解</a></p>
<p>socket编程并发处理的问题中，<code>select</code>和<code>epoll</code>函数的区别一直是面试中的重点</p>
<h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a><code>TCP</code> 拥塞控制</h3><p>TCP拥塞控制是传输控制协议（Transmission Control Protocol）避免网络拥塞的算法，是互联网上主要的一个拥塞控制措施。它使用一套基于线增积减模式的多样化网络拥塞控制方法, 包括慢启动和拥塞窗口等模式, 来控制拥塞</p>
<p>TCP使用多种拥塞控制策略来避免雪崩式拥塞。TCP会为每条连接维护一个拥塞窗口来限制可能在端对端间传输的未确认分组总数量。这类似TCP流量控制机制中使用的滑动窗口。TCP在一个连接初始化或超时后使用一种<strong>慢启动</strong>机制来增加拥塞窗口的大小。它的起始值一般为最大分段大小（Maximum segment size，MSS）的两倍，虽然名为“慢启动”，初始值也相当低，但其增长极快：当每个分段得到确认时，拥塞窗口会增加一个MSS，使得在每次往返时间（round-trip time，RTT）内拥塞窗口能高效地双倍增长</p>
<p>当拥塞窗口超过慢启动阈值（ssthresh）时，算法就会进入一个名为拥塞避免的阶段。在拥塞避免阶段，只要未收到重复确认，拥塞窗口则在每次往返时间内线性增加一个MSS大小</p>
<h4 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口"></a>拥塞窗口</h4><p>在TCP中，拥塞窗口（congestion window）是任何时刻内确定能被发送出去的字节数的控制因素之一，是阻止发送方至接收方之间的链路变得拥塞的手段。他是由发送方维护，通过估计链路的拥塞程度计算出来的，与由接收方维护的接收窗口大小并不冲突。</p>
<p>当一条连接创建后，每个主机独立维护一个拥塞窗口并设置值为连接所能承受的MSS的最小倍数，之后的变化依靠线增积减机制来控制，这意味如果所有分段到达接收方和确认包准时地回到发送方，拥塞窗口会增加一定数量。该窗口会保持指数增大，直到发生超时或者超过一个称为慢启动阈值（ssthresh）的限值。如果发送方到达这个阈值时，每收到一个新确认包，拥塞窗口只按照线性速度增加自身值的倒数。</p>
<p>当发生超时的时候，慢启动阈值降为超时前拥塞窗口的一半大小、拥塞窗口会降为1个MSS，并且重新回到慢启动阶段。</p>
<p>系统管理员可以设置窗口最大限值，或者调整拥塞窗口的增加量，来对TCP调优。</p>
<p>在流量控制中，接收方通过TCP的窗口值（Window Size）来告知发送方，由发送方通过对拥塞窗口和接收窗口的大小比较，来确定任何时刻内需要传输的数据量</p>
<h4 id="tcp-的四种拥塞控制算法"><a href="#tcp-的四种拥塞控制算法" class="headerlink" title="tcp 的四种拥塞控制算法"></a>tcp 的四种拥塞控制算法</h4><ul>
<li>慢开始</li>
<li>拥塞控制</li>
<li>快重传</li>
<li>快恢复</li>
</ul>
<h3 id="Mysql-用的是什么数据结构"><a href="#Mysql-用的是什么数据结构" class="headerlink" title="Mysql 用的是什么数据结构"></a><code>Mysql</code> 用的是什么数据结构</h3><p>在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储数据结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速查找到所需的内容</p>
<h3 id="kafka-的工作原理"><a href="#kafka-的工作原理" class="headerlink" title="kafka 的工作原理"></a><code>kafka</code> 的工作原理</h3><p>Kafka是一种高吞吐量的分布式发布订阅消息系统</p>
<ul>
<li>Broker: Kafka集群包含一个或多个服务器，这种服务器被称为broker，可以水平扩展，一般broker数量越多，集群吞吐率越高，而且kafka 每个节点可以有多个 broker</li>
<li>Producer: 负责发布消息到Kafka broker，可以是web前端产生的page view，或者是服务器日志，系统CPU、memory等</li>
<li>Consumer: 费消息。每个consumer属于一个特定的consumer group（可为每个consumer指定group name，若不指定group name则属于默认的group）。使用consumer high level API时，同一topic的一条消息只能被同一个consumer group内的一个consumer消费，但多个consumer group可同时消费这一消息</li>
<li>Zookeeper: 通过Zookeeper管理集群配置，选举leader，以及在consumer group发生变化时进行rebalance</li>
<li>Topic: 每条发布到Kafka集群的消息都有一个类别，这个类别被称为topic</li>
<li>Partition: parition是物理上的概念，每个topic包含一个或多个partition，创建topic时可指定parition数量。每个partition对应于一个文件夹，该文件夹下存储该partition的数据和索引文件</li>
<li>Segment: partition物理上由多个segment组成，每一个segment 数据文件都有一个索引文件对应</li>
<li>Offset: 每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做offset,用于partition唯一标识一条消息</li>
</ul>
<h4 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h4><p>在软件架构中，发布-订阅是一种消息范式，消息的发送者, 称为发布者, 不会将消息直接发送给特定的接收者, 称为订阅者。而是将发布的消息分为不同的类别，无需了解哪些订阅者可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在</p>
<p>在发布/订阅模型中，订阅者通常接收所有发布的消息的一个子集。选择接受和处理的消息的过程被称作过滤。有两种常用的过滤形式：基于主题的和基于内容的</p>
<p>在基于主题的系统中，消息被发布到主题或命名通道上。订阅者将收到其订阅的主题上的所有消息，并且所有订阅同一主题的订阅者将接收到同样的消息。发布者负责定义订阅者所订阅的消息类别</p>
<p>在基于内容的系统中，订阅者定义其感兴趣的消息的条件，只有当消息的属性或内容满足订阅者定义的条件时，消息才会被投递到该订阅者。订阅者需要负责对消息进行分类</p>
<h3 id="详细描述一下-HTTPS-的加密过程，需要几次通信"><a href="#详细描述一下-HTTPS-的加密过程，需要几次通信" class="headerlink" title="详细描述一下 HTTPS 的加密过程，需要几次通信"></a>详细描述一下 <code>HTTPS</code> 的加密过程，需要几次通信</h3><ol>
<li>客户端请求服务器获取 证书公钥</li>
<li>客户端(SSL/TLS)解析证书（无效会弹出警告）</li>
<li>生成随机值</li>
<li>用 公钥加密 随机值生成密钥</li>
<li>客户端将 秘钥 发送给服务器</li>
<li>服务端用 私钥 解密 秘钥 得到随机值</li>
<li>将信息和随机值混合在一起 进行对称加密</li>
<li>将加密的内容发送给客户端</li>
</ol>
<p>HTTPS，全称：Hyper Text Transfer Protocol over Secure Socket Layer 超文本传输安全协议</p>
<p>HTTPS在传统的HTTP和TCP之间加了一层用于加密解密的SSL/TLS层【安全套接层Secure Sockets Layer/安全传输层Transport Layer Security】。使用HTTPS必须要有一套自己的数字证书, 包含公钥和私钥.</p>
<h4 id="HTTPS解决的问题"><a href="#HTTPS解决的问题" class="headerlink" title="HTTPS解决的问题"></a>HTTPS解决的问题</h4><ul>
<li>信息加密传输：第三方无法窃听</li>
<li>校验机制：一旦被篡改，通信双方会立刻发现</li>
<li>身份证书：防止身份被冒充</li>
</ul>
<h3 id="三次握手和四次挥手，说一下-time-wait"><a href="#三次握手和四次挥手，说一下-time-wait" class="headerlink" title="三次握手和四次挥手，说一下 time_wait"></a>三次握手和四次挥手，说一下 <code>time_wait</code></h3><h4 id="TCP-报文的结构"><a href="#TCP-报文的结构" class="headerlink" title="TCP 报文的结构"></a>TCP 报文的结构</h4><ul>
<li>端口号：每个 TCP 报文段都包含源端和目的端的端口号，用于寻找发送端和接收端应用进程。这两个值加上 IP 首部中的源端 IP 地址和目的端 IP 地址就可以确定一个唯一的 TCP 连接</li>
<li>序号：这个字段的主要作用是用于将失序的数据重新排列。TCP 会隐式地对字节流中的每个字节进行编号，而 TCP 报文段的序号被设置为其数据部分的第一个字节的编号。序号是 <code>32bit</code> 的无符号数，取值范围是<code>0 - 2^32-1</code></li>
<li>确认序号：接收方在接受到数据后，会回复确认报文，其中包含确认序号，作用就是告诉发送方自己接收到了哪些数据，下一次数据从哪里开始发，因此，确认序号应当是上次已成功收到数据字节序号加 1。只有 ACK 标志为 1 时确认序号字段才有效</li>
<li>首部长度：首部中的选项部分的长度是可变的，因此首部的长度也是可变的，所以需要这个字段来明确表示首部的长度，这个字段占 4 bit，4 位的二进制数最大可以表示 15，而首部长度是以 4 个字节为一个单位的，因此首部最大长度是 15 * 4 = 60 字节</li>
<li>保留字段：占 6 位，未来可能有具体用途，目前默认值为0</li>
<li>控制位：在三次握手和四次挥手中会经常看到 SYN、ACK 和 FIN 的身影，一共有 6 个标志位，它们表示的意义如下:<ol>
<li>URG (Urgent Bit)：值为 1 时，紧急指针生效</li>
<li>ACK (Acknowledgment Bit)：值为 1 时，确认序号生效</li>
<li>PSH (Push Bit)：接收方应尽快将这个报文段交给应用层</li>
<li>RST (Reset Bit)：发送端遇到问题，想要重建连接</li>
<li>SYN (Synchronize Bit)：同步序号，用于发起一个连接</li>
<li>FIN (Finish Bit)：发送端要求关闭连接</li>
</ol>
</li>
<li>窗口大小 (Window)： TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个 16 bit 字段，单位是字节， 因而窗口大小最大为 65535 字节</li>
<li>检验和 (Checksum)：功能类似于数字签名，用于验证数据完整性，也就是确保数据未被修改。检验和覆盖了整个 TCP 报文段，包括 TCP 首部和 TCP 数据，发送端根据特定算法对整个报文段计算出一个检验和，接收端会进行计算并验证</li>
<li>紧急指针 (Urgent Pointer)：当 URG 控制位值为 1 时，此字段生效，紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式</li>
<li>选项 (Options)：这一部分是可选字段，也就是非必须字段，最常见的可选字段是<em>最长报文大小 (MSS，Maximum Segment Size)</em></li>
<li>有效数据部分 (Data)：这部分也不是必须的，比如在建立和关闭 TCP 连接的阶段，双方交换的报文段就只包含 TCP 首部</li>
</ul>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul>
<li>第一次握手：客户端向服务器发送报文段1，其中的 SYN 标志位的值为 1，表示这是一个用于请求发起连接的报文段，其中的序号字段 (Sequence Number，图中简写为seq)被设置为初始序号x (Initial Sequence Number，ISN)，TCP 连接双方均可随机选择初始序号。发送完报文段1之后，客户端进入 SYN-SENT 状态，等待服务器的确认</li>
<li>第二次握手：服务器在收到客户端的连接请求后，向客户端发送报文段2作为应答，其中 ACK 标志位设置为 1，表示对客户端做出应答，其确认序号字段 (Acknowledgment Number，图中简写为小写 ack) 生效，该字段值为 x + 1，也就是从客户端收到的报文段的序号加一，代表服务器期望下次收到客户端的数据的序号。此外，报文段2的 SYN 标志位也设置为1，代表这同时也是一个用于发起连接的报文段，序号 seq 设置为服务器初始序号y。发送完报文段2后，服务器进入 SYN-RECEIVED 状态</li>
<li>第三次握手：客户端在收到报文段2后，向服务器发送报文段3，其 ACK 标志位为1，代表对服务器做出应答，确认序号字段 ack 为 y + 1，序号字段 seq 为 x + 1。此报文段发送完毕后，双方都进入 ESTABLISHED 状态，表示连接已建立</li>
</ul>
<h4 id="TCP-建立连接为什么要三次握手而不是两次"><a href="#TCP-建立连接为什么要三次握手而不是两次" class="headerlink" title="TCP 建立连接为什么要三次握手而不是两次"></a>TCP 建立连接为什么要三次握手而不是两次</h4><ul>
<li>防止已过期的连接请求报文突然又传送到服务器，因而产生错误, 在双方两次握手即可建立连接的情况下，假设客户端发送 A 报文段请求建立连接，由于网络原因造成 A 暂时无法到达服务器，服务器接收不到请求报文段就不会返回确认报文段，客户端在长时间得不到应答的情况下重新发送请求报文段 B，这次 B 顺利到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，客户端在收到 确认报文后也进入 ESTABLISHED 状态，双方建立连接并传输数据，之后正常断开连接。此时姗姗来迟的 A 报文段才到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，但是已经进入 CLOSED 状态的客户端无法再接受确认报文段，更无法进入 ESTABLISHED 状态，这将导致服务器长时间单方面等待，造成资源浪费</li>
<li>三次握手才能让双方均确认自己和对方的发送和接收能力都正常<ol>
<li>第一次握手：客户端只是发送出请求报文段，什么都无法确认，而服务器可以确认自己的接收能力和对方的发送能力正常</li>
<li>第二次握手：客户端可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常</li>
<li>第三次握手：服务器可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常</li>
<li>可见三次握手才能让双方都确认自己和对方的发送和接收能力全部正常，这样就可以愉快地进行通信了</li>
</ol>
</li>
<li>告知对方自己的初始序号值，并确认收到对方的初始序号值, TCP 实现了可靠的数据传输，原因之一就是 TCP 报文段中维护了序号字段和确认序号字段，也就是图中的 seq 和 ack，通过这两个字段双方都可以知道在自己发出的数据中，哪些是已经被对方确认接收的。这两个字段的值会在初始序号值得基础递增，如果是两次握手，只有发起方的初始序号可以得到确认，而另一方的初始序号则得不到确认</li>
</ul>
<h4 id="TCP-建立连接为什么要三次握手而不是四次"><a href="#TCP-建立连接为什么要三次握手而不是四次" class="headerlink" title="TCP 建立连接为什么要三次握手而不是四次"></a>TCP 建立连接为什么要三次握手而不是四次</h4><p>因为三次握手已经可以确认双方的发送接收能力正常，双方都知道彼此已经准备好，而且也可以完成对双方初始序号值得确认，也就无需再第四次握手了</p>
<h4 id="有一种网络攻击是利用了-TCP-建立连接机制的漏洞，这个问题怎么解决"><a href="#有一种网络攻击是利用了-TCP-建立连接机制的漏洞，这个问题怎么解决" class="headerlink" title="有一种网络攻击是利用了 TCP 建立连接机制的漏洞，这个问题怎么解决"></a>有一种网络攻击是利用了 TCP 建立连接机制的漏洞，这个问题怎么解决</h4><p>在三次握手过程中，服务器在收到了客户端的 SYN 报文段后，会分配并初始化连接变量和缓存，并向客户端发送 SYN + ACK 报文段，这相当于是打开了一个<em>半开连接 (half-open connection)<em>，会消耗服务器资源。如果客户端正常返回了 ACK 报文段，那么双方可以正常建立连接，否则，服务器在等待一分钟后会终止这个</em>半开连接</em>并回收资源。这样的机制为 SYN洪泛攻击 (SYN flood attack)提供了机会，这是一种经典的 DoS攻击 (Denial of Service，拒绝服务攻击)，所谓的拒绝服务攻击就是通过进行攻击，使受害主机或网络不能提供良好的服务，从而间接达到攻击的目的。在 SYN 洪泛攻击中，攻击者发送大量的 SYN 报文段到服务器请求建立连接，但是却不进行第三次握手，这会导致服务器打开大量的半开连接，消耗大量的资源，最终无法进行正常的服务</p>
<p><em>解决方法</em>：SYN Cookies，现在大多数主流操作系统都有这种防御系统。SYN Cookies 是对 TCP 服务器端的三次握手做一些修改，专门用来防范 SYN 洪泛攻击的一种手段。它的原理是，在服务器接收到 SYN 报文段并返回 SYN + ACK 报文段时，不再打开一个半开连接，也不分配资源，而是根据这个 SYN 报文段的重要信息 (包括源和目的 IP 地址，端口号可一个秘密数)，利用特定散列函数计算出一个 cookie 值。这个 cookie 作为将要返回的SYN + ACK 报文段的初始序列号(ISN)。当客户端返回一个 ACK 报文段时，服务器根据首部字段信息计算 cookie，与返回的确认序号(初始序列号 + 1)进行对比，如果相同，则是一个正常连接，然后分配资源并建立连接，否则拒绝建立连接</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>建立一个连接需要三次握手，而终止一个连接要经过 4次握手。这由 TCP 的半关闭( half-close) 造成的。既然一个 TCP 连接是全双工 (即数据在两个方向上能同时传递)， 因此每个方向必须单独地进行关闭。这原则就是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向连接。当一端收到一个 FIN，它必须通知应用层另一端已经终止了数据传送。理论上客户端和服务器都可以发起主动关闭，但是更多的情况下是客户端主动发起</p>
<ul>
<li>客户端发送关闭连接的报文段，FIN 标志位1，请求关闭连接，并停止发送数据。序号字段 seq = x (等于之前发送的所有数据的最后一个字节的序号加一)，然后客户端会进入 FIN-WAIT-1 状态，等待来自服务器的确认报文</li>
<li>服务器收到 FIN 报文后，发回确认报文，ACK = 1， ack = x + 1，并带上自己的序号 seq = y，然后服务器就进入 CLOSE-WAIT 状态。服务器还会通知上层的应用程序对方已经释放连接，此时 TCP 处于半关闭状态，也就是说客户端已经没有数据要发送了，但是服务器还可以发送数据，客户端也还能够接收</li>
<li>客户端收到服务器的 ACK 报文段后随即进入 FIN-WAIT-2 状态，此时还能收到来自服务器的数据，直到收到 FIN 报文段</li>
<li>服务器发送完所有数据后，会向客户端发送 FIN 报文段，随后服务器进入 LAST-ACK 状态，等待来自客户端的确认报文段</li>
<li>客户端收到来自服务器的 FIN 报文段后，向服务器发送 ACK 报文，随后进入 <code>TIME-WAIT</code> 状态，等待 2MSL(2 * Maximum Segment Lifetime，两倍的报文段最大存活时间) ，这是任何报文段在被丢弃前能在网络中存在的最长时间，常用值有30秒、1分钟和2分钟。如无特殊情况，客户端会进入 CLOSED 状态</li>
<li>服务器在接收到客户端的 ACK 报文后会随即进入 CLOSED 状态，由于没有等待时间，一般而言，服务器比客户端更早进入 CLOSED 状态</li>
</ul>
<h4 id="为什么-TCP-关闭连接为什么要四次而不是三次"><a href="#为什么-TCP-关闭连接为什么要四次而不是三次" class="headerlink" title="为什么 TCP 关闭连接为什么要四次而不是三次"></a>为什么 TCP 关闭连接为什么要四次而不是三次</h4><p>服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回 ACK 报文段，接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 FIN 报文，表示数据已经发送完毕，请求关闭连接，然后客户端再做出应答，因此一共需要四次挥手</p>
<h4 id="客户端为什么需要在-TIME-WAIT-状态等待-2MSL-时间才能进入-CLOSED-状态"><a href="#客户端为什么需要在-TIME-WAIT-状态等待-2MSL-时间才能进入-CLOSED-状态" class="headerlink" title="客户端为什么需要在 TIME-WAIT 状态等待 2MSL 时间才能进入 CLOSED 状态"></a>客户端为什么需要在 TIME-WAIT 状态等待 2MSL 时间才能进入 CLOSED 状态</h4><p>按照常理，在网络正常的情况下，四个报文段发送完后，双方就可以关闭连接进入 CLOSED 状态了，但是网络并不总是可靠的，如果客户端发送的 ACK 报文段丢失，服务器在接收不到 ACK 的情况下会一直重发 FIN 报文段，这显然不是我们想要的。因此客户端为了确保服务器收到了 ACK，会设置一个定时器，并在 TIME-WAIT 状态等待 2MSL 的时间，如果在此期间又收到了来自服务器的 FIN 报文段，那么客户端会重新设置计时器并再次等待 2MSL 的时间，如果在这段时间内没有收到来自服务器的 FIN 报文，那就说明服务器已经成功收到了 ACK 报文，此时客户端就可以进入 CLOSED 状态了</p>
<h3 id="Mysql-的幻读是怎么个情况，Mysql-是如何避免的"><a href="#Mysql-的幻读是怎么个情况，Mysql-是如何避免的" class="headerlink" title="Mysql 的幻读是怎么个情况，Mysql 是如何避免的"></a><code>Mysql</code> 的幻读是怎么个情况，<code>Mysql</code> 是如何避免的</h3><p>幻读指的是在一个事务内，同一<code>SELECT</code>语句在不同时间执行，得到不同的结果集时，就会发生所谓的幻读问题</p>
<p>在一次事务里面，多次查询之后，结果集的个数不一致的情况叫做幻读。而多出来或者少的哪一行被叫做幻行</p>
<p>MySQL 存储引擎 InnoDB 隔离级别 RR 解决了幻读问题, MySQL 四种隔离级别</p>
<h3 id="自旋锁和互斥锁有什么区别"><a href="#自旋锁和互斥锁有什么区别" class="headerlink" title="自旋锁和互斥锁有什么区别"></a>自旋锁和互斥锁有什么区别</h3><p>自旋锁是一种互斥锁的实现方式而已，相比一般的互斥锁会在等待期间放弃cpu，自旋锁（spinlock）则是不断循环并测试锁的状态，这样就一直占着cpu。 互斥锁：用于保护临界区，确保同一时间只有一个线程访问数据</p>
<ul>
<li>互斥锁：用于保护临界区，确保同一时间只有一个线程访问数据。对共享资源的访问，先对互斥量进行加锁，如果互斥量已经上锁，调用线程会阻塞，直到互斥量被解锁。在完成了对共享资源的访问后，要对互斥量进行解锁</li>
<li>自旋锁：与互斥量类似，它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等(自旋)阻塞状态。用在以下情况：锁持有的时间短，而且线程并不希望在重新调度上花太多的成本。<em>原地打转</em></li>
<li>临界区：每个进程中访问临界资源的那段程序称为临界区，每次只允许一个进程进入临界区，进入后不允许其他进程进入</li>
<li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段</li>
</ul>
<p><strong>自旋锁与互斥锁的区别：线程在申请自旋锁的时候，线程不会被挂起，而是处于忙等的状态</strong></p>
<h3 id="用过哪些分布式锁"><a href="#用过哪些分布式锁" class="headerlink" title="用过哪些分布式锁"></a>用过哪些分布式锁</h3><h3 id="redis-setnx-expire-有什么缺点，如何优化"><a href="#redis-setnx-expire-有什么缺点，如何优化" class="headerlink" title="redis setnx + expire 有什么缺点，如何优化"></a>redis <code>setnx + expire</code> 有什么缺点，如何优化</h3><h3 id="打开一个-URL-的过程"><a href="#打开一个-URL-的过程" class="headerlink" title="打开一个 URL 的过程"></a>打开一个 <code>URL</code> 的过程</h3><ul>
<li>DNS 解析:将域名解析成 IP 地址</li>
<li>TCP 连接：TCP 三次握手</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>断开连接：TCP 四次挥手</li>
</ul>
<p>打开一个网页的过程中，浏览器会因页面上的css/js/image等静态资源会多次发起连接请求，所以我们暂且把这个网页加载过程分成两部分:</p>
<ol>
<li><code>jsp/php/aspx</code>页面加载, 假设存在简单的Nginx负载均衡</li>
<li><code>css/js/image</code>等网页静态资源加载, 假设使用CDN</li>
</ol>
<h4 id="1-DNS-解析"><a href="#1-DNS-解析" class="headerlink" title="1. DNS 解析"></a>1. DNS 解析</h4><ul>
<li>浏览器首先搜索浏览器自身缓存的DNS记录</li>
<li>如果浏览器缓存中没有找到需要的记录或记录已经过期，则搜索hosts文件和操作系统缓存</li>
<li>如果在hosts文件和操作系统缓存中没有找到需要的记录或记录已经过期，则向域名解析服务器发送解析请求</li>
<li>如果域名解析服务器也没有该域名的记录，则开始 递归+迭代 解析</li>
<li>获取域名对应的IP后，一步步向上返回，直到返回给浏览器</li>
</ul>
<h4 id="2-发起TCP请求"><a href="#2-发起TCP请求" class="headerlink" title="2. 发起TCP请求"></a>2. 发起TCP请求</h4><p>浏览器会选择一个大于1024的本机端口向目标IP地址的80端口发起TCP连接请求。经过标准的<em>TCP握手</em>流程，建立TCP连接</p>
<h4 id="3-发起HTTP请求"><a href="#3-发起HTTP请求" class="headerlink" title="3. 发起HTTP请求"></a>3. 发起HTTP请求</h4><p>其本质是在建立起的TCP连接中，按照HTTP协议标准发送一个索要网页的请求</p>
<h4 id="4-负载均衡"><a href="#4-负载均衡" class="headerlink" title="4. 负载均衡"></a>4. 负载均衡</h4><p>什么是负载均衡？当一台服务器无法支持大量的用户访问时，将用户分摊到两个或多个服务器上的方法叫负载均衡</p>
<p>如果我们的平台配备了负载均衡的话，前一步DNS解析获得的IP地址应该是我们Nginx负载均衡服务器的IP地址。所以，我们的浏览器将我们的网页请求发送到了Nginx负载均衡服务器上</p>
<p>Nginx根据我们设定的分配算法和规则，选择一台后端的真实Web服务器，与之建立TCP连接、并转发我们浏览器发出去的网页请求</p>
<p>Web服务器收到请求，产生响应，并将网页发送给Nginx负载均衡服务器</p>
<p>Nginx负载均衡服务器将网页传递给filters链处理，之后发回给我们的浏览器</p>
<h4 id="5-浏览器渲染"><a href="#5-浏览器渲染" class="headerlink" title="5. 浏览器渲染"></a>5. 浏览器渲染</h4><ul>
<li>浏览器根据页面内容，生成DOM Tree。根据CSS内容，生成CSS Rule Tree(规则树)。调用JS执行引擎执行JS代码</li>
<li>根据DOM Tree和CSS Rule Tree生成Render Tree(呈现树)</li>
<li>根据Render Tree渲染网页</li>
</ul>
<p><strong>在浏览器解析页面内容的时候，会发现页面引用了其他未加载的image、css文件、js文件等静态内容</strong></p>
<h4 id="网页静态资源加载"><a href="#网页静态资源加载" class="headerlink" title="网页静态资源加载"></a>网页静态资源加载</h4><p>什么是CDN？如果我在北京访问杭州的淘宝网，跨省的通信必然造成延迟。如果淘宝网能在北京建立一个服务器，静态资源我可以直接从就近的北京服务器获取，必然能提高整个网站的打开速度，这就是CDN。CDN叫内容分发网络，是依靠部署在各地的边缘服务器，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度</p>
<h3 id="B-树-和-B-树的区别，为什么-mysql-要用-B-树，mongodb-要用-B-树"><a href="#B-树-和-B-树的区别，为什么-mysql-要用-B-树，mongodb-要用-B-树" class="headerlink" title="B 树 和 B+ 树的区别，为什么 mysql 要用 B+ 树，mongodb 要用 B 树"></a><code>B</code> 树 和 <code>B+</code> 树的区别，为什么<code> mysql</code> 要用 <code>B+</code> 树，<code>mongodb</code> 要用 <code>B</code> 树</h3><ul>
<li>B+ 树中只有叶子节点会带有指向记录的指针，而 B 树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中</li>
<li>B+ 树中所有叶子节点都是通过指针连接在一起，而 B 树不会</li>
</ul>
<h3 id="redis-的跳表，为什么不用红黑树"><a href="#redis-的跳表，为什么不用红黑树" class="headerlink" title="redis 的跳表，为什么不用红黑树"></a><code>redis</code> 的跳表，为什么不用红黑树</h3><p>Redis只在两个地方用到了跳跃表，一个是实现有序集合键(zset)，另一个是在集群节点中用作内部数据结构，除此之外，跳表在Redis里面没有其他用途</p>
<ul>
<li>在做范围查找的时候，平衡树比跳表操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现</li>
<li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速</li>
<li>从内存占用上来说，跳表比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针, 分别指向左右子树，而跳表每个节点包含的指针数目平均为<code>1/(1-p)</code>，具体取决于参数<code>p</code>的大小。如果像Redis里的实现一样，取<code>p=1/4</code>，那么平均每个节点包含<code>1.33</code>个指针，比平衡树更有优势</li>
<li>查找单个key，跳表和平衡树的时间复杂度都为<code>O(logn)</code>，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近<code>O(1)</code>，性能更高一些。所以我们平常使用的各种Map或dict结构，大都是基于哈希表实现的</li>
<li>从算法实现难度上来比较，跳表比平衡树要简单得多</li>
</ul>
<h3 id="redis-集群是怎么实现的，说一下一致性-hash"><a href="#redis-集群是怎么实现的，说一下一致性-hash" class="headerlink" title="redis 集群是怎么实现的，说一下一致性 hash"></a><code>redis</code> 集群是怎么实现的，说一下一致性 <code>hash</code></h3><h3 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h3><h3 id="Mysql-集群如何保证数据的一致性"><a href="#Mysql-集群如何保证数据的一致性" class="headerlink" title="Mysql 集群如何保证数据的一致性"></a><code>Mysql</code> 集群如何保证数据的一致性</h3><h3 id="Mysql-集群在保证强一致性的情况下，如何保证高并发"><a href="#Mysql-集群在保证强一致性的情况下，如何保证高并发" class="headerlink" title="Mysql 集群在保证强一致性的情况下，如何保证高并发"></a><code>Mysql</code> 集群在保证强一致性的情况下，如何保证高并发</h3><h3 id="哪些操作会导致内存泄漏"><a href="#哪些操作会导致内存泄漏" class="headerlink" title="哪些操作会导致内存泄漏"></a>哪些操作会导致内存泄漏</h3><p>内存泄漏，就是不再需要的对象仍然存在内存中，内存泄漏不断堆积的后果就是内存溢出，即内存不够用。</p>
<p>垃圾回收机制会定期扫描对象，如果一个对象没有被其他对象引用，或两个对象互相引用但没有被第三个对象引用，则它们的内存会被回收</p>
<ol>
<li>单例造成的内存泄漏<br>由于单例的静态特性使得其生命周期和应用的生命周期一样长，如果一个对象已经不再需要使用了，而单例对象还持有该对象的引用，就会使得该对象不能被正常回收，从而导致了内存泄漏</li>
<li>10次内存泄露，有9次是<code>goroutine</code>泄露<br><code>goroutine</code>泄露的本质是<code>channel</code>阻塞，无法继续向下执行，导致此<code>goroutine</code>关联的内存都无法释放，进一步造成内存泄露</li>
</ol>
<h3 id="哪些操作会导致-io-开销大幅上升"><a href="#哪些操作会导致-io-开销大幅上升" class="headerlink" title="哪些操作会导致 io 开销大幅上升"></a>哪些操作会导致 <code>io</code> 开销大幅上升</h3><h3 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h3><p><strong>同步</strong>，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是处于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。整个处理过程顺序执行，当各个过程都执行完毕，并返回结果。是一种线性执行的方式，执行的流程不能跨越。一般用于流程性比较强的程序，比如用户登录，需要对用户验证完成后才能登录系统</p>
<p><strong>异步</strong>，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。异步只是发送了调用的指令，调用者无需等待被调用的方法完全执行完毕；而是继续执行下面的流程。是一种并行处理的方式，不必等待一个程序执行完，可以执行其它的任务，比如页面数据加载过程，不需要等所有数据获取后再显示页面</p>
<p>他们的区别就在于一个需要等待，一个不需要等待，在部分情况下，我们的项目开发中都会优先选择不需要等待的异步交互方式，比如日志记录就可以使用异步方式进行保存</p>
<p>如果<strong>同步</strong>是发起了一个调用后， 没有得到结果之前不返回， 那它毫无疑问就是被<strong>阻塞</strong>了，即调用进程处于 <code>waiting</code> 状态</p>
<p>如果<strong>异步</strong>调用发出了以后就直接返回了， 毫无疑问， 这个进程是<strong>非阻塞</strong>的</p>
<h3 id="怎么做一个自动化配置平台系统"><a href="#怎么做一个自动化配置平台系统" class="headerlink" title="怎么做一个自动化配置平台系统"></a>怎么做一个自动化配置平台系统</h3><h3 id="开发的流程规范是什么"><a href="#开发的流程规范是什么" class="headerlink" title="开发的流程规范是什么"></a>开发的流程规范是什么</h3><h3 id="线上-cpu-和内存突然飙高后应该怎么排错"><a href="#线上-cpu-和内存突然飙高后应该怎么排错" class="headerlink" title="线上 cpu 和内存突然飙高后应该怎么排错"></a>线上 <code>cpu</code> 和内存突然飙高后应该怎么排错</h3><h3 id="服务器受到攻击怎么定位服务器问题"><a href="#服务器受到攻击怎么定位服务器问题" class="headerlink" title="服务器受到攻击怎么定位服务器问题"></a>服务器受到攻击怎么定位服务器问题</h3><h3 id="rpc的具体实现"><a href="#rpc的具体实现" class="headerlink" title="rpc的具体实现"></a><code>rpc</code>的具体实现</h3><h3 id="设计一个海量日志写入系统"><a href="#设计一个海量日志写入系统" class="headerlink" title="设计一个海量日志写入系统"></a>设计一个海量日志写入系统</h3><h3 id="设计一个长链接转短链接，需要考虑高并发"><a href="#设计一个长链接转短链接，需要考虑高并发" class="headerlink" title="设计一个长链接转短链接，需要考虑高并发"></a>设计一个长链接转短链接，需要考虑高并发</h3><h3 id="设计一个微信朋友圈系统，列出主要的表结构，写出一些数据结构"><a href="#设计一个微信朋友圈系统，列出主要的表结构，写出一些数据结构" class="headerlink" title="设计一个微信朋友圈系统，列出主要的表结构，写出一些数据结构"></a>设计一个微信朋友圈系统，列出主要的表结构，写出一些数据结构</h3><h3 id="设计一个海量的评论系统"><a href="#设计一个海量的评论系统" class="headerlink" title="设计一个海量的评论系统"></a>设计一个海量的评论系统</h3><h3 id="使用过的中间件"><a href="#使用过的中间件" class="headerlink" title="使用过的中间件"></a>使用过的中间件</h3><h3 id="唯一订单号生成的算法问题"><a href="#唯一订单号生成的算法问题" class="headerlink" title="唯一订单号生成的算法问题"></a>唯一订单号生成的算法问题</h3><h3 id="mysql高可用的方案"><a href="#mysql高可用的方案" class="headerlink" title="mysql高可用的方案"></a><code>mysql</code>高可用的方案</h3><h3 id="服务发现怎么实现的"><a href="#服务发现怎么实现的" class="headerlink" title="服务发现怎么实现的"></a>服务发现怎么实现的</h3><h3 id="如何保证服务宕机造成的分布式服务节点处理问题"><a href="#如何保证服务宕机造成的分布式服务节点处理问题" class="headerlink" title="如何保证服务宕机造成的分布式服务节点处理问题"></a>如何保证服务宕机造成的分布式服务节点处理问题</h3><h3 id="高可用软件是什么"><a href="#高可用软件是什么" class="headerlink" title="高可用软件是什么"></a>高可用软件是什么</h3><h3 id="怎么设计orm，你会怎么写"><a href="#怎么设计orm，你会怎么写" class="headerlink" title="怎么设计orm，你会怎么写"></a>怎么设计<code>orm</code>，你会怎么写</h3><h3 id="怎么设计一个并发服务程序"><a href="#怎么设计一个并发服务程序" class="headerlink" title="怎么设计一个并发服务程序"></a>怎么设计一个并发服务程序</h3><h3 id="设计一个web框架，要怎么设计"><a href="#设计一个web框架，要怎么设计" class="headerlink" title="设计一个web框架，要怎么设计"></a>设计一个web框架，要怎么设计</h3><h3 id="实现消息队列-多生产者，多消费者"><a href="#实现消息队列-多生产者，多消费者" class="headerlink" title="实现消息队列. 多生产者，多消费者"></a>实现消息队列. 多生产者，多消费者</h3><h3 id="怎么做弹性扩缩容，原理是什么"><a href="#怎么做弹性扩缩容，原理是什么" class="headerlink" title="怎么做弹性扩缩容，原理是什么"></a>怎么做弹性扩缩容，原理是什么</h3><h3 id="解释一下中间件原理"><a href="#解释一下中间件原理" class="headerlink" title="解释一下中间件原理"></a>解释一下中间件原理</h3><h3 id="各个系统出问题怎么监控报警"><a href="#各个系统出问题怎么监控报警" class="headerlink" title="各个系统出问题怎么监控报警"></a>各个系统出问题怎么监控报警</h3><h3 id="微服务架构是什么样的"><a href="#微服务架构是什么样的" class="headerlink" title="微服务架构是什么样的"></a>微服务架构是什么样的</h3><h3 id="负载均衡原理是什么"><a href="#负载均衡原理是什么" class="headerlink" title="负载均衡原理是什么"></a>负载均衡原理是什么</h3><h3 id="分布式锁的实现原理"><a href="#分布式锁的实现原理" class="headerlink" title="分布式锁的实现原理"></a>分布式锁的实现原理</h3><h3 id="Mysql高可用方案有哪些"><a href="#Mysql高可用方案有哪些" class="headerlink" title="Mysql高可用方案有哪些"></a><code>Mysql</code>高可用方案有哪些</h3><hr>
<ul>
<li>数据库和网络一定要重点复习</li>
<li>语言主要还是平时的积累，多看源码，要知道对应语言的一些特性和比较常用或者有特色的标准库</li>
<li>数据库最重要的肯定是 <code>Mysql</code>，<code>Mysql</code>中比较重要的就是隔离级别和索引，一定一定要弄懂。然后就是 <code>redis</code></li>
<li>中间件这个也是必问的一个环节，尽量要多了解一些，但是一定要说自己会的，至少知道运行原理和特点。比较重要的中间件有：<code>memcache</code>、<code>kafka</code></li>
<li>架构设计有实战最好，没有实战多学习一些开源的架构，尤其是日志系统、评论系统、聊天室相关的内容</li>
<li>好好准备一个有亮点的项目，很多面试官喜欢让你说一个印象最深的项目，这时候就是你的表演时刻了</li>
<li>分布式、Docker、微服务也是经常会问的东西，也要好好准备</li>
<li>最重要的算法, 能刷多少刷多少，主要是学方法</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/06/08/go-interview/" rel="prev" title="Golang 编程面试问题总结">
                  <i class="fa fa-chevron-left"></i> Golang 编程面试问题总结
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/09/12/linux-interview/" rel="next" title="Linux 常见面试问题总结">
                  Linux 常见面试问题总结 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ifcalm</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">157k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:23</span>
  </span>
</div>





<!-- 网站运行时间的设置 -->

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
