<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="在软体架构和程序设计领域，前端是软体系统中直接和用户交互的部分，而后端控制着软件的输出的编程语言">
<meta property="og:type" content="article">
<meta property="og:title" content="后端通用面试问题总结">
<meta property="og:url" content="http://example.com/2020/07/12/backend-interview/index.html">
<meta property="og:site_name" content="缘起">
<meta property="og:description" content="在软体架构和程序设计领域，前端是软体系统中直接和用户交互的部分，而后端控制着软件的输出的编程语言">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-07-12T07:57:02.000Z">
<meta property="article:modified_time" content="2021-02-22T14:59:05.620Z">
<meta property="article:author" content="ifcalm">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2020/07/12/backend-interview/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>后端通用面试问题总结 | 缘起</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">缘起</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">种瓜的瓜, 种豆得豆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">协程，线程，进程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%8C%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%8C%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="nav-number">2.</span> <span class="nav-text">互斥锁，读写锁，死锁问题是怎么解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-%E5%8E%9F%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">epoll 原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O"><span class="nav-number">3.1.</span> <span class="nav-text">I&#x2F;O</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">3.2.</span> <span class="nav-text">事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">3.3.</span> <span class="nav-text">通知机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll%E6%9C%BA%E5%88%B6"><span class="nav-number">3.4.</span> <span class="nav-text">epoll机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll-API"><span class="nav-number">3.5.</span> <span class="nav-text">epoll API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll-%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="nav-number">3.6.</span> <span class="nav-text">epoll 的两种触发方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">IO 多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">5.</span> <span class="nav-text">并发编程概念是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">6.</span> <span class="nav-text">什么是线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LVS-%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BA%86%E8%A7%A3"><span class="nav-number">7.</span> <span class="nav-text">LVS 的相关了解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">8.</span> <span class="nav-text">Redis的数据类型有哪些，以及应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String"><span class="nav-number">8.1.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List"><span class="nav-number">8.2.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hash"><span class="nav-number">8.3.</span> <span class="nav-text">Hash</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set"><span class="nav-number">8.4.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sorted-Set"><span class="nav-number">8.5.</span> <span class="nav-text">Sorted Set</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">9.</span> <span class="nav-text">异步和非阻塞的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="nav-number">10.</span> <span class="nav-text">滑动窗口的概念以及应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E5%A4%A7%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%8C%E8%AE%A9%E5%85%B6%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E6%83%B3%E5%8A%A0%E7%AD%89%E4%BA%8E1000%E6%80%8E%E4%B9%88%E7%AE%97"><span class="nav-number">11.</span> <span class="nav-text">一个非常大的数组，让其中两个数想加等于1000怎么算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%EF%BC%8C%E6%96%B9%E6%B3%95"><span class="nav-number">12.</span> <span class="nav-text">常用测试工具，压测工具，方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%80%8E%E4%B9%88%E6%B5%8B%E8%AF%95%EF%BC%8C%E6%AF%94%E5%A6%82%E6%9C%89%E5%A4%96%E9%83%A8%E6%8E%A5%E5%8F%A3mysql%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">13.</span> <span class="nav-text">复杂的单元测试怎么测试，比如有外部接口mysql接口的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis%E9%9B%86%E7%BE%A4%EF%BC%8C%E5%93%A8%E5%85%B5%EF%BC%8C%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E4%BA%8B%E5%8A%A1"><span class="nav-number">14.</span> <span class="nav-text">redis集群，哨兵，持久化，事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql%E5%92%8Credis%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">15.</span> <span class="nav-text">mysql和redis区别是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFredis%E7%BC%93%E5%AD%98%E5%88%B0mysql"><span class="nav-number">15.1.</span> <span class="nav-text">什么是redis缓存到mysql</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><span class="nav-number">15.2.</span> <span class="nav-text">其他缓存策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql%E4%BA%8B%E5%8A%A1"><span class="nav-number">16.</span> <span class="nav-text">mysql事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">16.1.</span> <span class="nav-text">并发事务带来的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">16.2.</span> <span class="nav-text">并发事务的解决办法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97"><span class="nav-number">16.3.</span> <span class="nav-text">事务日志</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#grpc%E9%81%B5%E5%BE%AA%E4%BB%80%E4%B9%88%E5%8D%8F%E8%AE%AE"><span class="nav-number">17.</span> <span class="nav-text">grpc遵循什么协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#grpc%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">18.</span> <span class="nav-text">grpc内部原理是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http2%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%8Ehttp1-1%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">19.</span> <span class="nav-text">http2的特点是什么，与http1.1的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#client%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="nav-number">20.</span> <span class="nav-text">client如何实现长连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">21.</span> <span class="nav-text">大文件排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E7%A8%B3%E5%AE%9A%E7%9A%84"><span class="nav-number">22.</span> <span class="nav-text">基本排序，哪些是稳定的</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%B3%E5%AE%9A%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">22.1.</span> <span class="nav-text">稳定的排序算法:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F"><span class="nav-number">22.2.</span> <span class="nav-text">不稳定排序:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Http-get%E4%B8%8Ehead"><span class="nav-number">23.</span> <span class="nav-text">Http get与head</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Http-401-403"><span class="nav-number">24.</span> <span class="nav-text">Http 401,403</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Http-keep-alive"><span class="nav-number">25.</span> <span class="nav-text">Http keep-alive</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E7%94%A8Keep-Alive%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">25.1.</span> <span class="nav-text">启用Keep-Alive的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%B6%88%E6%81%AF%E5%86%85%E5%AE%B9%E9%95%BF%E5%BA%A6%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">25.2.</span> <span class="nav-text">如何判断消息内容长度的大小</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Http%E8%83%BD%E4%B8%8D%E8%83%BD%E4%B8%80%E6%AC%A1%E8%BF%9E%E6%8E%A5%E5%A4%9A%E6%AC%A1%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%8D%E7%AD%89%E5%90%8E%E7%AB%AF%E8%BF%94%E5%9B%9E"><span class="nav-number">26.</span> <span class="nav-text">Http能不能一次连接多次请求，不等后端返回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E5%92%8C-UDP-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">27.</span> <span class="nav-text">TCP 和 UDP 有什么区别,适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#time-wait%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">28.</span> <span class="nav-text">time-wait的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">29.</span> <span class="nav-text">数据库如何建索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">30.</span> <span class="nav-text">孤儿进程，僵尸进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%9D%A1%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D"><span class="nav-number">31.</span> <span class="nav-text">死锁条件，如何避免</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux%E5%91%BD%E4%BB%A4%EF%BC%8C%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%EF%BC%8Ccpu%E8%B4%9F%E8%BD%BD%EF%BC%8C%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7%E7%BB%99%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="nav-number">32.</span> <span class="nav-text">linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git%E6%96%87%E4%BB%B6%E7%89%88%E6%9C%AC%EF%BC%8C%E4%BD%BF%E7%94%A8%E9%A1%BA%E5%BA%8F%EF%BC%8Cmerge%E8%B7%9Frebase"><span class="nav-number">33.</span> <span class="nav-text">git文件版本，使用顺序，merge跟rebase</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E4%BC%9A%E7%94%A8%E5%88%B0%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">34.</span> <span class="nav-text">一般会用到哪些数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84%E7%9B%B8%E6%AF%94-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">35.</span> <span class="nav-text">链表和数组相比, 有什么优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%97%A0%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BA%A4%E5%8F%89%E7%82%B9"><span class="nav-number">36.</span> <span class="nav-text">如何判断两个无环单链表有没有交叉点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E6%9C%89%E6%B2%A1%E6%9C%89%E7%8E%AF-%E5%B9%B6%E6%89%BE%E5%87%BA%E5%85%A5%E7%8E%AF%E7%82%B9"><span class="nav-number">37.</span> <span class="nav-text">如何判断一个单链表有没有环, 并找出入环点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B-TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD"><span class="nav-number">38.</span> <span class="nav-text">描述一下 TCP 四次挥手的过程中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81"><span class="nav-number">39.</span> <span class="nav-text">TCP 有哪些状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E7%9A%84-LISTEN-%E7%8A%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">40.</span> <span class="nav-text">TCP 的 LISTEN 状态是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E7%9A%84-CLOSE-WAIT-%E7%8A%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">41.</span> <span class="nav-text">TCP 的 CLOSE_WAIT 状态是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA-socket-%E8%BF%9E%E6%8E%A5%E8%A6%81%E7%BB%8F%E8%BF%87%E5%93%AA%E4%BA%9B%E6%AD%A5%E9%AA%A4"><span class="nav-number">42.</span> <span class="nav-text">建立一个 socket 连接要经过哪些步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84-HTTP-%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">43.</span> <span class="nav-text">常见的 HTTP 状态码有哪些</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E7%B1%BB"><span class="nav-number">43.1.</span> <span class="nav-text">HTTP状态码分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#301%E5%92%8C302%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">44.</span> <span class="nav-text">301和302有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#504%E5%92%8C500%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">45.</span> <span class="nav-text">504和500有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS-%E5%92%8C-HTTP-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">46.</span> <span class="nav-text">HTTPS 和 HTTP 有什么区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-%E4%B8%8E-HTTPS-%E5%8C%BA%E5%88%AB"><span class="nav-number">46.1.</span> <span class="nav-text">HTTP 与 HTTPS 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">46.2.</span> <span class="nav-text">TCP 三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">46.3.</span> <span class="nav-text">HTTPS 的工作原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">47.</span> <span class="nav-text">手写一个快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">48.</span> <span class="nav-text">配置中心如何保证一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E9%87%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%86%9F%E6%82%89%E5%90%97"><span class="nav-number">49.</span> <span class="nav-text">Redis 里数据结构的实现熟悉吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SLB%E5%8E%9F%E7%90%86"><span class="nav-number">50.</span> <span class="nav-text">SLB原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E5%88%99"><span class="nav-number">51.</span> <span class="nav-text">分布式一致性原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-%E2%80%93-gt-C"><span class="nav-number">52.</span> <span class="nav-text">智能指针 –&gt; C++</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%92%8C%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="nav-number">53.</span> <span class="nav-text">唯一索引和主键索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp%E7%B2%98%E5%8C%85"><span class="nav-number">54.</span> <span class="nav-text">tcp粘包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83"><span class="nav-number">55.</span> <span class="nav-text">进程虚拟空间分布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E5%92%8C-go-%E5%92%8C-java-%E5%AF%B9%E6%AF%94"><span class="nav-number">56.</span> <span class="nav-text">c++ 和 go 和 java 对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="nav-number">57.</span> <span class="nav-text">堆的时间复杂度，稳定性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">58.</span> <span class="nav-text">几种基本排序算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#top-K-%E9%97%AE%E9%A2%98"><span class="nav-number">59.</span> <span class="nav-text">top-K 问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%BB%E9%94%AE"><span class="nav-number">60.</span> <span class="nav-text">什么是主键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="nav-number">61.</span> <span class="nav-text">联合索引和唯一索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%8A%E5%A4%9A%E7%9A%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E5%A5%BD%E5%90%97"><span class="nav-number">62.</span> <span class="nav-text">越多的索引越好吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88"><span class="nav-number">63.</span> <span class="nav-text">建立索引要注意什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">64.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">65.</span> <span class="nav-text">tcp三次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http%E4%B8%8Ehttps"><span class="nav-number">66.</span> <span class="nav-text">http与https</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">67.</span> <span class="nav-text">数据库隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cookie%E4%B8%8Esession"><span class="nav-number">68.</span> <span class="nav-text">cookie与session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-%E5%92%8C-epoll"><span class="nav-number">69.</span> <span class="nav-text">select 和 epoll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">70.</span> <span class="nav-text">TCP 拥塞控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mysql-%E7%94%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">71.</span> <span class="nav-text">Mysql 用的是什么数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kafka-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">72.</span> <span class="nav-text">kafka 的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B-HTTPS-%E7%9A%84%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B%EF%BC%8C%E9%9C%80%E8%A6%81%E5%87%A0%E6%AC%A1%E9%80%9A%E4%BF%A1"><span class="nav-number">73.</span> <span class="nav-text">详细描述一下 HTTPS 的加密过程，需要几次通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%8C%E8%AF%B4%E4%B8%80%E4%B8%8B-time-wait"><span class="nav-number">74.</span> <span class="nav-text">三次握手和四次挥手，说一下 time_wait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mysql-%E7%9A%84%E5%B9%BB%E8%AF%BB%E6%98%AF%E6%80%8E%E4%B9%88%E4%B8%AA%E6%83%85%E5%86%B5%EF%BC%8CMysql-%E6%98%AF%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%9A%84"><span class="nav-number">75.</span> <span class="nav-text">Mysql 的幻读是怎么个情况，Mysql 是如何避免的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">76.</span> <span class="nav-text">自旋锁和互斥锁有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">77.</span> <span class="nav-text">用过哪些分布式锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-setnx-expire-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="nav-number">78.</span> <span class="nav-text">redis setnx + expire 有什么缺点，如何优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA-URL-%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">79.</span> <span class="nav-text">打开一个 URL 的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E6%A0%91-%E5%92%8C-B-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88-mysql-%E8%A6%81%E7%94%A8-B-%E6%A0%91%EF%BC%8Cmongodb-%E8%A6%81%E7%94%A8-B-%E6%A0%91"><span class="nav-number">80.</span> <span class="nav-text">B 树 和 B+ 树的区别，为什么 mysql 要用 B+ 树，mongodb 要用 B 树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-%E7%9A%84%E8%B7%B3%E8%A1%A8%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">81.</span> <span class="nav-text">redis 的跳表，为什么不用红黑树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-%E9%9B%86%E7%BE%A4%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%B8%80%E8%87%B4%E6%80%A7-hash"><span class="nav-number">82.</span> <span class="nav-text">redis 集群是怎么实现的，说一下一致性 hash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="nav-number">83.</span> <span class="nav-text">进程的调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mysql-%E9%9B%86%E7%BE%A4%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">84.</span> <span class="nav-text">Mysql 集群如何保证数据的一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mysql-%E9%9B%86%E7%BE%A4%E5%9C%A8%E4%BF%9D%E8%AF%81%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="nav-number">85.</span> <span class="nav-text">Mysql 集群在保证强一致性的情况下，如何保证高并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">86.</span> <span class="nav-text">哪些操作会导致内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E5%AF%BC%E8%87%B4-io-%E5%BC%80%E9%94%80%E5%A4%A7%E5%B9%85%E4%B8%8A%E5%8D%87"><span class="nav-number">87.</span> <span class="nav-text">哪些操作会导致 io 开销大幅上升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5"><span class="nav-number">88.</span> <span class="nav-text">异步和同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%81%9A%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E9%85%8D%E7%BD%AE%E5%B9%B3%E5%8F%B0%E7%B3%BB%E7%BB%9F"><span class="nav-number">89.</span> <span class="nav-text">怎么做一个自动化配置平台系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E7%9A%84%E6%B5%81%E7%A8%8B%E8%A7%84%E8%8C%83%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">90.</span> <span class="nav-text">开发的流程规范是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E4%B8%8A-cpu-%E5%92%8C%E5%86%85%E5%AD%98%E7%AA%81%E7%84%B6%E9%A3%99%E9%AB%98%E5%90%8E%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E6%8E%92%E9%94%99"><span class="nav-number">91.</span> <span class="nav-text">线上 cpu 和内存突然飙高后应该怎么排错</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%97%E5%88%B0%E6%94%BB%E5%87%BB%E6%80%8E%E4%B9%88%E5%AE%9A%E4%BD%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%AE%E9%A2%98"><span class="nav-number">92.</span> <span class="nav-text">服务器受到攻击怎么定位服务器问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rpc%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">93.</span> <span class="nav-text">rpc的具体实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%B5%B7%E9%87%8F%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5%E7%B3%BB%E7%BB%9F"><span class="nav-number">94.</span> <span class="nav-text">设计一个海量日志写入系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%95%BF%E9%93%BE%E6%8E%A5%E8%BD%AC%E7%9F%AD%E9%93%BE%E6%8E%A5%EF%BC%8C%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="nav-number">95.</span> <span class="nav-text">设计一个长链接转短链接，需要考虑高并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%BE%AE%E4%BF%A1%E6%9C%8B%E5%8F%8B%E5%9C%88%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%88%97%E5%87%BA%E4%B8%BB%E8%A6%81%E7%9A%84%E8%A1%A8%E7%BB%93%E6%9E%84%EF%BC%8C%E5%86%99%E5%87%BA%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">96.</span> <span class="nav-text">设计一个微信朋友圈系统，列出主要的表结构，写出一些数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%B5%B7%E9%87%8F%E7%9A%84%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F"><span class="nav-number">97.</span> <span class="nav-text">设计一个海量的评论系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%87%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">98.</span> <span class="nav-text">使用过的中间件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E8%AE%A2%E5%8D%95%E5%8F%B7%E7%94%9F%E6%88%90%E7%9A%84%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98"><span class="nav-number">99.</span> <span class="nav-text">唯一订单号生成的算法问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E6%96%B9%E6%A1%88"><span class="nav-number">100.</span> <span class="nav-text">mysql高可用的方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">101.</span> <span class="nav-text">服务发现怎么实现的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E5%AE%95%E6%9C%BA%E9%80%A0%E6%88%90%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98"><span class="nav-number">102.</span> <span class="nav-text">如何保证服务宕机造成的分布式服务节点处理问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">103.</span> <span class="nav-text">高可用软件是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1orm%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%86%99"><span class="nav-number">104.</span> <span class="nav-text">怎么设计orm，你会怎么写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F"><span class="nav-number">105.</span> <span class="nav-text">怎么设计一个并发服务程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AAweb%E6%A1%86%E6%9E%B6%EF%BC%8C%E8%A6%81%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1"><span class="nav-number">106.</span> <span class="nav-text">设计一个web框架，要怎么设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%8C%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-number">107.</span> <span class="nav-text">实现消息队列. 多生产者，多消费者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%81%9A%E5%BC%B9%E6%80%A7%E6%89%A9%E7%BC%A9%E5%AE%B9%EF%BC%8C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">108.</span> <span class="nav-text">怎么做弹性扩缩容，原理是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86"><span class="nav-number">109.</span> <span class="nav-text">解释一下中间件原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%84%E4%B8%AA%E7%B3%BB%E7%BB%9F%E5%87%BA%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6"><span class="nav-number">110.</span> <span class="nav-text">各个系统出问题怎么监控报警</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="nav-number">111.</span> <span class="nav-text">微服务架构是什么样的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">112.</span> <span class="nav-text">负载均衡原理是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">113.</span> <span class="nav-text">分布式锁的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mysql%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">114.</span> <span class="nav-text">Mysql高可用方案有哪些</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ifcalm</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/12/backend-interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ifcalm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘起">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          后端通用面试问题总结
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-12 15:57:02" itemprop="dateCreated datePublished" datetime="2020-07-12T15:57:02+08:00">2020-07-12</time>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

            <div class="post-description">在软体架构和程序设计领域，前端是软体系统中直接和用户交互的部分，而后端控制着软件的输出的编程语言</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h3 id="协程，线程，进程的区别"><a href="#协程，线程，进程的区别" class="headerlink" title="协程，线程，进程的区别"></a>协程，线程，进程的区别</h3><p>进程、线程、协程是为了满足用户的多任务任务需求。比如一边写代码一边听音乐</p>
<p>单核的 CPU 一次只能执行一个任务，想要实现多任务，需要把 CPU 的运行时间切成一段一段的时间片，每个时间片运行一个程序，循环的分配时间片给不同的应用程序</p>
<p>由于时间片非常的短，在用户看来，就像是多个任务同时在运行</p>
<p>进程、线程、协程就是计算机表示任务的方式, 它们被统称为<strong>执行体</strong></p>
<p>进程、线程、协程的区别主要体现在执行体的颗粒度上。最初的执行体任务比较简单，用一个进程就能满足需求，随着执行体做的事情越来越复杂，就出现了进程内多任务的需求</p>
<p>进程内的执行体，被称为线程，它作为进程的子执行体，创建和运行成本小很多。线程是执行任务的最小单元，每个线程具有独立的栈空间，并共享堆空间</p>
<p>进程和线程都属于系统级的任务，切换进程、线程都需要经历用户态跃迁内核态，切换成功后再由内核态切回用户态</p>
<p>协程是比线程颗粒度更细小的任务，允许切换线程的最小单元是函数(方法），而切换协程可以在任何一行代码</p>
<h3 id="互斥锁，读写锁，死锁问题是怎么解决"><a href="#互斥锁，读写锁，死锁问题是怎么解决" class="headerlink" title="互斥锁，读写锁，死锁问题是怎么解决"></a>互斥锁，读写锁，死锁问题是怎么解决</h3><h3 id="epoll-原理"><a href="#epoll-原理" class="headerlink" title="epoll 原理"></a><code>epoll</code> 原理</h3><p><code>epoll</code>是一种I/O事件通知机制，是linux 内核实现<strong>IO多路复用</strong>的一个实现</p>
<p><strong>IO多路复用</strong>是指，在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作</p>
<h4 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h4><p>输入输出(input/output)的对象可以是文件(file)， 网络(socket)，进程之间的管道(pipe)。在linux系统中，都用文件描述符(fd)来表示</p>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><ul>
<li>可读事件，当文件描述符关联的内核读缓冲区可读，则触发可读事件。可读：内核缓冲区非空，有数据可以读取</li>
<li>可写事件，当文件描述符关联的内核写缓冲区可写，则触发可写事件。可写：内核缓冲区不满，有空闲空间可以写入</li>
</ul>
<h4 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h4><p>通知机制，就是当事件发生的时候，则主动通知。通知机制的反面，就是轮询机制</p>
<h4 id="epoll机制"><a href="#epoll机制" class="headerlink" title="epoll机制"></a>epoll机制</h4><p><code>epoll</code>是一种当文件描述符的内核缓冲区非空的时候，发出可读信号进行通知，当写缓冲区不满的时候，发出可写信号通知的机制</p>
<h4 id="epoll-API"><a href="#epoll-API" class="headerlink" title="epoll API"></a>epoll API</h4><p><code>epoll</code>的核心是3个API，核心数据结构是: 1个红黑树和1个链表</p>
<ul>
<li><code>int epoll_create(int size)</code>, 内核会产生一个epoll 实例数据结构并返回一个文件描述符，这个特殊的描述符就是epoll实例的句柄，后面的两个接口都以它为中心</li>
<li><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code>, 将被监听的描述符添加到红黑树或从红黑树中删除或者对监听事件进行修改</li>
<li><code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</code>, 阻塞等待注册的事件发生，返回事件的数目，并将触发的事件写入<code>events</code>数组中</li>
</ul>
<h4 id="epoll-的两种触发方式"><a href="#epoll-的两种触发方式" class="headerlink" title="epoll 的两种触发方式"></a>epoll 的两种触发方式</h4><p><code>epoll</code>监控多个文件描述符的I/O事件。<code>epoll</code>支持边缘触发(edge trigger, ET)或水平触发(level trigger, LT)，通过<code>epoll_wait</code>等待I/O事件，如果当前没有可用的事件则阻塞调用线程</p>
<p><strong><code>select</code>和<code>poll</code>只支持LT工作模式，<code>epoll</code>的默认的工作模式是LT模式</strong></p>
<ol>
<li>水平触发</li>
<li>边缘触发</li>
</ol>
<h3 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h3><p>假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择:</p>
<ul>
<li>按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡主，全班都会被耽误</li>
<li>你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接</li>
<li>你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A, <strong>这种就是IO复用模型</strong>，Linux下的<code>select</code>、<code>poll</code>和<code>epoll</code>就是干这个的。将用户<code>socket</code>对应的fd注册进<code>epoll</code>，然后<code>epoll</code>帮你监听哪些<code>socket</code>上有消息到达，这样就避免了大量的无用操作</li>
</ul>
<p>这样，整个过程只在调用<code>select、poll、epoll</code>这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是<strong>事件驱动</strong>，所谓的<strong>reactor模式</strong></p>
<h3 id="并发编程概念是什么"><a href="#并发编程概念是什么" class="headerlink" title="并发编程概念是什么"></a>并发编程概念是什么</h3><h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><p>线程安全是程式设计中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成</p>
<p>线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。 不会出现数据不一致或者数据污染。 线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</p>
<h3 id="LVS-的相关了解"><a href="#LVS-的相关了解" class="headerlink" title="LVS 的相关了解"></a>LVS 的相关了解</h3><p><code>LVS</code>，全称Linux Virtual Server，是国人章文嵩发起的一个开源项目。在社区具有很大的热度，是一个基于四层、具有强大性能的反向代理服务器</p>
<h3 id="Redis的数据类型有哪些，以及应用场景"><a href="#Redis的数据类型有哪些，以及应用场景" class="headerlink" title="Redis的数据类型有哪些，以及应用场景"></a><code>Redis</code>的数据类型有哪些，以及应用场景</h3><p>Redis目前支持5种数据类型，分别是:</p>
<ul>
<li>String, 字符串</li>
<li>List, 列表</li>
<li>Hash, 字典</li>
<li>Set, 集合</li>
<li>Sorted Set, 有序集合</li>
</ul>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>String是简单的 key-value 键值对，value 不仅可以是 String，也可以是数字。String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到<code>incr,decr</code>等操作时会转成数值型进行计算，此时redisObject的encoding字段为int</p>
<p><em>应用场景:</em></p>
<p>String是最常用的一种数据类型，普通的<code>key/value</code>存储都可以归为此类</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>edis列表是简单的字符串列表，是一个链表或者说是一个队列。可以从头部或尾部向Redis列表添加元素。列表的最大长度为<code>2^32 - 1</code>，也即每个列表支持超过40亿个元素</p>
<p>Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构</p>
<p><em>应用场景:</em></p>
<p>Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表、粉丝列表等都可以用Redis的list结构来实现，再比如有的应用使用Redis的list类型实现一个简单的轻量级消息队列，生产者push，消费者pop/bpop</p>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>待补充</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>一个值不重复的列表，类似数学领域中的集合概念，且Redis也提供了针对集合的求交集、并集、差集等操作。</p>
<p>set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因</p>
<p><em>应用场景:</em></p>
<p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的</p>
<h4 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h4><p>Redis有序集合类似Redis集合，不同的是增加了一个功能，即集合是有序的。一个有序集合的每个成员带有分数，用于进行排序</p>
<p>Redis有序集合添加、删除和测试的时间复杂度均为<code>O(1)</code></p>
<p>Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单</p>
<p><em>应用场景:</em></p>
<p>Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的 public timeline 可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。</p>
<p>又比如用户的积分排行榜需求就可以通过有序集合实现。还有上面介绍的使用List实现轻量级的消息队列，其实也可以通过Sorted Set实现有优先级或按权重的队列</p>
<h3 id="异步和非阻塞的区别"><a href="#异步和非阻塞的区别" class="headerlink" title="异步和非阻塞的区别"></a>异步和非阻塞的区别</h3><p>异步，调用在发出之后，这个调用就直接返回，不管有无结果. 异步是过程</p>
<p>非阻塞, 关注的是程序在等待调用结果时的状态，指在不能立刻得到结果之前，该调用不会阻塞当前线程</p>
<h3 id="滑动窗口的概念以及应用"><a href="#滑动窗口的概念以及应用" class="headerlink" title="滑动窗口的概念以及应用"></a>滑动窗口的概念以及应用</h3><p>滑动窗口协议是用来改善吞吐量的一种技术，即容许发送方在接收任何应答之前传送附加的包。 接收方告诉发送方在某一时刻能送多少包（称窗口尺寸）。 TCP中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据</p>
<h3 id="一个非常大的数组，让其中两个数想加等于1000怎么算"><a href="#一个非常大的数组，让其中两个数想加等于1000怎么算" class="headerlink" title="一个非常大的数组，让其中两个数想加等于1000怎么算"></a>一个非常大的数组，让其中两个数想加等于1000怎么算</h3><h3 id="常用测试工具，压测工具，方法"><a href="#常用测试工具，压测工具，方法" class="headerlink" title="常用测试工具，压测工具，方法"></a>常用测试工具，压测工具，方法</h3><h3 id="复杂的单元测试怎么测试，比如有外部接口mysql接口的情况"><a href="#复杂的单元测试怎么测试，比如有外部接口mysql接口的情况" class="headerlink" title="复杂的单元测试怎么测试，比如有外部接口mysql接口的情况"></a>复杂的单元测试怎么测试，比如有外部接口mysql接口的情况</h3><h3 id="redis集群，哨兵，持久化，事务"><a href="#redis集群，哨兵，持久化，事务" class="headerlink" title="redis集群，哨兵，持久化，事务"></a>redis集群，哨兵，持久化，事务</h3><h3 id="mysql和redis区别是什么"><a href="#mysql和redis区别是什么" class="headerlink" title="mysql和redis区别是什么"></a><code>mysql</code>和<code>redis</code>区别是什么</h3><p>Redis基于内存，是一个大的 map 结构，读写速度快，也可做持久化，但是内存空间有限，当数据量超过内存空间时，需扩充内存，但内存价格贵</p>
<p>MySQL基于磁盘，读写速度没有Redis快，但是不受空间容量限制，性价比高。</p>
<p>大多数的应用场景是MySQL（主）+Redis（辅），MySQL做为主存储，Redis用于缓存，加快访问速度。需要高性能的地方使用Redis，不需要高性能的地方使用MySQL。存储数据在MySQL和Redis之间做同步</p>
<h4 id="什么是redis缓存到mysql"><a href="#什么是redis缓存到mysql" class="headerlink" title="什么是redis缓存到mysql"></a>什么是redis缓存到mysql</h4><p>Redis其实就是说把表中经常访问的记录放在了Redis中，然后用户查询时先去查询Redis再去查询MySQL，确实实现了读写分离，也就是Redis只做读操作。由于缓存在内存中，所以查询会很快。对于一个sql语句格式的数据请求，首先计算该语句的MD5并据此得到结果集标识符，然后利用该标识符在Redis中查找该结果集。注意，结果集中的每一行都有一个相应的键，这些键都存储在一个Redis集合结构中。如果Redis中不存在这样一个集合，说明要找的结果集不在Redis中，所以需要执行相应的sql语句，在Mysql中查询到相应的结果集，然后按照上面所说的办法把结果集中的每一行以字符串或哈希的形式存入Redis</p>
<h4 id="其他缓存策略"><a href="#其他缓存策略" class="headerlink" title="其他缓存策略"></a>其他缓存策略</h4><p>MemCached数据结构单一，仅用来缓存数据，而Redis支持更加丰富的数据类型，也可以在服务器端直接对数据进行丰富的操作,这样可以减少网络IO次数和数据体积</p>
<p>MemCached不支持数据持久化，断电或重启后数据消失，但其稳定性是有保证的。Redis支持数据持久化和数据恢复，允许单点故障，但是同时也会付出性能的代价</p>
<h3 id="mysql事务"><a href="#mysql事务" class="headerlink" title="mysql事务"></a><code>mysql</code>事务</h3><p><code>MySQL</code> 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务</p>
<ul>
<li>在 <code>MySQL</code> 中只有使用了 <code>Innodb</code> 数据库引擎的数据库或表才支持事务</li>
<li>事务处理可以用来维护数据库的完整性，保证成批的 <code>SQL</code> 语句要么全部执行，要么全部不执行</li>
<li>事务用来管理 <code>insert</code>,<code>update</code>,<code>delete</code> 语句</li>
</ul>
<p>一般来说，事务是必须满足4个条件【ACID】：原子性、一致性、隔离性又称独立性、持久性</p>
<ul>
<li>原子性: 一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样</li>
<li>一致性: 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作</li>
<li>隔离性: 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交、读提交、可重复读和串行化</li>
<li>持久性: 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失</li>
</ul>
<p>MYSQL 事务处理主要有两种方法:</p>
<ol>
<li>用 <code>BEGIN</code>, <code>ROLLBACK</code>, <code>COMMIT</code>来实现<ul>
<li><code>BEGIN</code> 开始一个事务</li>
<li><code>ROLLBACK</code> 事务回滚</li>
<li><code>COMMIT</code> 事务确认</li>
</ul>
</li>
<li>直接用 <code>SET</code> 来改变 MySQL 的自动提交模式<ul>
<li><code>SET AUTOCOMMIT=0</code> 禁止自动提交</li>
<li><code>SET AUTOCOMMIT=1</code> 开启自动提交</li>
</ul>
</li>
</ol>
<h4 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h4><ul>
<li>更新丢失: 当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题, 后的更新覆盖了由其他事务所做的更新</li>
<li>脏读: 一个事务正在对一条记录做修改，在这个事务完成并提交前， 这条记录的数据就处于不一致状态； 这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些脏数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做<strong>脏读</strong></li>
<li>不可重复读: 一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了, 这种现象就叫做不可重复读</li>
<li>幻读: 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读</li>
</ul>
<p>不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样,因为中间有其他事务提交了修改</p>
<p>幻读的重点在于新增或者删除：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样, 因为中间有其他事务提交了插入/删除</p>
<h4 id="并发事务的解决办法"><a href="#并发事务的解决办法" class="headerlink" title="并发事务的解决办法"></a>并发事务的解决办法</h4><p>更新丢失通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决</p>
<p>脏读 、 不可重复读和幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决</p>
<ul>
<li>一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改</li>
<li>一种是数据多版本并发控制，简称 MVCC，也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照, 并用这个快照来提供一定级别 的一致性读取</li>
</ul>
<p>SQL标准定义了4类隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销</p>
<ol>
<li>读取未提交内容<ul>
<li>所有事务都可以看到其他未提交事务的执行结果</li>
<li>该隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少</li>
<li>该级别引发的问题是脏读, 读取到了未提交的数据</li>
</ul>
</li>
<li>读取提交内容<ul>
<li>这是大多数数据库系统的默认隔离级别, 但不是MySQL默认的</li>
<li>一个事务只能看见已经提交事务所做的改变</li>
<li>这种隔离级别出现的问题是不可重复读：不可重复读意味着我们在同一个事务中执行完全相同的<code>select</code>语句时可能看到不一样的结果</li>
</ul>
</li>
<li>可重读<ul>
<li>这是MySQL的默认事务隔离级别</li>
<li>它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行</li>
<li>此级别可能出现的问题是幻读：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的幻影行</li>
<li>InnoDB存储引擎通过多版本并发控制机制解决幻读问题, InnoDB还通过间隙锁解决幻读问题</li>
</ul>
</li>
<li>多版本并发控制<ul>
<li>Mysql的大多数事务型存储引擎实现都不是简单的行级锁。基于提升并发性考虑，一般都同时实现了多版本并发控制【MVCC】</li>
<li>MVCC的实现是通过保存数据在某一个时间点快照来实现的。也就是说不管实现时间多长，每个事物看到的数据都是一致的</li>
<li><code>InnoDB</code>的MVCC是通过在每行记录后面保存两个隐藏的列来实现。这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号。每开始一个新的事务，系统版本号都会自动新增。事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较</li>
</ul>
</li>
<li>可串行化<ul>
<li>这是最高的隔离级别</li>
<li>它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁</li>
<li>在这个级别，可能导致大量的超时现象和锁竞争</li>
</ul>
</li>
</ol>
<h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4><p>待补充</p>
<h3 id="grpc遵循什么协议"><a href="#grpc遵循什么协议" class="headerlink" title="grpc遵循什么协议"></a><code>grpc</code>遵循什么协议</h3><h3 id="grpc内部原理是什么"><a href="#grpc内部原理是什么" class="headerlink" title="grpc内部原理是什么"></a><code>grpc</code>内部原理是什么</h3><h3 id="http2的特点是什么，与http1-1的对比"><a href="#http2的特点是什么，与http1-1的对比" class="headerlink" title="http2的特点是什么，与http1.1的对比"></a><code>http2</code>的特点是什么，与<code>http1.1</code>的对比</h3><ul>
<li>HTTP2使用的是二进制传送，HTTP1.X是文本传送, 二进制传送的单位是帧和流。帧组成了流，同时流还有流ID标示</li>
<li>HTTP2支持多路复用, 因为有流ID，所以通过同一个http请求实现多个http请求传输变成了可能，可以通过流ID来标示究竟是哪个流从而定位到是哪个http请求</li>
<li>HTTP2通过gzip和compress压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID就可以知道表头的值了</li>
<li>HTTP2支持服务器推送, HTTP2支持在客户端未经请求许可的情况下，主动向客户端推送内容</li>
</ul>
<h3 id="client如何实现长连接"><a href="#client如何实现长连接" class="headerlink" title="client如何实现长连接"></a>client如何实现长连接</h3><h3 id="大文件排序"><a href="#大文件排序" class="headerlink" title="大文件排序"></a>大文件排序</h3><h3 id="基本排序，哪些是稳定的"><a href="#基本排序，哪些是稳定的" class="headerlink" title="基本排序，哪些是稳定的"></a>基本排序，哪些是稳定的</h3><p>稳定性: 稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录<code>R</code>和<code>S</code>，且在原本的列表中<code>R</code>出现在<code>S</code>之前，在排序过的列表中<code>R</code>也将会是在<code>S</code>之前</p>
<h4 id="稳定的排序算法"><a href="#稳定的排序算法" class="headerlink" title="稳定的排序算法:"></a>稳定的排序算法:</h4><ul>
<li>冒泡排序</li>
<li>插入排序</li>
<li>桶排序</li>
<li>计数排序</li>
<li>归并排序</li>
</ul>
<h4 id="不稳定排序"><a href="#不稳定排序" class="headerlink" title="不稳定排序:"></a>不稳定排序:</h4><ul>
<li>选择排序</li>
<li>希尔排序</li>
<li>堆排序</li>
<li>快速排序</li>
</ul>
<h3 id="Http-get与head"><a href="#Http-get与head" class="headerlink" title="Http get与head"></a>Http <code>get</code>与<code>head</code></h3><ul>
<li>HEAD: 只请求页面的首部</li>
<li>GET: 请求指定的页面信息，并返回实体主体</li>
</ul>
<p><code>HEAD</code>和<code>GET</code>本质是一样的，区别在于<code>HEAD</code>不含有呈现数据，而仅仅是HTTP头信息。有的人可能觉得这个方法没什么用，其实不是这样的</p>
<p>想象一个业务情景: 欲判断某个资源是否存在，我们通常使用<code>GET</code>，但这里用<code>HEAD</code>则意义更加明确</p>
<h3 id="Http-401-403"><a href="#Http-401-403" class="headerlink" title="Http 401,403"></a>Http 401,403</h3><ul>
<li><code>401</code> Unauthorized</li>
<li><code>403</code> Forbidden</li>
</ul>
<p><code>401</code>，是说服务端不知道你是谁, 例如，token 失效，或者 token 缺失，甚至 token 伪造。导致服务端无法识别你的身份，这时会返回 HTTP Status Code 401。客户端此时只能重试</p>
<p><code>403</code>，是说虽然服务端已经知道了你是谁，但是你没有权限去访问该数据资源, 例如，你登录成功了，但是你却非要去访问其他人的隐私内容，或者你无权访问的内容</p>
<h3 id="Http-keep-alive"><a href="#Http-keep-alive" class="headerlink" title="Http keep-alive"></a>Http <code>keep-alive</code></h3><p>HTTP协议采用<strong>请求-应答</strong>模式，当使用普通模式，即非<code>Keep-Alive</code>模式时，每个请求-应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）, 当使用<code>Keep-Alive</code>模式（又称持久连接、连接重用）时，<code>Keep-Alive</code> 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，<code>Keep-Alive</code> 功能避免了建立或者重新建立连接</p>
<p><code>http 1.0</code> 中默认是关闭的，需要在 http 头加入<code>Connection: Keep-Alive</code>，才能启用<code>Keep-Alive</code></p>
<p><code>http 1.1</code>中默认启用<code>Keep-Alive</code>，如果加入<code>Connection: close</code>，才关闭</p>
<p>目前大部分浏览器都是用<code>http1.1</code>协议，也就是说默认都会发起<code>Keep-Alive</code>的连接请求了，所以是否能完成一个完整的<code>Keep-Alive</code>连接就看服务器设置情况</p>
<h4 id="启用Keep-Alive的优点"><a href="#启用Keep-Alive的优点" class="headerlink" title="启用Keep-Alive的优点"></a>启用Keep-Alive的优点</h4><p>启用<code>Keep-Alive</code>模式肯定更高效，性能更高。因为避免了【建立/释放】连接的开销</p>
<h4 id="如何判断消息内容长度的大小"><a href="#如何判断消息内容长度的大小" class="headerlink" title="如何判断消息内容长度的大小"></a>如何判断消息内容长度的大小</h4><p><code>Keep-Alive</code>模式，客户端如何判断请求所得到的响应数据已经接收完成，我们已经知道了，<code>Keep-Alive</code>模式发送玩数据HTTP服务器不会自动断开连接，所有不能再使用返回EOF(-1)来判断</p>
<ul>
<li>使用消息首部字段<code>Conent-Length</code><br><code>Conent-Length</code>表示实体内容长度，客户端（服务器）可以根据这个值来判断数据是否接收完成。但是如果消息中没有<code>Conent-Length</code>，那该如何来判断呢</li>
<li>使用消息首部字段<code>Transfer-Encoding</code><br>当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过<code>Content-length</code>消息首部字段告诉客户端需要接收多少数据。但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用<code>Transfer-Encoding: chunk</code>模式来传输数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用<code>Transfer-Encoding: chunked</code>这样的方式来代替<code>Content-Length</code></li>
</ul>
<h3 id="Http能不能一次连接多次请求，不等后端返回"><a href="#Http能不能一次连接多次请求，不等后端返回" class="headerlink" title="Http能不能一次连接多次请求，不等后端返回"></a>Http能不能一次连接多次请求，不等后端返回</h3><ul>
<li><code>HTTP/1.0</code>: 一个tcp连接只能发一个http请求。每次服务端返回响应后TCP连接会断开</li>
<li><code>HTTP/1.1</code>: 默认开启<code>Connection: keep-alive</code>，一个TCP连接可以发多个http请求，但是多个请求是串行执行</li>
<li><code>HTTP/2</code>: 引入了多路复用技术和二进制分帧，同个域名下的请求只需要占用一个 TCP 连接，请求和响应是并行执行</li>
</ul>
<h3 id="TCP-和-UDP-有什么区别-适用场景"><a href="#TCP-和-UDP-有什么区别-适用场景" class="headerlink" title="TCP 和 UDP 有什么区别,适用场景"></a><code>TCP</code> 和 <code>UDP</code> 有什么区别,适用场景</h3><ul>
<li>TCP基于连接, UDP基于无连接</li>
<li>TCP要求系统资源较多, UDP较少</li>
<li>UDP程序结构简单</li>
<li>TCP流模式, UDP数据报模式</li>
<li>TCP保证数据顺序, UDP不保证</li>
</ul>
<p>UDP应用场景:</p>
<ul>
<li>面向数据报方式</li>
<li>网络数据大多为短消息</li>
<li>拥有大量 client</li>
<li>对数据安全性无特殊要求</li>
<li>网络负担非常重，但对响应速度要求高</li>
</ul>
<p>通常我们在说到网络编程时默认是指TCP编程，即用<code>socket</code>函数创建一个<code>socke</code>t用于TCP通讯</p>
<ul>
<li>TCP 编程</li>
<li>UDP 编程</li>
</ul>
<ol>
<li>TCP面向连接, 如打电话要先拨号建立连接. UDP是无连接的，即发送数据之前不需要建立连接</li>
<li>TCP提供可靠的服务, 也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达. UDP尽最大努力交付，不保证可靠交付</li>
<li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流. UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低, 对实时应用很有用，如IP电话，实时视频会议等</li>
<li>每一条TCP连接只能是点到点的. UDP支持一对一，一对多的交互通信</li>
<li>TCP首部开销20字节. UDP的首部开销小，只有8个字节</li>
<li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li>
</ol>
<h3 id="time-wait的作用"><a href="#time-wait的作用" class="headerlink" title="time-wait的作用"></a><code>time-wait</code>的作用</h3><h3 id="数据库如何建索引"><a href="#数据库如何建索引" class="headerlink" title="数据库如何建索引"></a>数据库如何建索引</h3><h3 id="孤儿进程，僵尸进程"><a href="#孤儿进程，僵尸进程" class="headerlink" title="孤儿进程，僵尸进程"></a>孤儿进程，僵尸进程</h3><h3 id="死锁条件，如何避免"><a href="#死锁条件，如何避免" class="headerlink" title="死锁条件，如何避免"></a>死锁条件，如何避免</h3><h3 id="linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程"><a href="#linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程" class="headerlink" title="linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程"></a>linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程</h3><h3 id="git文件版本，使用顺序，merge跟rebase"><a href="#git文件版本，使用顺序，merge跟rebase" class="headerlink" title="git文件版本，使用顺序，merge跟rebase"></a>git文件版本，使用顺序，<code>merge</code>跟<code>rebase</code></h3><h3 id="一般会用到哪些数据结构"><a href="#一般会用到哪些数据结构" class="headerlink" title="一般会用到哪些数据结构"></a>一般会用到哪些数据结构</h3><h3 id="链表和数组相比-有什么优缺点"><a href="#链表和数组相比-有什么优缺点" class="headerlink" title="链表和数组相比, 有什么优缺点"></a>链表和数组相比, 有什么优缺点</h3><p>数组,在内存上给出了连续的空间. 链表,内存地址上可以是不连续的</p>
<p>数组内的数据可随机访问.但链表不具备随机访问性</p>
<p>链表的扩展性比数组好.因为一个数组建立后所占用的空间大小就是固定的.如果满了就没法扩展.只能新建一个更大空间的数组.而链表不是固定的,可以很方便的扩展</p>
<p>内存地址的利用率方面.不管你内存里还有多少空间,如果没办法一次性给出数组所需的要空间,那就会提示内存不足,磁盘空间整理的原因之一在这里.而链表可以是分散的空间地址</p>
<p>如果数组的中间插入一个元素,那么这个元素后的所有元素的内存地址都要往后移动.删除的话同理.只有对数据的最后一个元素进行插入删除操作时,才比较快.链表只需要更改有必要更改的节点内的节点信息就够了.并不需要更改节点的内存地址</p>
<h3 id="如何判断两个无环单链表有没有交叉点"><a href="#如何判断两个无环单链表有没有交叉点" class="headerlink" title="如何判断两个无环单链表有没有交叉点"></a>如何判断两个无环单链表有没有交叉点</h3><h3 id="如何判断一个单链表有没有环-并找出入环点"><a href="#如何判断一个单链表有没有环-并找出入环点" class="headerlink" title="如何判断一个单链表有没有环, 并找出入环点"></a>如何判断一个单链表有没有环, 并找出入环点</h3><h3 id="描述一下-TCP-四次挥手的过程中"><a href="#描述一下-TCP-四次挥手的过程中" class="headerlink" title="描述一下 TCP 四次挥手的过程中"></a>描述一下 TCP 四次挥手的过程中</h3><h3 id="TCP-有哪些状态"><a href="#TCP-有哪些状态" class="headerlink" title="TCP 有哪些状态"></a>TCP 有哪些状态</h3><h3 id="TCP-的-LISTEN-状态是什么"><a href="#TCP-的-LISTEN-状态是什么" class="headerlink" title="TCP 的 LISTEN 状态是什么"></a>TCP 的 <code>LISTEN</code> 状态是什么</h3><h3 id="TCP-的-CLOSE-WAIT-状态是什么"><a href="#TCP-的-CLOSE-WAIT-状态是什么" class="headerlink" title="TCP 的 CLOSE_WAIT 状态是什么"></a>TCP 的 <code>CLOSE_WAIT</code> 状态是什么</h3><h3 id="建立一个-socket-连接要经过哪些步骤"><a href="#建立一个-socket-连接要经过哪些步骤" class="headerlink" title="建立一个 socket 连接要经过哪些步骤"></a>建立一个 <code>socket</code> 连接要经过哪些步骤</h3><h3 id="常见的-HTTP-状态码有哪些"><a href="#常见的-HTTP-状态码有哪些" class="headerlink" title="常见的 HTTP 状态码有哪些"></a>常见的 <code>HTTP</code> 状态码有哪些</h3><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头用以响应浏览器的请求</p>
<p>下面是常见的HTTP状态码:</p>
<ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
</ul>
<h4 id="HTTP状态码分类"><a href="#HTTP状态码分类" class="headerlink" title="HTTP状态码分类"></a>HTTP状态码分类</h4><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型:</p>
<ul>
<li>1xx: 信息，服务器收到请求，需要请求者继续执行操作</li>
<li>2xx: 成功，操作被成功接收并处理</li>
<li>3xx: 重定向，需要进一步的操作以完成请求</li>
<li>4xx: 客户端错误，请求包含语法错误或无法完成请求</li>
<li>5xx: 服务器错误，服务器在处理请求的过程中发生了错误</li>
</ul>
<h3 id="301和302有什么区别"><a href="#301和302有什么区别" class="headerlink" title="301和302有什么区别"></a><code>301</code>和<code>302</code>有什么区别</h3><p><code>302</code>重定向只是暂时的重定向，搜索引擎会抓取新的内容而保留旧的地址，因为服务器返回<code>302</code>，所以，搜索搜索引擎认为新的网址是暂时的。 而<code>301</code>重定向是永久的重定向，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址</p>
<p>对于301请求，浏览器是默认给一个很长的缓存。而302是不缓存的</p>
<p>302：请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在<code>Cache-Control</code>或<code>Expires</code>中进行了指定的情况下，这个响应才是可缓存的</p>
<h3 id="504和500有什么区别"><a href="#504和500有什么区别" class="headerlink" title="504和500有什么区别"></a><code>504</code>和<code>500</code>有什么区别</h3><ul>
<li>502 Bad Gateway错误</li>
<li>504 Bad Gateway timeout 网关超时</li>
<li>500 后端脚本出现错误。或者高并发时候因为系统资源限制，而不能打开过多文件</li>
</ul>
<h3 id="HTTPS-和-HTTP-有什么区别"><a href="#HTTPS-和-HTTP-有什么区别" class="headerlink" title="HTTPS 和 HTTP 有什么区别"></a><code>HTTPS</code> 和 <code>HTTP</code> 有什么区别</h3><p>HTTP（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。被用于在 Web 浏览器和网站服务器之间传递信息, HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 <code>http://</code> 打头的都是标准 HTTP 服务. HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息</p>
<p>HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 <code>SSL/TLS</code> 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性</p>
<p>HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式:</p>
<ul>
<li>TCP 三次同步握手</li>
<li>客户端验证服务器数字证书</li>
<li>DH 算法协商对称加密算法的密钥、hash 算法的密钥</li>
<li>SSL 安全加密隧道协商完成</li>
<li>网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改</li>
</ul>
<h4 id="HTTP-与-HTTPS-区别"><a href="#HTTP-与-HTTPS-区别" class="headerlink" title="HTTP 与 HTTPS 区别"></a>HTTP 与 HTTPS 区别</h4><ul>
<li>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好</li>
<li>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用</li>
<li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包</li>
<li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443</li>
<li>TTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以 HTTPS 比 HTTP 要更耗费服务器资源</li>
</ul>
<h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><p>在TCP/IP协议中，TCP协议通过三次握手建立一个可靠的连接</p>
<ul>
<li>第一次握手：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认</li>
<li>第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态</li>
<li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</li>
</ul>
<h4 id="HTTPS-的工作原理"><a href="#HTTPS-的工作原理" class="headerlink" title="HTTPS 的工作原理"></a>HTTPS 的工作原理</h4><p>HTTPS 能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用 HTTPS 协议</p>
<ol>
<li>客户端发起 HTTPS 请求</li>
<li>服务端的配置, 采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面, 这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西</li>
<li>传送证书, 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等</li>
<li>客户端解析证书, 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题, 如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容</li>
<li>传送加密信息, 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了</li>
<li>服务端解密信息, 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全</li>
<li>传输加密后的信息, 这部分信息是服务端用私钥加密后的信息，可以在客户端被还原</li>
<li>客户端解密信息, 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策</li>
</ol>
<h3 id="手写一个快速排序"><a href="#手写一个快速排序" class="headerlink" title="手写一个快速排序"></a>手写一个快速排序</h3><p>快速排序利用的是分治思想，假设要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为分区点，我们遍历 p 到 r 之间的数据，将小于分区点的放到左边，将大于分区点的放到右边，将分区点放到中间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func QuickSort(arr []int) &#123;</span><br><span class="line">    separateSort(arr, 0, len(arr)-1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func separateSort(arr []int, start, end int) &#123;</span><br><span class="line">    if start &gt;&#x3D; end &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    i :&#x3D; partition(arr, start, end)</span><br><span class="line">    separateSort(arr, start, i-1)</span><br><span class="line">    separateSort(arr, i+1, end)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func partition(arr []int, start, end int) int &#123;</span><br><span class="line">    pivot :&#x3D; arr[end]</span><br><span class="line">    var i &#x3D; start</span><br><span class="line">    for j :&#x3D; start; j &lt; end; j++ &#123;</span><br><span class="line">        if arr[j] &lt; pivot &#123;</span><br><span class="line">            if !(i &#x3D;&#x3D; j) &#123;</span><br><span class="line">                arr[i], arr[j] &#x3D; arr[j], arr[i]</span><br><span class="line">            &#125;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i], arr[end] &#x3D; arr[end], arr[i]</span><br><span class="line">    return i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置中心如何保证一致性"><a href="#配置中心如何保证一致性" class="headerlink" title="配置中心如何保证一致性"></a>配置中心如何保证一致性</h3><h3 id="Redis-里数据结构的实现熟悉吗"><a href="#Redis-里数据结构的实现熟悉吗" class="headerlink" title="Redis 里数据结构的实现熟悉吗"></a>Redis 里数据结构的实现熟悉吗</h3><h3 id="SLB原理"><a href="#SLB原理" class="headerlink" title="SLB原理"></a>SLB原理</h3><h3 id="分布式一致性原则"><a href="#分布式一致性原则" class="headerlink" title="分布式一致性原则"></a>分布式一致性原则</h3><h3 id="智能指针-–-gt-C"><a href="#智能指针-–-gt-C" class="headerlink" title="智能指针 –&gt; C++"></a>智能指针 –&gt; C++</h3><h3 id="唯一索引和主键索引"><a href="#唯一索引和主键索引" class="headerlink" title="唯一索引和主键索引"></a>唯一索引和主键索引</h3><h3 id="tcp粘包"><a href="#tcp粘包" class="headerlink" title="tcp粘包"></a>tcp粘包</h3><h3 id="进程虚拟空间分布"><a href="#进程虚拟空间分布" class="headerlink" title="进程虚拟空间分布"></a>进程虚拟空间分布</h3><h3 id="c-和-go-和-java-对比"><a href="#c-和-go-和-java-对比" class="headerlink" title="c++ 和 go 和 java 对比"></a>c++ 和 go 和 java 对比</h3><h3 id="堆的时间复杂度，稳定性"><a href="#堆的时间复杂度，稳定性" class="headerlink" title="堆的时间复杂度，稳定性"></a>堆的时间复杂度，稳定性</h3><h3 id="几种基本排序算法"><a href="#几种基本排序算法" class="headerlink" title="几种基本排序算法"></a>几种基本排序算法</h3><h3 id="top-K-问题"><a href="#top-K-问题" class="headerlink" title="top-K 问题"></a>top-K 问题</h3><h3 id="什么是主键"><a href="#什么是主键" class="headerlink" title="什么是主键"></a>什么是主键</h3><h3 id="联合索引和唯一索引"><a href="#联合索引和唯一索引" class="headerlink" title="联合索引和唯一索引"></a>联合索引和唯一索引</h3><h3 id="越多的索引越好吗"><a href="#越多的索引越好吗" class="headerlink" title="越多的索引越好吗"></a>越多的索引越好吗</h3><h3 id="建立索引要注意什么"><a href="#建立索引要注意什么" class="headerlink" title="建立索引要注意什么"></a>建立索引要注意什么</h3><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h3 id="tcp三次握手"><a href="#tcp三次握手" class="headerlink" title="tcp三次握手"></a>tcp三次握手</h3><h3 id="http与https"><a href="#http与https" class="headerlink" title="http与https"></a>http与https</h3><h3 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h3><h3 id="cookie与session"><a href="#cookie与session" class="headerlink" title="cookie与session"></a><code>cookie</code>与<code>session</code></h3><h3 id="select-和-epoll"><a href="#select-和-epoll" class="headerlink" title="select 和 epoll"></a>select 和 epoll</h3><h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a><code>TCP</code> 拥塞控制</h3><h3 id="Mysql-用的是什么数据结构"><a href="#Mysql-用的是什么数据结构" class="headerlink" title="Mysql 用的是什么数据结构"></a><code>Mysql</code> 用的是什么数据结构</h3><h3 id="kafka-的工作原理"><a href="#kafka-的工作原理" class="headerlink" title="kafka 的工作原理"></a><code>kafka</code> 的工作原理</h3><h3 id="详细描述一下-HTTPS-的加密过程，需要几次通信"><a href="#详细描述一下-HTTPS-的加密过程，需要几次通信" class="headerlink" title="详细描述一下 HTTPS 的加密过程，需要几次通信"></a>详细描述一下 <code>HTTPS</code> 的加密过程，需要几次通信</h3><h3 id="三次握手和四次挥手，说一下-time-wait"><a href="#三次握手和四次挥手，说一下-time-wait" class="headerlink" title="三次握手和四次挥手，说一下 time_wait"></a>三次握手和四次挥手，说一下 <code>time_wait</code></h3><h3 id="Mysql-的幻读是怎么个情况，Mysql-是如何避免的"><a href="#Mysql-的幻读是怎么个情况，Mysql-是如何避免的" class="headerlink" title="Mysql 的幻读是怎么个情况，Mysql 是如何避免的"></a><code>Mysql</code> 的幻读是怎么个情况，<code>Mysql</code> 是如何避免的</h3><h3 id="自旋锁和互斥锁有什么区别"><a href="#自旋锁和互斥锁有什么区别" class="headerlink" title="自旋锁和互斥锁有什么区别"></a>自旋锁和互斥锁有什么区别</h3><h3 id="用过哪些分布式锁"><a href="#用过哪些分布式锁" class="headerlink" title="用过哪些分布式锁"></a>用过哪些分布式锁</h3><h3 id="redis-setnx-expire-有什么缺点，如何优化"><a href="#redis-setnx-expire-有什么缺点，如何优化" class="headerlink" title="redis setnx + expire 有什么缺点，如何优化"></a>redis <code>setnx + expire</code> 有什么缺点，如何优化</h3><h3 id="打开一个-URL-的过程"><a href="#打开一个-URL-的过程" class="headerlink" title="打开一个 URL 的过程"></a>打开一个 <code>URL</code> 的过程</h3><h3 id="B-树-和-B-树的区别，为什么-mysql-要用-B-树，mongodb-要用-B-树"><a href="#B-树-和-B-树的区别，为什么-mysql-要用-B-树，mongodb-要用-B-树" class="headerlink" title="B 树 和 B+ 树的区别，为什么 mysql 要用 B+ 树，mongodb 要用 B 树"></a><code>B</code> 树 和 <code>B+</code> 树的区别，为什么<code> mysql</code> 要用 <code>B+</code> 树，<code>mongodb</code> 要用 <code>B</code> 树</h3><h3 id="redis-的跳表，为什么不用红黑树"><a href="#redis-的跳表，为什么不用红黑树" class="headerlink" title="redis 的跳表，为什么不用红黑树"></a><code>redis</code> 的跳表，为什么不用红黑树</h3><h3 id="redis-集群是怎么实现的，说一下一致性-hash"><a href="#redis-集群是怎么实现的，说一下一致性-hash" class="headerlink" title="redis 集群是怎么实现的，说一下一致性 hash"></a><code>redis</code> 集群是怎么实现的，说一下一致性 <code>hash</code></h3><h3 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h3><h3 id="Mysql-集群如何保证数据的一致性"><a href="#Mysql-集群如何保证数据的一致性" class="headerlink" title="Mysql 集群如何保证数据的一致性"></a><code>Mysql</code> 集群如何保证数据的一致性</h3><h3 id="Mysql-集群在保证强一致性的情况下，如何保证高并发"><a href="#Mysql-集群在保证强一致性的情况下，如何保证高并发" class="headerlink" title="Mysql 集群在保证强一致性的情况下，如何保证高并发"></a><code>Mysql</code> 集群在保证强一致性的情况下，如何保证高并发</h3><h3 id="哪些操作会导致内存泄漏"><a href="#哪些操作会导致内存泄漏" class="headerlink" title="哪些操作会导致内存泄漏"></a>哪些操作会导致内存泄漏</h3><p>内存泄漏，就是不再需要的对象仍然存在内存中，内存泄漏不断堆积的后果就是内存溢出，即内存不够用。</p>
<p>垃圾回收机制会定期扫描对象，如果一个对象没有被其他对象引用，或两个对象互相引用但没有被第三个对象引用，则它们的内存会被回收</p>
<ol>
<li>单例造成的内存泄漏<br>由于单例的静态特性使得其生命周期和应用的生命周期一样长，如果一个对象已经不再需要使用了，而单例对象还持有该对象的引用，就会使得该对象不能被正常回收，从而导致了内存泄漏</li>
<li>10次内存泄露，有9次是<code>goroutine</code>泄露<br><code>goroutine</code>泄露的本质是<code>channel</code>阻塞，无法继续向下执行，导致此<code>goroutine</code>关联的内存都无法释放，进一步造成内存泄露</li>
</ol>
<h3 id="哪些操作会导致-io-开销大幅上升"><a href="#哪些操作会导致-io-开销大幅上升" class="headerlink" title="哪些操作会导致 io 开销大幅上升"></a>哪些操作会导致 <code>io</code> 开销大幅上升</h3><h3 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h3><p><strong>同步</strong>，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是处于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。整个处理过程顺序执行，当各个过程都执行完毕，并返回结果。是一种线性执行的方式，执行的流程不能跨越。一般用于流程性比较强的程序，比如用户登录，需要对用户验证完成后才能登录系统</p>
<p><strong>异步</strong>，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。异步只是发送了调用的指令，调用者无需等待被调用的方法完全执行完毕；而是继续执行下面的流程。是一种并行处理的方式，不必等待一个程序执行完，可以执行其它的任务，比如页面数据加载过程，不需要等所有数据获取后再显示页面</p>
<p>他们的区别就在于一个需要等待，一个不需要等待，在部分情况下，我们的项目开发中都会优先选择不需要等待的异步交互方式，比如日志记录就可以使用异步方式进行保存</p>
<p>如果<strong>同步</strong>是发起了一个调用后， 没有得到结果之前不返回， 那它毫无疑问就是被<strong>阻塞</strong>了，即调用进程处于 <code>waiting</code> 状态</p>
<p>如果<strong>异步</strong>调用发出了以后就直接返回了， 毫无疑问， 这个进程是<strong>非阻塞</strong>的</p>
<h3 id="怎么做一个自动化配置平台系统"><a href="#怎么做一个自动化配置平台系统" class="headerlink" title="怎么做一个自动化配置平台系统"></a>怎么做一个自动化配置平台系统</h3><h3 id="开发的流程规范是什么"><a href="#开发的流程规范是什么" class="headerlink" title="开发的流程规范是什么"></a>开发的流程规范是什么</h3><h3 id="线上-cpu-和内存突然飙高后应该怎么排错"><a href="#线上-cpu-和内存突然飙高后应该怎么排错" class="headerlink" title="线上 cpu 和内存突然飙高后应该怎么排错"></a>线上 <code>cpu</code> 和内存突然飙高后应该怎么排错</h3><h3 id="服务器受到攻击怎么定位服务器问题"><a href="#服务器受到攻击怎么定位服务器问题" class="headerlink" title="服务器受到攻击怎么定位服务器问题"></a>服务器受到攻击怎么定位服务器问题</h3><h3 id="rpc的具体实现"><a href="#rpc的具体实现" class="headerlink" title="rpc的具体实现"></a><code>rpc</code>的具体实现</h3><h3 id="设计一个海量日志写入系统"><a href="#设计一个海量日志写入系统" class="headerlink" title="设计一个海量日志写入系统"></a>设计一个海量日志写入系统</h3><h3 id="设计一个长链接转短链接，需要考虑高并发"><a href="#设计一个长链接转短链接，需要考虑高并发" class="headerlink" title="设计一个长链接转短链接，需要考虑高并发"></a>设计一个长链接转短链接，需要考虑高并发</h3><h3 id="设计一个微信朋友圈系统，列出主要的表结构，写出一些数据结构"><a href="#设计一个微信朋友圈系统，列出主要的表结构，写出一些数据结构" class="headerlink" title="设计一个微信朋友圈系统，列出主要的表结构，写出一些数据结构"></a>设计一个微信朋友圈系统，列出主要的表结构，写出一些数据结构</h3><h3 id="设计一个海量的评论系统"><a href="#设计一个海量的评论系统" class="headerlink" title="设计一个海量的评论系统"></a>设计一个海量的评论系统</h3><h3 id="使用过的中间件"><a href="#使用过的中间件" class="headerlink" title="使用过的中间件"></a>使用过的中间件</h3><h3 id="唯一订单号生成的算法问题"><a href="#唯一订单号生成的算法问题" class="headerlink" title="唯一订单号生成的算法问题"></a>唯一订单号生成的算法问题</h3><h3 id="mysql高可用的方案"><a href="#mysql高可用的方案" class="headerlink" title="mysql高可用的方案"></a><code>mysql</code>高可用的方案</h3><h3 id="服务发现怎么实现的"><a href="#服务发现怎么实现的" class="headerlink" title="服务发现怎么实现的"></a>服务发现怎么实现的</h3><h3 id="如何保证服务宕机造成的分布式服务节点处理问题"><a href="#如何保证服务宕机造成的分布式服务节点处理问题" class="headerlink" title="如何保证服务宕机造成的分布式服务节点处理问题"></a>如何保证服务宕机造成的分布式服务节点处理问题</h3><h3 id="高可用软件是什么"><a href="#高可用软件是什么" class="headerlink" title="高可用软件是什么"></a>高可用软件是什么</h3><h3 id="怎么设计orm，你会怎么写"><a href="#怎么设计orm，你会怎么写" class="headerlink" title="怎么设计orm，你会怎么写"></a>怎么设计<code>orm</code>，你会怎么写</h3><h3 id="怎么设计一个并发服务程序"><a href="#怎么设计一个并发服务程序" class="headerlink" title="怎么设计一个并发服务程序"></a>怎么设计一个并发服务程序</h3><h3 id="设计一个web框架，要怎么设计"><a href="#设计一个web框架，要怎么设计" class="headerlink" title="设计一个web框架，要怎么设计"></a>设计一个web框架，要怎么设计</h3><h3 id="实现消息队列-多生产者，多消费者"><a href="#实现消息队列-多生产者，多消费者" class="headerlink" title="实现消息队列. 多生产者，多消费者"></a>实现消息队列. 多生产者，多消费者</h3><h3 id="怎么做弹性扩缩容，原理是什么"><a href="#怎么做弹性扩缩容，原理是什么" class="headerlink" title="怎么做弹性扩缩容，原理是什么"></a>怎么做弹性扩缩容，原理是什么</h3><h3 id="解释一下中间件原理"><a href="#解释一下中间件原理" class="headerlink" title="解释一下中间件原理"></a>解释一下中间件原理</h3><h3 id="各个系统出问题怎么监控报警"><a href="#各个系统出问题怎么监控报警" class="headerlink" title="各个系统出问题怎么监控报警"></a>各个系统出问题怎么监控报警</h3><h3 id="微服务架构是什么样的"><a href="#微服务架构是什么样的" class="headerlink" title="微服务架构是什么样的"></a>微服务架构是什么样的</h3><h3 id="负载均衡原理是什么"><a href="#负载均衡原理是什么" class="headerlink" title="负载均衡原理是什么"></a>负载均衡原理是什么</h3><h3 id="分布式锁的实现原理"><a href="#分布式锁的实现原理" class="headerlink" title="分布式锁的实现原理"></a>分布式锁的实现原理</h3><h3 id="Mysql高可用方案有哪些"><a href="#Mysql高可用方案有哪些" class="headerlink" title="Mysql高可用方案有哪些"></a><code>Mysql</code>高可用方案有哪些</h3><hr>
<ul>
<li>数据库和网络一定要重点复习</li>
<li>语言主要还是平时的积累，多看源码，要知道对应语言的一些特性和比较常用或者有特色的标准库</li>
<li>数据库最重要的肯定是 <code>Mysql</code>，<code>Mysql</code>中比较重要的就是隔离级别和索引，一定一定要弄懂。然后就是 <code>redis</code></li>
<li>中间件这个也是必问的一个环节，尽量要多了解一些，但是一定要说自己会的，至少知道运行原理和特点。比较重要的中间件有：<code>memcache</code>、<code>kafka</code></li>
<li>架构设计有实战最好，没有实战多学习一些开源的架构，尤其是日志系统、评论系统、聊天室相关的内容</li>
<li>好好准备一个有亮点的项目，很多面试官喜欢让你说一个印象最深的项目，这时候就是你的表演时刻了</li>
<li>分布式、Docker、微服务也是经常会问的东西，也要好好准备</li>
<li>最重要的算法, 能刷多少刷多少，主要是学方法</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/06/08/go-interview/" rel="prev" title="Golang 编程面试问题总结">
                  <i class="fa fa-chevron-left"></i> Golang 编程面试问题总结
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/09/12/linux-interview/" rel="next" title="Linux 常见面试问题总结">
                  Linux 常见面试问题总结 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ifcalm</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">130k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:58</span>
  </span>
</div>





<!-- 网站运行时间的设置 -->

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
