<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="Go, 又称Golang是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言, Go的语法接近C语言，但对于变量的声明有所不同">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang 入坑法门">
<meta property="og:url" content="http://example.com/2018/09/06/golang-base/index.html">
<meta property="og:site_name" content="缘起">
<meta property="og:description" content="Go, 又称Golang是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言, Go的语法接近C语言，但对于变量的声明有所不同">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-09-06T07:13:13.000Z">
<meta property="article:modified_time" content="2020-12-27T10:23:04.455Z">
<meta property="article:author" content="ifcalm">
<meta property="article:tag" content="Golang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2018/09/06/golang-base/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>Golang 入坑法门 | 缘起</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">缘起</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85"><span class="nav-number">1.</span> <span class="nav-text">包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5"><span class="nav-number">2.</span> <span class="nav-text">导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%87%BA%E5%90%8D"><span class="nav-number">3.</span> <span class="nav-text">导出名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%80%BC%E8%BF%94%E5%9B%9E"><span class="nav-number">5.</span> <span class="nav-text">多值返回</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">5.1.</span> <span class="nav-text">命名返回值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">6.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">6.1.</span> <span class="nav-text">变量的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="nav-number">6.2.</span> <span class="nav-text">短变量声明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.</span> <span class="nav-text">Go 的基本类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6%E5%80%BC"><span class="nav-number">8.</span> <span class="nav-text">零值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">9.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="nav-number">10.</span> <span class="nav-text">类型推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">11.</span> <span class="nav-text">常量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E5%B8%B8%E9%87%8F"><span class="nav-number">11.1.</span> <span class="nav-text">数值常量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for"><span class="nav-number">12.</span> <span class="nav-text">for</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF"><span class="nav-number">12.1.</span> <span class="nav-text">无限循环</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#if"><span class="nav-number">13.</span> <span class="nav-text">if</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#if-%E7%9A%84%E7%AE%80%E7%9F%AD%E8%AF%AD%E5%8F%A5"><span class="nav-number">13.1.</span> <span class="nav-text">if 的简短语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#if-%E5%92%8C-else"><span class="nav-number">13.2.</span> <span class="nav-text">if 和 else</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch"><span class="nav-number">14.</span> <span class="nav-text">switch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#switch-%E7%9A%84%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="nav-number">14.1.</span> <span class="nav-text">switch 的求值顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89%E6%9D%A1%E4%BB%B6%E7%9A%84-switch"><span class="nav-number">14.2.</span> <span class="nav-text">没有条件的 switch</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer"><span class="nav-number">15.</span> <span class="nav-text">defer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#defer-%E6%A0%88"><span class="nav-number">15.1.</span> <span class="nav-text">defer 栈</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">16.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">17.</span> <span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E4%BD%BF%E7%94%A8%E7%82%B9%E5%8F%B7%E6%9D%A5%E8%AE%BF%E9%97%AE"><span class="nav-number">17.1.</span> <span class="nav-text">结构体字段使用点号来访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="nav-number">17.2.</span> <span class="nav-text">结构体指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%87%E6%B3%95"><span class="nav-number">17.3.</span> <span class="nav-text">结构体文法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">18.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E7%89%87"><span class="nav-number">19.</span> <span class="nav-text">切片</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E7%89%87%E5%B0%B1%E5%83%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-number">19.1.</span> <span class="nav-text">切片就像数组的引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E7%89%87%E6%96%87%E6%B3%95"><span class="nav-number">19.2.</span> <span class="nav-text">切片文法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="nav-number">19.3.</span> <span class="nav-text">切片的默认行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%8E%E5%AE%B9%E9%87%8F"><span class="nav-number">19.4.</span> <span class="nav-text">切片的长度与容量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nil-%E5%88%87%E7%89%87"><span class="nav-number">19.5.</span> <span class="nav-text">nil 切片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8-make-%E5%88%9B%E5%BB%BA%E5%88%87%E7%89%87"><span class="nav-number">19.6.</span> <span class="nav-text">用 make 创建切片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E5%88%87%E7%89%87"><span class="nav-number">19.7.</span> <span class="nav-text">切片的切片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E5%88%87%E7%89%87%E8%BF%BD%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="nav-number">19.8.</span> <span class="nav-text">向切片追加元素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Range"><span class="nav-number">20.</span> <span class="nav-text">Range</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E2%80%93-gt-%E5%AD%97%E5%85%B8"><span class="nav-number">21.</span> <span class="nav-text">映射–&gt;字典</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E6%98%A0%E5%B0%84"><span class="nav-number">21.1.</span> <span class="nav-text">修改映射</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%80%BC"><span class="nav-number">22.</span> <span class="nav-text">函数值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AD%E5%8C%85"><span class="nav-number">23.</span> <span class="nav-text">函数的闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">24.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8D%B3%E5%87%BD%E6%95%B0"><span class="nav-number">24.1.</span> <span class="nav-text">方法即函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85"><span class="nav-number">24.2.</span> <span class="nav-text">指针接收者</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="nav-number">25.</span> <span class="nav-text">指针与函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8C%87%E9%92%88%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">25.1.</span> <span class="nav-text">方法与指针重定向</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%80%BC%E6%88%96%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E6%8E%A5%E6%94%B6%E8%80%85"><span class="nav-number">26.</span> <span class="nav-text">选择值或指针作为接收者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">27.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E9%9A%90%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="nav-number">27.1.</span> <span class="nav-text">接口与隐式实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%80%BC"><span class="nav-number">27.2.</span> <span class="nav-text">接口值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%80%BC%E4%B8%BA-nil-%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%80%BC"><span class="nav-number">27.3.</span> <span class="nav-text">底层值为 nil 的接口值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nil-%E6%8E%A5%E5%8F%A3%E5%80%BC"><span class="nav-number">27.4.</span> <span class="nav-text">nil 接口值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3"><span class="nav-number">27.5.</span> <span class="nav-text">空接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="nav-number">27.6.</span> <span class="nav-text">类型断言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9"><span class="nav-number">27.7.</span> <span class="nav-text">类型选择</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-%E7%A8%8B"><span class="nav-number">28.</span> <span class="nav-text">Go 程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E9%81%93"><span class="nav-number">29.</span> <span class="nav-text">信道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E7%BC%93%E5%86%B2%E7%9A%84%E4%BF%A1%E9%81%93"><span class="nav-number">29.1.</span> <span class="nav-text">带缓冲的信道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#range-%E5%92%8C-close"><span class="nav-number">29.2.</span> <span class="nav-text">range 和 close</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-%E8%AF%AD%E5%8F%A5"><span class="nav-number">30.</span> <span class="nav-text">select 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sync-Mutex"><span class="nav-number">31.</span> <span class="nav-text">sync.Mutex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%96%87%E5%AE%8C"><span class="nav-number">32.</span> <span class="nav-text">全文完</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ifcalm</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/09/06/golang-base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ifcalm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘起">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Golang 入坑法门
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-06 15:13:13" itemprop="dateCreated datePublished" datetime="2018-09-06T15:13:13+08:00">2018-09-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-27 18:23:04" itemprop="dateModified" datetime="2020-12-27T18:23:04+08:00">2020-12-27</time>
      </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>29k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>27 分钟</span>
    </span>
</div>

            <div class="post-description">Go, 又称Golang是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言, Go的语法接近C语言，但对于变量的声明有所不同</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>每个Go 程序都是由包构成<br>程序从 <code>main</code> 包开始运行<br>本程序通过导入 <code>fmt</code> 和 <code>math/rand</code> 来使用这两个包<br>按照约定，包名与导入路径的最后一个元素一致。例如，<code>math/rand</code> 包中的源码均以 <code>package rand</code> 语句开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;math&#x2F;rand&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     fmt.Println(&quot;My favorite number is&quot;, rand.Intn(10))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>此代码用圆括号组合了导入，这是分组形式的导入语句<br>当然你也可以编写多个导入语句，例如：<br><code>import &quot;fmt&quot;</code><br><code>import &quot;math&quot;</code><br>不过使用分组导入语句是更好的形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     fmt.Printf(&quot;Now you have %g problems.\n&quot;, math.Sqrt(7))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="导出名"><a href="#导出名" class="headerlink" title="导出名"></a>导出名</h3><p><strong>这里导出与未导出指该变量是公开的还是私有的</strong><br>在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，Pizza就是个已导出名，Pi 也同样，它导出自 math 包<br>pizza 和 pi 并未以大写字母开头，所以它们是未导出的<br>在导入一个包时，你只能引用其中已导出的名字。任何“未导出”的名字在该包外均无法访问<br>执行代码，观察错误输出<br>然后将 math.pi 改名为 math.Pi 再试着执行一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     fmt.Println(math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数可以没有参数或接受多个参数<br>在本例中，add 接受两个 int 类型的参数<br>注意<strong>类型在变量名</strong> 之后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func add(x int, y int) int &#123;</span><br><span class="line">     return x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     fmt.Println(add(42, 13))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略<br>在本例中，<code>x int, y int</code>被缩写为 <code>x, y int</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func add(x, y int) int &#123;</span><br><span class="line">     return x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     fmt.Println(add(42, 13))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多值返回"><a href="#多值返回" class="headerlink" title="多值返回"></a>多值返回</h3><p>函数可以返回任意数量的返回值, swap 函数返回了两个字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func swap(x, y string) (string, string) &#123;</span><br><span class="line">     return y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     a, b :&#x3D; swap(&quot;hello&quot;, &quot;world&quot;)</span><br><span class="line">     fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h4><p>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量, 返回值的名称应当具有一定的意义，它可以作为文档使用, 没有参数的 <code>return</code> 语句返回已命名的返回值, 也就是直接返回。直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func split(sum int) (x, y int) &#123;</span><br><span class="line">     x &#x3D; sum * 4 &#x2F; 9</span><br><span class="line">     y &#x3D; sum - x</span><br><span class="line">     return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     fmt.Println(split(17))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><code>var</code> 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后, 就像在这个例子中看到的一样，<code>var</code> 语句可以出现在包或函数级别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">var c, python, java bool</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     var i int</span><br><span class="line">     fmt.Println(i, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h4><p>变量声明可以包含初始值，每个变量对应一个, 如果初始化值已存在，则可以省略类型, 变量会从初始值中获得类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">var i, j int &#x3D; 1, 2</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     var c, python, java &#x3D; true, false, &quot;no!&quot;</span><br><span class="line">     fmt.Println(i, j, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>在函数中，简洁赋值语句 <code>:=</code> 可在类型明确的地方代替 <code>var</code> 声明, 函数外的每个语句都必须以关键字开始（var, func 等等），因此 <code>:=</code> 结构不能在函数外使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     var i, j int &#x3D; 1, 2</span><br><span class="line">     k :&#x3D; 3</span><br><span class="line">     c, python, java :&#x3D; true, false, &quot;no!&quot;</span><br><span class="line">     fmt.Println(i, j, k, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Go-的基本类型"><a href="#Go-的基本类型" class="headerlink" title="Go 的基本类型"></a>Go 的基本类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">string</span><br><span class="line">int  int8  int16  int32  int64</span><br><span class="line">uint uint8 uint16 uint32 uint64 uintptr</span><br><span class="line">byte &#x2F;&#x2F; uint8 的别名</span><br><span class="line">rune &#x2F;&#x2F; int32 的别名, 表示一个 Unicode 码点</span><br><span class="line">float32 float64</span><br><span class="line">complex64 complex128</span><br></pre></td></tr></table></figure>
<p>本例展示了几种类型的变量。 同导入语句一样，变量声明也可以分组成一个语法块。<br><code>int</code>, <code>uint</code> 和 <code>uintptr</code> 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 <code>int</code> 类型，除非你有特殊的理由使用固定大小或无符号的整数类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;math&#x2F;cmplx&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">     ToBe bool &#x3D; false</span><br><span class="line">     MaxInt uint64 &#x3D; 1&lt;&lt;64 - 1</span><br><span class="line">     z complex128 &#x3D; cmplx.Sqrt(-5 + 12i)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     fmt.Printf(&quot;Type: %T Value: %v\n&quot;, ToBe, ToBe)</span><br><span class="line">     fmt.Printf(&quot;Type: %T Value: %v\n&quot;, MaxInt, MaxInt)</span><br><span class="line">     fmt.Printf(&quot;Type: %T Value: %v\n&quot;, z, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h3><p>没有明确初始值的变量声明会被赋予它们的 零值<br>基础类型的零值是：</p>
<ul>
<li>数值类型为 0</li>
<li>布尔类型为 false</li>
<li>字符串为 “”（空字符串）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     var i int</span><br><span class="line">     var f float64</span><br><span class="line">     var b bool</span><br><span class="line">     var s string</span><br><span class="line">     fmt.Printf(&quot;%v %v %v %q\n&quot;, i, f, b, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>表达式 T(v) 将值 v 转换为类型 T。<br>一些关于数值的转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var i int &#x3D; 42</span><br><span class="line">var f float64 &#x3D; float64(i)</span><br><span class="line">var u uint &#x3D; uint(f)</span><br></pre></td></tr></table></figure>
<p>或者，更加简单的形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i :&#x3D; 42</span><br><span class="line">f :&#x3D; float64(i)</span><br><span class="line">u :&#x3D; uint(f)</span><br></pre></td></tr></table></figure>
<p>与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     var x, y int &#x3D; 3, 4</span><br><span class="line">     var f float64 &#x3D; math.Sqrt(float64(x*x + y*y))</span><br><span class="line">     var z uint &#x3D; uint(f)</span><br><span class="line">     fmt.Println(x, y, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>在声明一个变量而不指定其类型时（即使用不带类型的 := 语法或 var = 表达式语法），变量的类型由右值推导得出<br>当右值声明了类型时，新变量的类型与其相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var i int</span><br><span class="line">j :&#x3D; i &#x2F;&#x2F; j 也是一个 int</span><br></pre></td></tr></table></figure>
<p>不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 int, float64 或 complex128 了，这取决于常量的精度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i :&#x3D; 42           &#x2F;&#x2F; int</span><br><span class="line">f :&#x3D; 3.142        &#x2F;&#x2F; float64</span><br><span class="line">g :&#x3D; 0.867 + 0.5i &#x2F;&#x2F; complex128</span><br></pre></td></tr></table></figure>
<p>尝试修改示例代码中 v 的初始值，并观察它是如何影响类型的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     v :&#x3D; 42</span><br><span class="line">     fmt.Printf(&quot;v is of type %T\n&quot;, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量的声明与变量类似，只不过是使用 <code>const</code> 关键字, 常量可以是字符、字符串、布尔值或数值, 常量不能用 <code>:=</code> 语法声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">const Pi &#x3D; 3.14</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     const World &#x3D; &quot;世界&quot;</span><br><span class="line">     fmt.Println(&quot;Hello&quot;, World)</span><br><span class="line">     fmt.Println(&quot;Happy&quot;, Pi, &quot;Day&quot;)</span><br><span class="line">     const Truth &#x3D; true</span><br><span class="line">     fmt.Println(&quot;Go rules?&quot;, Truth)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数值常量"><a href="#数值常量" class="headerlink" title="数值常量"></a>数值常量</h4><ul>
<li>数值常量是高精度的值</li>
<li>一个未指定类型的常量由上下文来决定其类型</li>
<li>int 类型最大可以存储一个 64 位的整数，有时会更小</li>
<li>int 可以存放最大64位的整数，根据平台不同有时会更少</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">     &#x2F;&#x2F; 将 1 左移 100 位来创建一个非常大的数字</span><br><span class="line">     &#x2F;&#x2F; 即这个数的二进制是 1 后面跟着 100 个 0</span><br><span class="line">     Big &#x3D; 1 &lt;&lt; 100</span><br><span class="line">     &#x2F;&#x2F; 再往右移 99 位，即 Small &#x3D; 1 &lt;&lt; 1，或者说 Small &#x3D; 2</span><br><span class="line">     Small &#x3D; Big &gt;&gt; 99</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func needInt(x int) int &#123; return x*10 + 1 &#125;</span><br><span class="line">func needFloat(x float64) float64 &#123;</span><br><span class="line">     return x * 0.1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     fmt.Println(needInt(Small))</span><br><span class="line">     fmt.Println(needFloat(Small))</span><br><span class="line">     fmt.Println(needFloat(Big))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>Go 只有一种循环结构：for 循环<br>基本的 for 循环由三部分组成，它们用分号隔开：</p>
<ul>
<li>初始化语句：在第一次迭代前执行</li>
<li>条件表达式：在每次迭代前求值</li>
<li>后置语句：在每次迭代的结尾执行</li>
</ul>
<p>初始化语句通常为一句短变量声明，该变量声明仅在 <code>for</code> 语句的作用域中可见,一旦条件表达式的布尔值为 false，循环迭代就会终止<br><strong>注意:</strong> Golang 和 <code>C、Java、JavaScript</code> 之类的语言不同，Go 的 <code>for</code> 语句后面的三个构成部分外没有小括号， 大括号 <code>&#123; &#125;</code> 则是必须的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     sum :&#x3D; 0</span><br><span class="line">     for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">         sum +&#x3D; i</span><br><span class="line">     &#125;</span><br><span class="line">     fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化语句和后置语句是可选的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     sum :&#x3D; 1</span><br><span class="line">     for ; sum &lt; 1000; &#123;</span><br><span class="line">         sum +&#x3D; sum</span><br><span class="line">     &#125;</span><br><span class="line">     fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for 是 Go 中的 <code>while</code>, 此时你可以去掉分号，因为 C 的 while 在 Go 中叫做 for</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     sum :&#x3D; 1</span><br><span class="line">     for sum &lt; 1000 &#123;</span><br><span class="line">         sum +&#x3D; sum</span><br><span class="line">     &#125;</span><br><span class="line">     fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><p>如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     for &#123;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>Go 的 if 语句与 for 循环类似，表达式外无需小括号 <code>( )</code> ，而大括号 <code>&#123; &#125;</code> 则是必须的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func sqrt(x float64) string &#123;</span><br><span class="line">     if x &lt; 0 &#123;</span><br><span class="line">         return sqrt(-x) + &quot;i&quot;</span><br><span class="line">     &#125;</span><br><span class="line">     return fmt.Sprint(math.Sqrt(x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     fmt.Println(sqrt(2), sqrt(-4))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="if-的简短语句"><a href="#if-的简短语句" class="headerlink" title="if 的简短语句"></a>if 的简短语句</h4><p>同 for 一样， if 语句可以在条件表达式前执行一个简单的语句, 该语句声明的变量作用域仅在 if 之内</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func pow(x, n, lim float64) float64 &#123;</span><br><span class="line">     if v :&#x3D; math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">         return v</span><br><span class="line">     &#125;</span><br><span class="line">     return lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     fmt.Println(</span><br><span class="line">         pow(3, 2, 10),</span><br><span class="line">         pow(3, 3, 20),</span><br><span class="line">     )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="if-和-else"><a href="#if-和-else" class="headerlink" title="if 和 else"></a>if 和 else</h4><p>在 <code>if</code> 的简短语句中声明的变量同样可以在任何对应的 <code>else</code> 块中使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func pow(x, n, lim float64) float64 &#123;</span><br><span class="line">     if v :&#x3D; math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">         return v</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         fmt.Printf(&quot;%g &gt;&#x3D; %g\n&quot;, v, lim)</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F; 这里开始就不能使用 v 了</span><br><span class="line">     return lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     fmt.Println(</span><br><span class="line">         pow(3, 2, 10),</span><br><span class="line">         pow(3, 3, 20),</span><br><span class="line">     )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p><code>switch</code> 是编写一连串 <code>if - else</code> 语句的简便方法。它运行第一个值等于条件表达式的 <code>case</code> 语句<br>Go 的 <code>switch</code> 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 break 语句。 除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;runtime&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     fmt.Print(&quot;Go runs on &quot;)</span><br><span class="line">     switch os :&#x3D; runtime.GOOS; os &#123;</span><br><span class="line">         case &quot;darwin&quot;:</span><br><span class="line">             fmt.Println(&quot;OS X.&quot;)</span><br><span class="line">         case &quot;linux&quot;:</span><br><span class="line">             fmt.Println(&quot;Linux.&quot;)</span><br><span class="line">         default:</span><br><span class="line">             &#x2F;&#x2F; freebsd, openbsd,</span><br><span class="line">             &#x2F;&#x2F; plan9, windows...</span><br><span class="line">             fmt.Printf(&quot;%s.\n&quot;, os)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="switch-的求值顺序"><a href="#switch-的求值顺序" class="headerlink" title="switch 的求值顺序"></a>switch 的求值顺序</h4><p>switch 的 case 语句从上到下顺次执行，直到匹配成功时停止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     fmt.Println(&quot;When&#39;s Saturday?&quot;)</span><br><span class="line">     today :&#x3D; time.Now().Weekday()</span><br><span class="line">     switch time.Saturday &#123;</span><br><span class="line">         case today + 0:</span><br><span class="line">             fmt.Println(&quot;Today.&quot;)</span><br><span class="line">         case today + 1:</span><br><span class="line">             fmt.Println(&quot;Tomorrow.&quot;)</span><br><span class="line">         case today + 2:</span><br><span class="line">             fmt.Println(&quot;In two days.&quot;)</span><br><span class="line">         default:</span><br><span class="line">             fmt.Println(&quot;Too far away.&quot;)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="没有条件的-switch"><a href="#没有条件的-switch" class="headerlink" title="没有条件的 switch"></a>没有条件的 switch</h4><p>没有条件的 switch 同 switch true 一样, 这种形式能将一长串 <code>if-then-else</code> 写得更加清晰</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     t :&#x3D; time.Now()</span><br><span class="line">     switch &#123;</span><br><span class="line">         case t.Hour() &lt; 12:</span><br><span class="line">             fmt.Println(&quot;Good morning!&quot;)</span><br><span class="line">         case t.Hour() &lt; 17:</span><br><span class="line">             fmt.Println(&quot;Good afternoon.&quot;)</span><br><span class="line">         default:</span><br><span class="line">             fmt.Println(&quot;Good evening.&quot;)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>defer 语句会将函数推迟到外层函数返回之后执行, <strong>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     defer fmt.Println(&quot;world&quot;)</span><br><span class="line">     fmt.Println(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="defer-栈"><a href="#defer-栈" class="headerlink" title="defer 栈"></a>defer 栈</h4><p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     fmt.Println(&quot;counting&quot;)</span><br><span class="line"></span><br><span class="line">     for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">         defer fmt.Println(i)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     fmt.Println(&quot;done&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>Go 拥有指针。指针保存了值的内存地址</p>
<p>类型 <code>*T</code> 是指向 <code>T</code> 类型值的指针。其零值为 <code>nil</code>, <code>var p *int</code></p>
<p><code>&amp;</code> 操作符会生成一个指向其操作数的指针<br><code>i := 42</code>, <code>p = &amp;i</code>(&amp;相当于 取地址符，把 i 的内存地址取出来，赋值给 p，*p相当于通过p中存储的地址取到相应的值，所以 *p = 21)<br><code>*</code> 操作符表示指针指向的底层值。</p>
<p><code>fmt.Println(*p) // 通过指针 p 读取 i</code>, <code>*p = 21         // 通过指针 p 设置 i</code><br>这也就是通常所说的<strong>间接引用</strong></p>
<p>与 C 不同，Go 没有指针运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     i, j :&#x3D; 42, 2701</span><br><span class="line"></span><br><span class="line">     p :&#x3D; &amp;i &#x2F;&#x2F; 指向 i</span><br><span class="line">     fmt.Println(*p) &#x2F;&#x2F; 通过指针读取 i 的值</span><br><span class="line">     *p &#x3D; 21 &#x2F;&#x2F; 通过指针设置 i 的值</span><br><span class="line">     fmt.Println(i) &#x2F;&#x2F; 查看 i 的值</span><br><span class="line"></span><br><span class="line">     p &#x3D; &amp;j &#x2F;&#x2F; 指向 j</span><br><span class="line">     *p &#x3D; *p &#x2F; 37 &#x2F;&#x2F; 通过指针对 j 进行除法运算</span><br><span class="line">     fmt.Println(j) &#x2F;&#x2F; 查看 j 的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>一个结构体就是一组字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">     X int</span><br><span class="line">     Y int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     fmt.Println(Vertex&#123;1, 2&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结构体字段使用点号来访问"><a href="#结构体字段使用点号来访问" class="headerlink" title="结构体字段使用点号来访问"></a>结构体字段使用点号来访问</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">     X int</span><br><span class="line">     Y int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     v :&#x3D; Vertex&#123;1, 2&#125;</span><br><span class="line">     v.X &#x3D; 4</span><br><span class="line">     fmt.Println(v.X)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><p>结构体字段可以通过结构体指针来访问<br>如果我们有一个指向结构体的指针 p，那么可以通过 (*p).X 来访问其字段 X。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 p.X 就可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">     X int</span><br><span class="line">     Y int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     v :&#x3D; Vertex&#123;1, 2&#125;</span><br><span class="line">     p :&#x3D; &amp;v</span><br><span class="line">     p.X &#x3D; 1e9</span><br><span class="line">     fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结构体文法"><a href="#结构体文法" class="headerlink" title="结构体文法"></a>结构体文法</h4><p>结构体文法通过直接列出字段的值来新分配一个结构体</p>
<p>特殊的前缀 <code>&amp;</code> 返回一个指向结构体的指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">     X, Y int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">     v1 &#x3D; Vertex&#123;1, 2&#125; &#x2F;&#x2F; 创建一个 Vertex 类型的结构体</span><br><span class="line">     v2 &#x3D; Vertex&#123;X: 1&#125; &#x2F;&#x2F; Y:0 被隐式地赋予</span><br><span class="line">     v3 &#x3D; Vertex&#123;&#125; &#x2F;&#x2F; X:0 Y:0</span><br><span class="line">     p &#x3D; &amp;Vertex&#123;1, 2&#125; &#x2F;&#x2F; 创建一个 *Vertex 类型的结构体（指针）</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     fmt.Println(v1, p, v2, v3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>类型 <code>[n]T</code> 表示拥有 n 个 T 类型的值的数组<br>表达式 <code>var a [10]int</code>, 会将变量 a 声明为拥有 10 个整数的数组</p>
<p>数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     var a [2]string</span><br><span class="line">     a[0] &#x3D; &quot;Hello&quot;</span><br><span class="line">     a[1] &#x3D; &quot;World&quot;</span><br><span class="line">     fmt.Println(a[0], a[1])</span><br><span class="line">     fmt.Println(a)</span><br><span class="line"></span><br><span class="line">     primes :&#x3D; [6]int&#123;2, 3, 5, 7, 11, 13&#125;</span><br><span class="line">     fmt.Println(primes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用<br>类型 <code>[]T</code> 表示一个元素类型为 T 的切片, 切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔, <code>a[low : high]</code>, 它会选择一个半开区间，包括第一个元素，但排除最后一个元素<br>以下表达式创建了一个切片，它包含 a 中下标从 1 到 3 的元素：<code>a[1:4]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     primes :&#x3D; [6]int&#123;2, 3, 5, 7, 11, 13&#125;</span><br><span class="line"></span><br><span class="line">     var s []int &#x3D; primes[1:4]</span><br><span class="line">     fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="切片就像数组的引用"><a href="#切片就像数组的引用" class="headerlink" title="切片就像数组的引用"></a>切片就像数组的引用</h4><p>切片并不存储任何数据，它只是描述了底层数组中的一段, 更改切片的元素会修改其底层数组中对应的元素, 与它共享底层数组的切片都会观测到这些修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     names :&#x3D; [4]string&#123;</span><br><span class="line">         &quot;John&quot;,</span><br><span class="line">         &quot;Paul&quot;,</span><br><span class="line">         &quot;George&quot;,</span><br><span class="line">         &quot;Ringo&quot;,</span><br><span class="line">     &#125;</span><br><span class="line">     fmt.Println(names)</span><br><span class="line"></span><br><span class="line">     a :&#x3D; names[0:2]</span><br><span class="line">     b :&#x3D; names[1:3]</span><br><span class="line">     fmt.Println(a, b)</span><br><span class="line"></span><br><span class="line">     b[0] &#x3D; &quot;XXX&quot;</span><br><span class="line">     fmt.Println(a, b)</span><br><span class="line">     fmt.Println(names)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="切片文法"><a href="#切片文法" class="headerlink" title="切片文法"></a>切片文法</h4><p>切片文法类似于没有长度的数组文法</p>
<p>这是一个数组文法：<code>[3]bool&#123;true, true, false&#125;</code></p>
<p>下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片, <code>[]bool&#123;true, true, false&#125;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     q :&#x3D; []int&#123;2, 3, 5, 7, 11, 13&#125;</span><br><span class="line">     fmt.Println(q)</span><br><span class="line"></span><br><span class="line">     r :&#x3D; []bool&#123;true, false, true, true, false, true&#125;</span><br><span class="line">     fmt.Println(r)</span><br><span class="line"></span><br><span class="line">     s :&#x3D; []struct &#123;</span><br><span class="line">         i int</span><br><span class="line">         b bool</span><br><span class="line">     &#125;&#123;</span><br><span class="line">         &#123;2, true&#125;,</span><br><span class="line">         &#123;3, false&#125;,</span><br><span class="line">         &#123;5, true&#125;,</span><br><span class="line">         &#123;7, true&#125;,</span><br><span class="line">         &#123;11, false&#125;,</span><br><span class="line">         &#123;13, true&#125;,</span><br><span class="line">     &#125;</span><br><span class="line">     fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="切片的默认行为"><a href="#切片的默认行为" class="headerlink" title="切片的默认行为"></a>切片的默认行为</h4><p>在进行切片时，你可以利用它的默认行为来忽略上下界, 切片下界的默认值为 0，上界则是该切片的长度<br>对于数组 <code>var a [10]int</code>, 来说，以下切片是等价的：<code>a[0:10]</code>, <code>a[:10]</code>, <code>a[0:]</code>, <code>a[:]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     s :&#x3D; []int&#123;2, 3, 5, 7, 11, 13&#125;</span><br><span class="line"></span><br><span class="line">     s &#x3D; s[1:4]</span><br><span class="line">     fmt.Println(s)</span><br><span class="line"></span><br><span class="line">     s &#x3D; s[:2]</span><br><span class="line">     fmt.Println(s)</span><br><span class="line"></span><br><span class="line">     s &#x3D; s[1:]</span><br><span class="line">     fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="切片的长度与容量"><a href="#切片的长度与容量" class="headerlink" title="切片的长度与容量"></a>切片的长度与容量</h4><p>切片拥有 长度 和 容量, 切片的长度就是它所包含的元素个数。切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。切片 s 的长度和容量可通过表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     s :&#x3D; []int&#123;2, 3, 5, 7, 11, 13&#125;</span><br><span class="line">     printSlice(s)</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 截取切片使其长度为 0</span><br><span class="line">     s &#x3D; s[:0]</span><br><span class="line">     printSlice(s)</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 拓展其长度</span><br><span class="line">     s &#x3D; s[:4]</span><br><span class="line">     printSlice(s)</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 舍弃前两个值</span><br><span class="line">     s &#x3D; s[2:]</span><br><span class="line">     printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printSlice(s []int) &#123;</span><br><span class="line">     fmt.Printf(&quot;len&#x3D;%d cap&#x3D;%d %v\n&quot;, len(s), cap(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="nil-切片"><a href="#nil-切片" class="headerlink" title="nil 切片"></a>nil 切片</h4><p>切片的零值是 nil, nil 切片的长度和容量为 0 且没有底层数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     var s []int</span><br><span class="line">     fmt.Println(s, len(s), cap(s))</span><br><span class="line">     if s &#x3D;&#x3D; nil &#123;</span><br><span class="line">         fmt.Println(&quot;nil!&quot;)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="用-make-创建切片"><a href="#用-make-创建切片" class="headerlink" title="用 make 创建切片"></a>用 make 创建切片</h4><p>切片可以用内建函数 <code>make</code> 来创建，这也是你创建动态数组的方式, <code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：<code>a := make([]int, 5)</code>, 要指定它的容量，需向 <code>make</code> 传入第三个参数：<code>b := make([]int, 0, 5)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b &#x3D; b[:cap(b)]  &#x2F;&#x2F; len(b)&#x3D;5, cap(b)&#x3D;5</span><br><span class="line">b &#x3D; b[1:]       &#x2F;&#x2F; len(b)&#x3D;4, cap(b)&#x3D;4</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     a :&#x3D; make([]int, 5)</span><br><span class="line">     printSlice(&quot;a&quot;, a)</span><br><span class="line"></span><br><span class="line">     b :&#x3D; make([]int, 0, 5)</span><br><span class="line">     printSlice(&quot;b&quot;, b)</span><br><span class="line"></span><br><span class="line">     c :&#x3D; b[:2]</span><br><span class="line">     printSlice(&quot;c&quot;, c)</span><br><span class="line"></span><br><span class="line">     d :&#x3D; c[2:5]</span><br><span class="line">     printSlice(&quot;d&quot;, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printSlice(s string, x []int) &#123;</span><br><span class="line">     fmt.Printf(&quot;%s len&#x3D;%d cap&#x3D;%d %v\n&quot;,</span><br><span class="line">     s, len(x), cap(x), x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="切片的切片"><a href="#切片的切片" class="headerlink" title="切片的切片"></a>切片的切片</h4><p>切片可包含任何类型，甚至包括其它的切片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     &#x2F;&#x2F; 创建一个井字板（经典游戏）</span><br><span class="line">     board :&#x3D; [][]string&#123;</span><br><span class="line">         []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;,</span><br><span class="line">         []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;,</span><br><span class="line">         []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;,</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 两个玩家轮流打上 X 和 O</span><br><span class="line">     board[0][0] &#x3D; &quot;X&quot;</span><br><span class="line">     board[2][2] &#x3D; &quot;O&quot;</span><br><span class="line">     board[1][2] &#x3D; &quot;X&quot;</span><br><span class="line">     board[1][0] &#x3D; &quot;O&quot;</span><br><span class="line">     board[0][2] &#x3D; &quot;X&quot;</span><br><span class="line"></span><br><span class="line">     for i :&#x3D; 0; i &lt; len(board); i++ &#123;</span><br><span class="line">         fmt.Printf(&quot;%s\n&quot;, strings.Join(board[i], &quot; &quot;))</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="向切片追加元素"><a href="#向切片追加元素" class="headerlink" title="向切片追加元素"></a>向切片追加元素</h4><p>为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 <code>append</code> 函数<br><code>append</code> 的第一个参数 s 是一个元素类型为 T 的切片，其余类型为 T 的值将会追加到该切片的末尾, <code>append</code> 的结果是一个包含原切片所有元素加上新添加元素的切片, 当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     var s []int</span><br><span class="line">     printSlice(s)</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 添加一个空切片</span><br><span class="line">     s &#x3D; append(s, 0)</span><br><span class="line">     printSlice(s)</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 这个切片会按需增长</span><br><span class="line">     s &#x3D; append(s, 1)</span><br><span class="line">     printSlice(s)</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 可以一次性添加多个元素</span><br><span class="line">     s &#x3D; append(s, 2, 3, 4)</span><br><span class="line">     printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printSlice(s []int) &#123;</span><br><span class="line">     fmt.Printf(&quot;len&#x3D;%d cap&#x3D;%d %v\n&quot;, len(s), cap(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>for 循环的 <code>range</code> 形式可遍历切片或映射, 当使用 for 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">var pow &#x3D; []int&#123;1, 2, 4, 8, 16, 32, 64, 128&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     for i, v :&#x3D; range pow &#123;</span><br><span class="line">         fmt.Printf(&quot;2**%d &#x3D; %d\n&quot;, i, v)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将下标或值赋予 <code>_</code> 来忽略它, 若你只需要索引，去掉 , value 的部分即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     pow :&#x3D; make([]int, 10)</span><br><span class="line">     for i :&#x3D; range pow &#123;</span><br><span class="line">         pow[i] &#x3D; 1 &lt;&lt; uint(i) &#x2F;&#x2F; &#x3D;&#x3D; 2**i</span><br><span class="line">     &#125;</span><br><span class="line">     for _, value :&#x3D; range pow &#123;</span><br><span class="line">         fmt.Printf(&quot;%d\n&quot;, value)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="映射–-gt-字典"><a href="#映射–-gt-字典" class="headerlink" title="映射–&gt;字典"></a>映射–&gt;字典</h3><p>映射将键映射到值, 映射的零值为 nil 。nil 映射既没有键，也不能添加键</p>
<p><code>make</code> 函数会返回给定类型的映射，并将其初始化备用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">     Lat, Long float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var m map[string]Vertex</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     m &#x3D; make(map[string]Vertex)</span><br><span class="line">     m[&quot;Bell Labs&quot;] &#x3D; Vertex&#123;</span><br><span class="line">         40.68433, -74.39967,</span><br><span class="line">     &#125;</span><br><span class="line">     fmt.Println(m[&quot;Bell Labs&quot;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>映射的文法与结构体相似，不过必须有键名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">     Lat, Long float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var m &#x3D; map[string]Vertex&#123;</span><br><span class="line">     &quot;Bell Labs&quot;: Vertex&#123;</span><br><span class="line">     40.68433, -74.39967,</span><br><span class="line"> &#125;,</span><br><span class="line">     &quot;Google&quot;: Vertex&#123;</span><br><span class="line">         37.42202, -122.08408,</span><br><span class="line">     &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若顶级类型只是一个类型名，你可以在文法的元素中省略它</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">     Lat, Long float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var m &#x3D; map[string]Vertex&#123;</span><br><span class="line">     &quot;Bell Labs&quot;: &#123;40.68433, -74.39967&#125;,</span><br><span class="line">     &quot;Google&quot;: &#123;37.42202, -122.08408&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修改映射"><a href="#修改映射" class="headerlink" title="修改映射"></a>修改映射</h4><ul>
<li>在映射 <code>m</code> 中插入或修改元素：<code>m[key] = elem</code></li>
<li>获取元素：<code>elem = m[key]</code></li>
<li>删除元素：<code>delete(m, key)</code></li>
</ul>
<p>通过双赋值检测某个键是否存在：<code>elem, ok = m[key]</code>, 若 key 在 m 中，ok 为 true ；否则，ok 为 false, 若 key 不在映射中，那么 elem 是该映射元素类型的零值</p>
<p>同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值</p>
<p>若 elem 或 ok 还未声明，你可以使用短变量声明：<code>elem, ok := m[key]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     m :&#x3D; make(map[string]int)</span><br><span class="line"></span><br><span class="line">     m[&quot;Answer&quot;] &#x3D; 42</span><br><span class="line">     fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;])</span><br><span class="line"></span><br><span class="line">     m[&quot;Answer&quot;] &#x3D; 48</span><br><span class="line">     fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;])</span><br><span class="line"></span><br><span class="line">     delete(m, &quot;Answer&quot;)</span><br><span class="line">     fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;])</span><br><span class="line"></span><br><span class="line">     v, ok :&#x3D; m[&quot;Answer&quot;]</span><br><span class="line">     fmt.Println(&quot;The value:&quot;, v, &quot;Present?&quot;, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h3><p>函数也是值。它们可以像其它值一样传递, 函数值可以用作函数的参数或返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func compute(fn func(float64, float64) float64) float64 &#123;</span><br><span class="line">     return fn(3, 4)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     hypot :&#x3D; func(x, y float64) float64 &#123;</span><br><span class="line">         return math.Sqrt(x*x + y*y)</span><br><span class="line">     &#125;</span><br><span class="line">     fmt.Println(hypot(5, 12))</span><br><span class="line"></span><br><span class="line">     fmt.Println(compute(hypot))</span><br><span class="line">     fmt.Println(compute(math.Pow))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数的闭包"><a href="#函数的闭包" class="headerlink" title="函数的闭包"></a>函数的闭包</h3><p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被<strong>绑定</strong>在了这些变量上</p>
<p>例如，函数 adder 返回一个闭包。每个闭包都被绑定在其各自的 sum 变量上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func adder() func(int) int &#123;</span><br><span class="line">     sum :&#x3D; 0</span><br><span class="line">     return func(x int) int &#123;</span><br><span class="line">         sum +&#x3D; x</span><br><span class="line">         return sum</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     pos, neg :&#x3D; adder(), adder()</span><br><span class="line">     for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">         fmt.Println(</span><br><span class="line">             pos(i),</span><br><span class="line">             neg(-2*i),</span><br><span class="line">         )</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Go 没有类。不过你可以为结构体类型定义方法, 方法就是一类带特殊的 <strong>接收者</strong> 参数的函数, 方法接收者在它自己的参数列表内，位于 <code>func</code> 关键字和方法名之间</p>
<p>在此例中，Abs 方法拥有一个名为 v，类型为 Vertex 的接收者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">     X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v Vertex) Abs() float64 &#123;</span><br><span class="line">     return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     v :&#x3D; Vertex&#123;3, 4&#125;</span><br><span class="line">     fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法即函数"><a href="#方法即函数" class="headerlink" title="方法即函数"></a>方法即函数</h4><p>方法只是个带接收者参数的函数, 现在这个 Abs 的写法就是个正常的函数，功能并没有什么变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">     X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Abs(v Vertex) float64 &#123;</span><br><span class="line">     return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     v :&#x3D; Vertex&#123;3, 4&#125;</span><br><span class="line">     fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以为非结构体类型声明方法, 在此例中，我们看到了一个带 Abs 方法的数值类型 MyFloat</p>
<p>只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 int 之类的内建类型）的接收者声明方法, 就是接收者的类型定义和方法声明必须在同一包内, 不能为内建类型声明方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type MyFloat float64</span><br><span class="line"></span><br><span class="line">func (f MyFloat) Abs() float64 &#123;</span><br><span class="line">     if f &lt; 0 &#123;</span><br><span class="line">         return float64(-f)</span><br><span class="line">     &#125;</span><br><span class="line">     return float64(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     f :&#x3D; MyFloat(-math.Sqrt2)</span><br><span class="line">     fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h4><p>你可以为指针接收者声明方法, 这意味着对于某类型 T，接收者的类型可以用 *T 的文法</p>
<p>例如，这里为 <code>*Vertex</code> 定义了 <code>Scale</code> 方法, 指针接收者的方法可以修改接收者指向的值。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用</p>
<p>若使用值接收者，那么 Scale 方法会对原始 Vertex 值的副本进行操作, Scale 方法必须用指针接受者来更改 main 函数中声明的 Vertex 的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">     X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v Vertex) Abs() float64 &#123;</span><br><span class="line">     return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v *Vertex) Scale(f float64) &#123;</span><br><span class="line">     v.X &#x3D; v.X * f</span><br><span class="line">     v.Y &#x3D; v.Y * f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h3><p>现在我们要把 <code>Abs</code> 和 <code>Scale</code> 方法重写为函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">     X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Abs(v Vertex) float64 &#123;</span><br><span class="line">     return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Scale(v *Vertex, f float64) &#123;</span><br><span class="line">     v.X &#x3D; v.X * f</span><br><span class="line">     v.Y &#x3D; v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     v :&#x3D; Vertex&#123;3, 4&#125;</span><br><span class="line">     Scale(&amp;v, 10)</span><br><span class="line">     fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法与指针重定向"><a href="#方法与指针重定向" class="headerlink" title="方法与指针重定向"></a>方法与指针重定向</h4><p>比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var v Vertex</span><br><span class="line">ScaleFunc(v, 5)  &#x2F;&#x2F; 编译错误！</span><br><span class="line">ScaleFunc(&amp;v, 5) &#x2F;&#x2F; OK</span><br></pre></td></tr></table></figure>
<p>而以指针为接收者的方法被调用时，接收者既能为值又能为指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var v Vertex</span><br><span class="line">v.Scale(5)  &#x2F;&#x2F; OK</span><br><span class="line">p :&#x3D; &amp;v</span><br><span class="line">p.Scale(10) &#x2F;&#x2F; OK</span><br></pre></td></tr></table></figure>
<p>对于语句 <code>v.Scale(5)</code>，即便 v 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 <code>Scale</code> 方法有一个指针接收者，为方便起见，Go 会将语句 <code>v.Scale(5)</code> 解释为 <code>(&amp;v).Scale(5)。</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">     X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v *Vertex) Scale(f float64) &#123;</span><br><span class="line">     v.X &#x3D; v.X * f</span><br><span class="line">     v.Y &#x3D; v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func ScaleFunc(v *Vertex, f float64) &#123;</span><br><span class="line">     v.X &#x3D; v.X * f</span><br><span class="line">     v.Y &#x3D; v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     v :&#x3D; Vertex&#123;3, 4&#125;</span><br><span class="line">     v.Scale(2)</span><br><span class="line">     ScaleFunc(&amp;v, 10)</span><br><span class="line"></span><br><span class="line">     p :&#x3D; &amp;Vertex&#123;4, 3&#125;</span><br><span class="line">     p.Scale(3)</span><br><span class="line">     ScaleFunc(p, 8)</span><br><span class="line"></span><br><span class="line">     fmt.Println(v, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的事情也发生在相反的方向, 接受一个值作为参数的函数必须接受一个指定类型的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var v Vertex</span><br><span class="line">fmt.Println(AbsFunc(v))  &#x2F;&#x2F; OK</span><br><span class="line">fmt.Println(AbsFunc(&amp;v)) &#x2F;&#x2F; 编译错误！</span><br></pre></td></tr></table></figure>
<p>而以值为接收者的方法被调用时，接收者既能为值又能为指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var v Vertex</span><br><span class="line">fmt.Println(v.Abs()) &#x2F;&#x2F; OK</span><br><span class="line">p :&#x3D; &amp;v</span><br><span class="line">fmt.Println(p.Abs()) &#x2F;&#x2F; OK</span><br></pre></td></tr></table></figure>
<p>这种情况下，方法调用 <code>p.Abs()</code> 会被解释为 <code>(*p).Abs()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">     X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v Vertex) Abs() float64 &#123;</span><br><span class="line">     return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func AbsFunc(v Vertex) float64 &#123;</span><br><span class="line">     return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     v :&#x3D; Vertex&#123;3, 4&#125;</span><br><span class="line">     fmt.Println(v.Abs())</span><br><span class="line">     fmt.Println(AbsFunc(v))</span><br><span class="line"></span><br><span class="line">     p :&#x3D; &amp;Vertex&#123;4, 3&#125;</span><br><span class="line">     fmt.Println(p.Abs())</span><br><span class="line">     fmt.Println(AbsFunc(*p))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择值或指针作为接收者"><a href="#选择值或指针作为接收者" class="headerlink" title="选择值或指针作为接收者"></a>选择值或指针作为接收者</h3><p>使用指针接收者的原因有二：</p>
<ul>
<li>首先，方法能够修改其接收者指向的值。</li>
<li>其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效<br>在本例中，<code>Scale</code> 和 <code>Abs</code> 接收者的类型为 <code>*Vertex</code>，即便 Abs 并不需要修改其接收者, 通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">     X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v *Vertex) Scale(f float64) &#123;</span><br><span class="line">     v.X &#x3D; v.X * f</span><br><span class="line">     v.Y &#x3D; v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v *Vertex) Abs() float64 &#123;</span><br><span class="line">     return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     v :&#x3D; &amp;Vertex&#123;3, 4&#125;</span><br><span class="line">     fmt.Printf(&quot;Before scaling: %+v, Abs: %v\n&quot;, v, v.Abs())</span><br><span class="line">     v.Scale(5)</span><br><span class="line">     fmt.Printf(&quot;After scaling: %+v, Abs: %v\n&quot;, v, v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口类型 是由一组方法签名定义的集合, 接口类型的变量可以保存任何实现了这些方法的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Abser interface &#123;</span><br><span class="line">     Abs() float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     var a Abser</span><br><span class="line">     f :&#x3D; MyFloat(-math.Sqrt2)</span><br><span class="line">     v :&#x3D; Vertex&#123;3, 4&#125;</span><br><span class="line"></span><br><span class="line">     a &#x3D; f &#x2F;&#x2F; a MyFloat 实现了 Abser</span><br><span class="line">     a &#x3D; &amp;v &#x2F;&#x2F; a *Vertex 实现了 Abser</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 下面一行，v 是一个 Vertex（而不是 *Vertex）</span><br><span class="line">     &#x2F;&#x2F; 所以没有实现 Abser。</span><br><span class="line">     a &#x3D; v</span><br><span class="line"></span><br><span class="line">     fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MyFloat float64</span><br><span class="line"></span><br><span class="line">func (f MyFloat) Abs() float64 &#123;</span><br><span class="line">     if f &lt; 0 &#123;</span><br><span class="line">         return float64(-f)</span><br><span class="line">     &#125;</span><br><span class="line">     return float64(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">     X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v *Vertex) Abs() float64 &#123;</span><br><span class="line">     return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接口与隐式实现"><a href="#接口与隐式实现" class="headerlink" title="接口与隐式实现"></a>接口与隐式实现</h4><p>类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有<code>implements</code>关键字, 隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备, 因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type I interface &#123;</span><br><span class="line">     M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type T struct &#123;</span><br><span class="line">     S string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。</span><br><span class="line">func (t T) M() &#123;</span><br><span class="line">     fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     var i I &#x3D; T&#123;&quot;hello&quot;&#125;</span><br><span class="line">     i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h4><p>接口也是值。它们可以像其它值一样传递, 接口值可以用作函数的参数或返回值<br>在内部，接口值可以看做包含值和具体类型的元组：(value, type)<br>接口值保存了一个具体底层类型的具体值, 接口值调用方法时会执行其底层类型的同名方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type I interface &#123;</span><br><span class="line">     M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type T struct &#123;</span><br><span class="line">     S string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *T) M() &#123;</span><br><span class="line">     fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type F float64</span><br><span class="line"></span><br><span class="line">func (f F) M() &#123;</span><br><span class="line">     fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     var i I</span><br><span class="line"></span><br><span class="line">     i &#x3D; &amp;T&#123;&quot;Hello&quot;&#125;</span><br><span class="line">     describe(i)</span><br><span class="line">     i.M()</span><br><span class="line"></span><br><span class="line">     i &#x3D; F(math.Pi)</span><br><span class="line">     describe(i)</span><br><span class="line">     i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func describe(i I) &#123;</span><br><span class="line">     fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="底层值为-nil-的接口值"><a href="#底层值为-nil-的接口值" class="headerlink" title="底层值为 nil 的接口值"></a>底层值为 nil 的接口值</h4><p>即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用, 在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它</p>
<p><strong>保存了 nil 具体值的接口其自身并不为 nil</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type I interface &#123;</span><br><span class="line">     M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type T struct &#123;</span><br><span class="line">     S string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *T) M() &#123;</span><br><span class="line">     if t &#x3D;&#x3D; nil &#123;</span><br><span class="line">         fmt.Println(&quot;&lt;nil&gt;&quot;)</span><br><span class="line">         return</span><br><span class="line">     &#125;</span><br><span class="line">     fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     var i I</span><br><span class="line"></span><br><span class="line">     var t *T</span><br><span class="line">     i &#x3D; t</span><br><span class="line">     describe(i)</span><br><span class="line">     i.M()</span><br><span class="line"></span><br><span class="line">     i &#x3D; &amp;T&#123;&quot;hello&quot;&#125;</span><br><span class="line">     describe(i)</span><br><span class="line">     i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func describe(i I) &#123;</span><br><span class="line">     fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="nil-接口值"><a href="#nil-接口值" class="headerlink" title="nil 接口值"></a>nil 接口值</h4><p>nil 接口值既不保存值也不保存具体类型, 为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个具体方法的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type I interface &#123;</span><br><span class="line">     M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     var i I</span><br><span class="line">     describe(i)</span><br><span class="line">     i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func describe(i I) &#123;</span><br><span class="line">     fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><p>指定了零个方法的接口值被称为 <em>空接口</em> <code>interface&#123;&#125;</code>, 空接口可保存任何类型的值, 因为每个类型都至少实现了零个方法</p>
<p>空接口被用来处理未知类型的值。例如，fmt.Print 可接受类型为 interface{} 的任意数量的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     var i interface&#123;&#125;</span><br><span class="line">     describe(i)</span><br><span class="line"></span><br><span class="line">     i &#x3D; 42</span><br><span class="line">     describe(i)</span><br><span class="line"></span><br><span class="line">     i &#x3D; &quot;hello&quot;</span><br><span class="line">     describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func describe(i interface&#123;&#125;) &#123;</span><br><span class="line">     fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>类型断言 提供了访问接口值底层具体值的方式,<code>t := i.(T)</code>, 该语句断言接口值 i 保存了具体类型 T，并将其底层类型为 T 的值赋予变量 t, 若 i 并未保存 T 类型的值，该语句就会触发一个恐慌</p>
<p>为了 判断 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值 <code>t, ok := i.(T)</code>, 若 i 保存了一个 T，那么 t 将会是其底层值，而 ok 为 true, 否则，ok 将为 false 而 t 将为 T 类型的零值，程序并不会产生恐慌. 请注意这种语法和读取一个映射时的相同之处</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     var i interface&#123;&#125; &#x3D; &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">     s :&#x3D; i.(string)</span><br><span class="line">     fmt.Println(s)</span><br><span class="line"></span><br><span class="line">     s, ok :&#x3D; i.(string)</span><br><span class="line">     fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">     f, ok :&#x3D; i.(float64)</span><br><span class="line">     fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">     f &#x3D; i.(float64) &#x2F;&#x2F; 报错(panic)</span><br><span class="line">     fmt.Println(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h4><p>类型选择 是一种按顺序从几个类型断言中选择分支的结构， 类型选择与一般的 <code>switch</code> 语句相似，不过类型选择中的 <code>case</code> 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch v :&#x3D; i.(type) &#123;</span><br><span class="line">     case T:</span><br><span class="line">         &#x2F;&#x2F; v 的类型为 T</span><br><span class="line">     case S:</span><br><span class="line">         &#x2F;&#x2F; v 的类型为 S</span><br><span class="line">     default:</span><br><span class="line">         &#x2F;&#x2F; 没有匹配，v 与 i 的类型相同</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型选择中的声明与类型断言 <code>i.(T)</code> 的语法相同，只是具体类型 T 被替换成了关键字 <code>type</code>， 此选择语句判断接口值 i 保存的值类型是 T 还是 S。在 T 或 S的情况下，变量 v 会分别按 T 或 S 类型保存 i 拥有的值。在默认(即没有匹配)的情况下，变量 v 与 i 的接口类型和值相同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func do(i interface&#123;&#125;) &#123;</span><br><span class="line">     switch v :&#x3D; i.(type) &#123;</span><br><span class="line">         case int:</span><br><span class="line">             fmt.Printf(&quot;Twice %v is %v\n&quot;, v, v*2)</span><br><span class="line">         case string:</span><br><span class="line">             fmt.Printf(&quot;%q is %v bytes long\n&quot;, v, len(v))</span><br><span class="line">         default:</span><br><span class="line">             fmt.Printf(&quot;I don&#39;t know about type %T!\n&quot;, v)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     do(21)</span><br><span class="line">     do(&quot;hello&quot;)</span><br><span class="line">     do(true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Go-程"><a href="#Go-程" class="headerlink" title="Go 程"></a>Go 程</h3><p>Go 程 goroutine是由 Go 运行时管理的轻量级线程, <code>go f(x, y, z)</code>, 会启动一个新的 Go 程并执行<code>f(x, y, z)</code></p>
<p>f, x, y 和 z 的求值发生在当前的 Go 程中，而 f 的执行发生在新的 Go 程中</p>
<p>Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。<code>sync</code> 包提供了这种能力，不过在 Go 中并不经常用到，因为还有其它的办法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func say(s string) &#123;</span><br><span class="line">     for i :&#x3D; 0; i &lt; 5; i++ &#123;</span><br><span class="line">         time.Sleep(100 * time.Millisecond)</span><br><span class="line">         fmt.Println(s)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     go say(&quot;world&quot;)</span><br><span class="line">     say(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>信道是带有类型的管道，你可以通过它用信道操作符 <code>&lt;-</code> 来发送或者接收值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    &#x2F;&#x2F; 将 v 发送至信道 ch。</span><br><span class="line">v :&#x3D; &lt;-ch  &#x2F;&#x2F; 从 ch 接收值并赋予 v。</span><br></pre></td></tr></table></figure>
<p>箭头就是数据流的方向</p>
<p>和映射与切片一样，信道在使用前必须创建：<code>ch := make(chan int)</code></p>
<p>默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步</p>
<p>以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func sum(s []int, c chan int) &#123;</span><br><span class="line">     sum :&#x3D; 0</span><br><span class="line">     for _, v :&#x3D; range s &#123;</span><br><span class="line">         sum +&#x3D; v</span><br><span class="line">     &#125;</span><br><span class="line">     c &lt;- sum &#x2F;&#x2F; 将和送入 c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     s :&#x3D; []int&#123;7, 2, 8, -9, 4, 0&#125;</span><br><span class="line"></span><br><span class="line">     c :&#x3D; make(chan int)</span><br><span class="line">     go sum(s[:len(s)&#x2F;2], c)</span><br><span class="line">     go sum(s[len(s)&#x2F;2:], c)</span><br><span class="line">     x, y :&#x3D; &lt;-c, &lt;-c &#x2F;&#x2F; 从 c 中接收</span><br><span class="line"></span><br><span class="line">     fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="带缓冲的信道"><a href="#带缓冲的信道" class="headerlink" title="带缓冲的信道"></a>带缓冲的信道</h4><p>信道可以是 带缓冲的。将缓冲长度作为第二个参数提供给 <code>make</code> 来初始化一个带缓冲的信道：<code>ch := make(chan int, 100)</code>, 仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     ch :&#x3D; make(chan int, 2)</span><br><span class="line">     ch &lt;- 1</span><br><span class="line">     ch &lt;- 2</span><br><span class="line">     fmt.Println(&lt;-ch)</span><br><span class="line">     fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="range-和-close"><a href="#range-和-close" class="headerlink" title="range 和 close"></a>range 和 close</h4><p>发送者可通过 <code>close</code> 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完 <code>v, ok := &lt;-ch</code>, 之后 ok 会被设置为 false, 循环 <code>for i := range c</code> 会不断从信道接收值，直到它被关闭</p>
<ul>
<li>只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）</li>
<li>信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func fibonacci(n int, c chan int) &#123;</span><br><span class="line">     x, y :&#x3D; 0, 1</span><br><span class="line">     for i :&#x3D; 0; i &lt; n; i++ &#123;</span><br><span class="line">         c &lt;- x</span><br><span class="line">         x, y &#x3D; y, x+y</span><br><span class="line">     &#125;</span><br><span class="line">     close(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     c :&#x3D; make(chan int, 10)</span><br><span class="line">     go fibonacci(cap(c), c)</span><br><span class="line">     for i :&#x3D; range c &#123;</span><br><span class="line">         fmt.Println(i)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h3><p><code>select</code> 语句使一个 Go 程可以等待多个通信操作, <code>select</code> 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func fibonacci(c, quit chan int) &#123;</span><br><span class="line">     x, y :&#x3D; 0, 1</span><br><span class="line">     for &#123;</span><br><span class="line">         select &#123;</span><br><span class="line">             case c &lt;- x:</span><br><span class="line">                 x, y &#x3D; y, x+y</span><br><span class="line">             case &lt;-quit:</span><br><span class="line">                 fmt.Println(&quot;quit&quot;)</span><br><span class="line">             return</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     c :&#x3D; make(chan int)</span><br><span class="line">     quit :&#x3D; make(chan int)</span><br><span class="line">     go func() &#123;</span><br><span class="line">         for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">             fmt.Println(&lt;-c)</span><br><span class="line">         &#125;</span><br><span class="line">     quit &lt;- 0</span><br><span class="line">     &#125;()</span><br><span class="line">     fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>select</code> 中的其它分支都没有准备好时，<code>default</code> 分支就会执行, 为了在尝试发送或者接收时不发生阻塞，可使用 <code>default</code> 分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">case i :&#x3D; &lt;-c:</span><br><span class="line">    &#x2F;&#x2F; 使用 i</span><br><span class="line">default:</span><br><span class="line">    &#x2F;&#x2F; 从 c 中接收会阻塞时执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     tick :&#x3D; time.Tick(100 * time.Millisecond)</span><br><span class="line">     boom :&#x3D; time.After(500 * time.Millisecond)</span><br><span class="line">     for &#123;</span><br><span class="line">         select &#123;</span><br><span class="line">             case &lt;-tick:</span><br><span class="line">                 fmt.Println(&quot;tick.&quot;)</span><br><span class="line">             case &lt;-boom:</span><br><span class="line">                 fmt.Println(&quot;BOOM!&quot;)</span><br><span class="line">             return</span><br><span class="line">             default:</span><br><span class="line">                 fmt.Println(&quot; .&quot;)</span><br><span class="line">                 time.Sleep(50 * time.Millisecond)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h3><p>我们已经看到信道非常适合在各个 Go 程间进行通信, 但是如果我们并不需要通信呢？比如说，若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？这里涉及的概念叫做 <strong>互斥</strong> ，我们通常使用 <strong>互斥锁</strong> 这一数据结构来提供这种机制</p>
<p>Go 标准库中提供了 <code>sync.Mutex</code> 互斥锁类型及其两个方法：</p>
<ul>
<li>Lock</li>
<li>Unlock</li>
</ul>
<p>我们可以通过在代码前调用 <code>Lock</code> 方法，在代码后调用 <code>Unlock</code>方法来保证一段代码的互斥执行我们也可以用 <code>defer</code> 语句来保证互斥锁一定会被解锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     &quot;sync&quot;</span><br><span class="line">     &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; SafeCounter 的并发使用是安全的。</span><br><span class="line">type SafeCounter struct &#123;</span><br><span class="line">     v map[string]int</span><br><span class="line">     mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Inc 增加给定 key 的计数器的值。</span><br><span class="line">func (c *SafeCounter) Inc(key string) &#123;</span><br><span class="line">     c.mux.Lock()</span><br><span class="line">     &#x2F;&#x2F; Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span><br><span class="line">     c.v[key]++</span><br><span class="line">     c.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Value 返回给定 key 的计数器的当前值。</span><br><span class="line">func (c *SafeCounter) Value(key string) int &#123;</span><br><span class="line">     c.mux.Lock()</span><br><span class="line">     &#x2F;&#x2F; Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span><br><span class="line">     defer c.mux.Unlock()</span><br><span class="line">     return c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">     c :&#x3D; SafeCounter&#123;v: make(map[string]int)&#125;</span><br><span class="line">     for i :&#x3D; 0; i &lt; 1000; i++ &#123;</span><br><span class="line">         go c.Inc(&quot;somekey&quot;)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     time.Sleep(time.Second)</span><br><span class="line">     fmt.Println(c.Value(&quot;somekey&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="全文完"><a href="#全文完" class="headerlink" title="全文完"></a>全文完</h3><p>整理自 golang 官方文档</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://tour.go-zh.org/welcome/1">官方在线教程</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Golang/" rel="tag"># Golang</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
            </div>
            <div class="post-nav-item">
                <a href="/2018/12/26/recursion-py/" rel="next" title="动态规划- Python代码实现">
                  动态规划- Python代码实现 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ifcalm</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">63k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">58 分钟</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>





<!-- 网站运行时间的设置 -->
<nobr>
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
</nobr>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("04/21/2020 15:54:40");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
